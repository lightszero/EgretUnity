var egret3d;
(function (egret3d) {
    /**
     * @class egret3d.DrawMode
     * @classdesc
     * 渲染模式
     * LINES 线框显示模式
     * POINTS 点显示模式
     * TRIANGLES 三角形显示模式
     * LINE_STRIP 连接线显示模式
     */
    var DrawMode = (function () {
        function DrawMode() {
        }
        return DrawMode;
    })();
    egret3d.DrawMode = DrawMode;
    /**
     * @private
     * @class egret3d.Egret3DDrive
     * @classdesc
     * 3d 驱动
     */
    var Egret3DDrive = (function () {
        function Egret3DDrive() {
        }
        /**
        * @language zh_CN
        * get GPU Context3D
        * 获取GPU交换链表程序
        * @param GPU_CONFIG
        * @param canvasRec
        * @event call
        */
        Egret3DDrive.requstContext3D = function (GPU_CONFIG, canvasRec, call) {
            console.log("requst GPU Config", GPU_CONFIG);
            if (!this.context3D || (this.context3D && !this.context3D.isLost)) {
                switch (GPU_CONFIG) {
                    case Egret3DDrive.OpenGLES_2_0:
                        var tapContext3D = Egret3DDrive.requestWEBGL(canvasRec);
                        Egret3DDrive.context3D = new egret3d.Context3DChild_OpenGLES_2_0(tapContext3D);
                        var ext = tapContext3D.getExtension('WEBGL_compressed_texture_s3tc');
                        var OES_texture_float = tapContext3D.getExtension("OES_texture_float");
                        ///if (!OES_texture_float) {
                        ///    alert("OES_texture_float Texture is not available");
                        ///}
                        ///else
                        ///    alert("OES_texture_float Texture");
                        Egret3DDrive.BLEND = tapContext3D.BLEND;
                        DrawMode.TRIANGLES = tapContext3D.TRIANGLES;
                        DrawMode.POINTS = tapContext3D.POINTS;
                        DrawMode.LINES = tapContext3D.LINES;
                        DrawMode.LINE_STRIP = tapContext3D.LINE_STRIP;
                        Egret3DDrive.FLOAT = tapContext3D.FLOAT;
                        Egret3DDrive.VERTEX_SHADER = tapContext3D.VERTEX_SHADER;
                        Egret3DDrive.FRAGMENT_SHADER = tapContext3D.FRAGMENT_SHADER;
                        Egret3DDrive.canvasRectangle = canvasRec;
                        Egret3DDrive.FRONT = tapContext3D.FRONT;
                        Egret3DDrive.BACK = tapContext3D.BACK;
                        Egret3DDrive.DEPTH_BUFFER_BIT = tapContext3D.DEPTH_BUFFER_BIT;
                        Egret3DDrive.ELEMENT_ARRAY_BUFFER = tapContext3D.ELEMENT_ARRAY_BUFFER;
                        Egret3DDrive.UNSIGNED_SHORT = tapContext3D.UNSIGNED_SHORT;
                        Egret3DDrive.NEAREST = tapContext3D.NEAREST;
                        Egret3DDrive.REPEAT = tapContext3D.REPEAT;
                        Egret3DDrive.ONE = tapContext3D.ONE;
                        Egret3DDrive.ZERO = tapContext3D.ZERO;
                        Egret3DDrive.SRC_ALPHA = tapContext3D.SRC_ALPHA;
                        Egret3DDrive.ONE_MINUS_SRC_ALPHA = tapContext3D.ONE_MINUS_SRC_ALPHA;
                        Egret3DDrive.SRC_COLOR = tapContext3D.SRC_COLOR;
                        Egret3DDrive.ONE_MINUS_SRC_COLOR = tapContext3D.ONE_MINUS_SRC_COLOR;
                        ;
                        Egret3DDrive.ColorFormat_RGB565 = tapContext3D.RGB565;
                        Egret3DDrive.ColorFormat_RGBA5551 = tapContext3D.RGB5_A1;
                        Egret3DDrive.ColorFormat_RGBA4444 = tapContext3D.RGBA4;
                        Egret3DDrive.ColorFormat_RGBA8888 = tapContext3D.RGBA;
                        Egret3DDrive.DEPTH_TEST = tapContext3D.DEPTH_TEST;
                        Egret3DDrive.CULL_FACE = tapContext3D.CULL_FACE;
                        Egret3DDrive.BLEND = tapContext3D.BLEND;
                        if (ext) {
                            Egret3DDrive.ColorFormat_DXT1_RGB = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            Egret3DDrive.ColorFormat_DXT1_RGBA = ext.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            Egret3DDrive.ColorFormat_DXT3_RGBA = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            Egret3DDrive.ColorFormat_DXT5_RGBA = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                        }
                        egret3d.ContextSamplerType.TEXTURE_0 = tapContext3D.TEXTURE0;
                        egret3d.ContextSamplerType.TEXTURE_1 = tapContext3D.TEXTURE1;
                        egret3d.ContextSamplerType.TEXTURE_2 = tapContext3D.TEXTURE2;
                        egret3d.ContextSamplerType.TEXTURE_3 = tapContext3D.TEXTURE3;
                        egret3d.ContextSamplerType.TEXTURE_4 = tapContext3D.TEXTURE4;
                        egret3d.ContextSamplerType.TEXTURE_5 = tapContext3D.TEXTURE5;
                        egret3d.ContextSamplerType.TEXTURE_6 = tapContext3D.TEXTURE6;
                        egret3d.ContextSamplerType.TEXTURE_7 = tapContext3D.TEXTURE7;
                        egret3d.ContextSamplerType.TEXTURE_8 = tapContext3D.TEXTURE8;
                        break;
                }
            }
            egret3d.CheckerboardTexture.texture.upload(Egret3DDrive.context3D);
            console.log("requst GPU Config", Egret3DDrive.context3D);
            egret3d.ShaderSystemTool.regist(call);
        };
        Egret3DDrive.requestWEBGL = function (viewPort) {
            Egret3DDrive.canvas = document.createElement("canvas");
            //Egret3DDrive.canvas.style.position = "absolute";
            //Egret3DDrive.canvas.style.zIndex = "-1";
            //Egret3DDrive.canvas.style.left = "0px";
            //Egret3DDrive.canvas.style.top = "0px";
            document.body.appendChild(this.canvas);
            Egret3DDrive.canvas.id = "egret3D";
            Egret3DDrive.canvas["x"] = viewPort.x;
            Egret3DDrive.canvas["y"] = viewPort.y;
            Egret3DDrive.canvas.width = viewPort.width;
            Egret3DDrive.canvas.height = viewPort.height;
            Egret3DDrive.clientRect = Egret3DDrive.canvas.getBoundingClientRect();
            Egret3DDrive.canvas.oncontextmenu = function () {
                return false;
            };
            var gl = this.canvas.getContext("experimental-webgl");
            if (!gl)
                gl = this.canvas.getContext("webgl");
            console.log("this.context3D ==>", this.context3D);
            if (!gl)
                alert("you drivers not suport webgl");
            return gl;
        };
        /**
        * @language zh_CN
        * 请求全屏
        */
        Egret3DDrive.requestFullScreen = function () {
            var dom = document.documentElement;
            if (dom.requestFullscreen) {
                dom.requestFullscreen();
            }
            else if (dom.webkitRequestFullScreen) {
                dom.webkitRequestFullScreen();
            }
        };
        /**
        * @language zh_CN
        * 退出全屏
        */
        Egret3DDrive.exitFullscreen = function () {
            var de = document;
            if (de.exitFullscreen) {
                de.exitFullscreen();
            }
            else if (de.webkitCancelFullScreen) {
                de.webkitCancelFullScreen();
            }
        };
        /**
        * @private
        */
        Egret3DDrive.Direct3D_Opengl_Auto = "Direct3D_Opengl_Auto";
        /**
        * @private
        */
        Egret3DDrive.Direct3D_9_0 = "Direct3D_9_0";
        /**
        * @private
        */
        Egret3DDrive.Direct3D_10_0 = "Direct3D_10_0";
        /**
        * @private
        */
        Egret3DDrive.Direct3D_11_0 = "Direct3D_11_0";
        /**
        * @private
        */
        Egret3DDrive.OpenGLES_2_0 = "OpenGLES_2_0";
        /**
        * @private
        */
        Egret3DDrive.OpenGLES_3_0 = "OpenGLES_3_0";
        /**
        * @private
        */
        Egret3DDrive.OpenGL = "OpenGL";
        /**
        * @private
        */
        Egret3DDrive.ColorFormat_DXT1_RGB = 0;
        /**
        * @private
        */
        Egret3DDrive.ColorFormat_DXT1_RGBA = 0;
        /**
        * @private
        */
        Egret3DDrive.ColorFormat_DXT3_RGBA = 0;
        /**
        * @private
        */
        Egret3DDrive.ColorFormat_DXT5_RGBA = 0;
        return Egret3DDrive;
    })();
    egret3d.Egret3DDrive = Egret3DDrive;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.MipmapData
    * @classdesc
    * 一个贴图的不同LOD层级数据
    * 生成 mipmap 可以使用 TextureUtil.generateMipMaps() 来制作lod mipmapdata
    *
    *
    * @see egret3d.base.Program3D
    * @see egret3d.base.IndexBuffer3D
    * @see egret3d.base.VertexBuffer3D
    * @see egret3d.base.Texture2D
    * @see egret3d.base.Shader
    * @see egret3d.base.CubeTexture
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MipmapData = (function () {
        function MipmapData(data, width, height) {
            this.data = data;
            this.width = width;
            this.height = height;
        }
        return MipmapData;
    })();
    egret3d.MipmapData = MipmapData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    ///export enum number { Unknown = 0x0000, RGB565 = 0x8d62, RGBA5551 = 0x8057, RGBA4444 = 0x8056, RGBA8888 = 0x1908, DXT1_RGB = 0x83f0, DXT1_RGBA = 0x83f1, DXT3_RGBA = 0x83f2, DXT5_RGBA = 0x83f3 };
    /**
    * @private
    */
    (function (InternalFormat) {
        InternalFormat[InternalFormat["PixelArray"] = 0] = "PixelArray";
        InternalFormat[InternalFormat["CompressData"] = 1] = "CompressData";
        InternalFormat[InternalFormat["ImageData"] = 2] = "ImageData";
    })(egret3d.InternalFormat || (egret3d.InternalFormat = {}));
    var InternalFormat = egret3d.InternalFormat;
    ;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var openGLES;
    (function (openGLES) {
        /**
        * @class egret3d.IndexBuffer3D
        * @classdesc
        * IndexBuffer3D 用于表示顶点索引列表，由图形子系统保留的图形元素构成。
        *
        * 定义一个立方图纹理，以便在渲染期间使用。立方体贴图可用于多种渲染技术，例如环境图、skyboxes 和 skylight 光照。
        * 不能直接创建 CubeTexture 对象，而应使用 Context3D createCubeTexture()。
        *
        * 由 IndexBuffer3D 对象管理的索引可用于从顶点流中选择顶点。索引为 16 位无符号整数。所允许的最大索引值为 65535 (0xffff)。图形子系统不会保留对提供给此对象的顶点的引用。修改或丢弃上载到此对象中的数据不会影响已存储的值。
    
        * 无法直接实例化 IndexBuffer3D。使用 Context3D.CreateIndexBuffer() 可创建实例
        * @see egret3d.Context3D
        * @see egret3d.base.CubeTexture
        * @version Egret 3.0
        * @platform Web,Native
        */
        var IndexBuffer3D = (function () {
            /**
            * @language zh_CN
            * 构造
            * @param buffer webglbuffer
            */
            function IndexBuffer3D(buffer) {
                this.buffer = buffer;
            }
            return IndexBuffer3D;
        })();
        openGLES.IndexBuffer3D = IndexBuffer3D;
    })(openGLES = egret3d.openGLES || (egret3d.openGLES = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var openGLES;
    (function (openGLES) {
        /**
        * @class egret3d.Program3D
        * @classdesc
        * Program3D 类表示上载到渲染上下文的一对渲染程序（也称为“编译后的着色器”）。
        *
        * 由 Program3D 对象管理的程序控制 drawTriangles 调用期间的整个三角形渲染。使用 upload 方法将二进制字节码上载到渲染上下文。（上载完成后，将不再引用原始字节数组中的数据；更改或放弃源字节数组不会更改该程序。）
        * 这些程序始终由两个相互关联的部分组成：顶点程序和片段程序。
        * 顶点程序会操作 VertexBuffer3D 中定义的数据，负责将顶点投影到剪辑空间，并将任何所需的顶点数据（例如颜色）传递到片段着色器。
        * 片段着色器会操作顶点程序传递给它的属性，并为三角形的每个栅格化片段生成颜色，最终形成像素颜色。请注意，片段程序在 3D 编程文献中具有多个名称，包括片段着色器和像素着色器。
        * 通过将相应 Program3D 实例传递到 Context3D setProgram() 方法，指定后续渲染操作要使用的程序对。
        * 您无法直接创建 Program3D 对象；请改用 Context3D createProgram() 方法。
        *
        * @see egret3d.Program3D
        * @see egret3d.IndexBuffer3D
        * @see egret3d.VertexBuffer3D
        * @see egret3d.Texture2D
        * @see egret3d.Shader
        * @see egret3d.CubeTexture
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Program3D = (function () {
            /**
            * @language zh_CN
            * 构造
            */
            function Program3D(pg3D) {
                /**
                * @language zh_CN
                * @private
                * WebGLBuffer 的引用
                */
                this.vertextAttribActive = false;
                this.program = pg3D;
            }
            return Program3D;
        })();
        openGLES.Program3D = Program3D;
    })(openGLES = egret3d.openGLES || (egret3d.openGLES = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var openGLES;
    (function (openGLES) {
        /**
        * @class egret3d.Shader
        * @classdesc
        * Shader 类表示上载到渲染上下文的一对渲染程序中的 顶点找色shader，或片段着色的shader 。
        *
        * shader 是基于 opengl es 2.0 标准 也就是webgl版本的shader着色器
        *
        * @see egret3d.Program3D
        * @see egret3d.IndexBuffer3D
        * @see egret3d.VertexBuffer3D
        * @see egret3d.Texture2D
        * @see egret3d.Shader
        * @see egret3d.CubeTexture
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Shader = (function () {
            /**
            * @language zh_CN
            * 构造
            */
            function Shader(shader) {
                this._shader = shader;
            }
            Object.defineProperty(Shader.prototype, "shader", {
                /**
                * @language zh_CN
                * @private
                * WebGLShader 的引用
                */
                get: function () {
                    return this._shader;
                },
                enumerable: true,
                configurable: true
            });
            /**
           * @language zh_CN
           * @private
           * 获取已经有的shader 的ID
           */
            Shader.ID_COUNT = 0;
            return Shader;
        })();
        openGLES.Shader = Shader;
    })(openGLES = egret3d.openGLES || (egret3d.openGLES = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var openGLES;
    (function (openGLES) {
        /**
        * @class egret3d.Texture2D
        * @classdesc
        * Texture 类表示上载到渲染上下文的二维纹理。
        *
        * 定义一个 2D 纹理，以便在渲染期间使用。
        * 无法直接实例化 Texture。使用 Context3D createTexture() 方法创建实例。
        * @see egret3d.base.Program3D
        * @see egret3d.base.IndexBuffer3D
        * @see egret3d.base.VertexBuffer3D
        * @see egret3d.base.Texture2D
        * @see egret3d.base.Shader
        * @see egret3d.base.CubeTexture
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Texture2D = (function () {
            /**
            * @language zh_CN
            * 构造
            * @param texture2D webgl贴图数据
            * @param context3D 上下文数据
            */
            function Texture2D(texture2D, context3D) {
                /**
                * @language zh_CN
                *
                * 二维纹理中的 像素宽度
                */
                this.width = 0;
                /**
                * @language zh_CN
                *
                * 二维纹理中的 像素高度
                */
                this.height = 0;
                this.gpu_texture = texture2D;
                this.context3D = context3D;
                this.mipmapDatas = new Array();
            }
            return Texture2D;
        })();
        openGLES.Texture2D = Texture2D;
    })(openGLES = egret3d.openGLES || (egret3d.openGLES = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var openGLES;
    (function (openGLES) {
        /**
        * @class egret3d.CubeTexture
        * @classdesc
        * CubeTexture 类表示上载到渲染上下文的立方体纹理。
        *
        * 定义一个立方图纹理，以便在渲染期间使用。立方体贴图可用于多种渲染技术，例如环境图、skyboxes 和 skylight 光照。
        * 不能直接创建 CubeTexture 对象，而应使用 Context3D createCubeTexture()。
        *
        *
        * @see egret3d.base.Texture2D
        * @see egret3d.base.CubeTexture
        * @version Egret 3.0
        * @platform Web,Native
        */
        var CubeTexture = (function () {
            function CubeTexture(cubeTexture) {
                this.gpu_texture = cubeTexture;
            }
            return CubeTexture;
        })();
        openGLES.CubeTexture = CubeTexture;
    })(openGLES = egret3d.openGLES || (egret3d.openGLES = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var openGLES;
    (function (openGLES) {
        /**
        * @class egret3d.IndexBuffer3D
        * @classdesc
        * IndexBuffer3D 用于表示顶点索引列表，由图形子系统保留的图形元素构成。
        * VertexBuffer3D 类表示上载到渲染上下文的一组顶点数据。
        * 使用 VertexBuffer3D 对象定义与一组顶点中每个点相关联的数据。您可以从 Vector 数组或 ByteArray 上载顶点数据。（上载完成后，将不再引用原始数组中的数据；更改或放弃源数组不会更改顶点数据。）
        * 与每个顶点相关联的数据采用应用程序定义的格式，并用作顶点着色器程序的输入。使用 Context3D.vertexAttribPointer  函数标识哪些值属于哪个顶点程序输入。一个顶点程序最多可以使用 8 个输入（也称为顶点属性寄存器）。每个输入可能需要 1 到 4 个 32 位值。例如，一个顶点的 [x,y,z] 位置坐标可以作为包含 3 个 32 位值的矢量传递到顶点程序。您最多可以为每个点提供 64 个 32 位值（256 字节）数据（但在这种情况下，单个顶点着色器无法使用所有数据）。
        * @see egret3d.Context3D
        * @see egret3d.base.CubeTexture
        * @version Egret 3.0
        * @platform Web,Native
        */
        var VertexBuffer3D = (function () {
            /**
            * @language zh_CN
            * 构造
            * @param buffer webglbuffer
            */
            function VertexBuffer3D(buffer) {
                this.buffer = buffer;
            }
            return VertexBuffer3D;
        })();
        openGLES.VertexBuffer3D = VertexBuffer3D;
    })(openGLES = egret3d.openGLES || (egret3d.openGLES = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
       * @class egret3d.FrameBuffer
       * @classdesc
       * FrameBuffer 类提供了用于呈现几何定义图形的上下文的帧缓冲对象。
       *
       * 渲染上下文包括一个绘图表面及其关联的资源帧缓冲对象
       * 通过context creatFrameBuffer 来创建，不能直接使用 new 的方式实例化
       * @see egret3d.base.Program3D
       * @see egret3d.base.IndexBuffer3D
       * @see egret3d.base.VertexBuffer3D
       * @see egret3d.base.Texture2D
       * @see egret3d.base.Shader
       * @see egret3d.base.CubeTexture
       * @version Egret 3.0
       * @platform Web,Native
       */
    var FrameBuffer = (function () {
        function FrameBuffer() {
        }
        return FrameBuffer;
    })();
    egret3d.FrameBuffer = FrameBuffer;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Context3DChild_OpenGLES_2_0
    * @classdesc
    * Context3DChild_OpenGLES_2_0  implements egret3d.Context3D
    * 3d设备数据
    */
    var Context3DChild_OpenGLES_2_0 = (function () {
        /**
        * @language zh_CN
        * 构造
        * @param context3D
        */
        function Context3DChild_OpenGLES_2_0(context3D) {
            this.gl = context3D;
            egret3d.ContextSamplerType.LINEAR = this.gl.LINEAR;
            egret3d.ContextSamplerType.NEAREST = this.gl.NEAREST;
            egret3d.ContextSamplerType.REPEAT = this.gl.REPEAT;
            ///enable necessry extensions.
            ///var OES_texture_float_linear = this.gl.getExtension("OES_texture_float_linear");
            //var OES_texture_float = this.gl.getExtension("OES_texture_float");
            ///var OES_texture_half_float = this.gl.getExtension("OES_texture_half_float");
            ///var OES_texture_half_float_linear = this.gl.getExtension("OES_texture_half_float_linear");
            ///var OES_standard_derivatives = this.gl.getExtension("OES_standard_derivatives");
            ///var WEBGL_draw_buffers = this.gl.getExtension("WEBGL_draw_buffers");
            ///var WEBGL_depth_texture = this.gl.getExtension("WEBGL_depth_texture");
            //if (!OES_texture_float) {
            //    alert("OES_texture_float Texture is not available");
            //}
        }
        Object.defineProperty(Context3DChild_OpenGLES_2_0.prototype, "version", {
            /**
            * @language zh_CN
            * 版本号
            *
            * @param context3D
            */
            get: function () {
                return "";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Context3DChild_OpenGLES_2_0.prototype, "isLost", {
            get: function () {
                /// need to add instance 
                return false;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 版本号
        * 视口设置定义
        * @param x position X
        * @param y position Y
        * @param width  3D canvas width
        * @param height  3D canvas  height
        */
        Context3DChild_OpenGLES_2_0.prototype.viewPort = function (x, y, width, height) {
            this.gl.viewport(x, y, width, height);
        };
        /**
        * @language zh_CN
        * 创建 显卡程序
        * @param vsShader
        * @param fsShader
        */
        Context3DChild_OpenGLES_2_0.prototype.creatProgram = function (vsShader, fsShader) {
            var shaderProgram = this.gl.createProgram();
            this.gl.attachShader(shaderProgram, vsShader.shader);
            this.gl.attachShader(shaderProgram, fsShader.shader);
            this.gl.linkProgram(shaderProgram);
            var p = this.gl.getProgramParameter(shaderProgram, this.gl.LINK_STATUS);
            if (!p) {
                alert("vsShader error" + this.gl.getShaderInfoLog(vsShader.shader));
                alert("fsShader error" + this.gl.getShaderInfoLog(fsShader.shader));
            }
            var program = new egret3d.openGLES.Program3D(shaderProgram);
            return program;
        };
        /**
        * @language zh_CN
        * 创建 顶点索引流
        * @param indexData
        */
        Context3DChild_OpenGLES_2_0.prototype.creatIndexBuffer = function (indexData) {
            var indexDataArray = new Uint16Array(indexData);
            var indexBuffer = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indexDataArray, this.gl.STATIC_DRAW);
            return new egret3d.openGLES.IndexBuffer3D(indexBuffer);
        };
        /**
        * @language zh_CN
        * 创建 顶点数据流
        * @param vertexData
        */
        Context3DChild_OpenGLES_2_0.prototype.creatVertexBuffer = function (vertexData) {
            var vertexDataArray = new Float32Array(vertexData);
            var vertexBuffer = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertexBuffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexDataArray, this.gl.STATIC_DRAW);
            return new egret3d.openGLES.VertexBuffer3D(vertexBuffer);
        };
        /// public upLoadTextureData(mipLevel: number, texture: Texture2D , data:any ) {
        ///     /// 启用二维纹理
        ///     ///this.gl.enable( this.gl.TEXTURE );
        ///     this.gl.bindTexture(this.gl.TEXTURE_2D, texture.texture2D);
        ///     ///if (typeof (data) == HTMLImageElement) {
        ///     /// this.gl.texImage2D(this.gl.TEXTURE_2D, mipLevel, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, data);
        ///     ///}
        ///     this.gl.texImage2D(this.gl.TEXTURE_2D, mipLevel, this.gl.RGBA, 128, 128, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, data ) ;
        ///
        ///     this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
        ///     this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
        ///     this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
        ///     this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
        /// }
        /**
        * @language zh_CN
        * 设置2D纹理状态
        * @param min_filter
        * @param mag_filter
        * @param wrap_u_filter
        * @param wrap_v_filter
        */
        Context3DChild_OpenGLES_2_0.prototype.setTexture2DSamplerState = function (min_filter, mag_filter, wrap_u_filter, wrap_v_filter) {
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, min_filter);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, mag_filter);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, wrap_u_filter);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, wrap_v_filter);
        };
        /**
        * @language zh_CN
        * 提交2D纹理
        * @param mipLevel
        * @param texture
        */
        Context3DChild_OpenGLES_2_0.prototype.upLoadTextureData = function (mipLevel, texture) {
            this.gl.bindTexture(this.gl.TEXTURE_2D, texture.gpu_texture);
            if (texture.gpu_internalformat == egret3d.InternalFormat.ImageData) {
                this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
                this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, texture.image);
                this.gl.generateMipmap(this.gl.TEXTURE_2D);
            }
            else if (texture.gpu_internalformat == egret3d.InternalFormat.CompressData) {
                this.upLoadCompressedTexture2D(mipLevel, texture);
            }
            else if (texture.gpu_internalformat == egret3d.InternalFormat.PixelArray) {
                this.gl.texImage2D(this.gl.TEXTURE_2D, mipLevel, texture.gpu_colorformat, texture.mipmapDatas[mipLevel].width, texture.mipmapDatas[mipLevel].height, texture.gpu_border, texture.gpu_colorformat, this.gl.UNSIGNED_BYTE, texture.mipmapDatas[mipLevel].data);
                this.gl.generateMipmap(this.gl.TEXTURE_2D);
            }
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
        };
        /**
        * @language zh_CN
        * 提交2D压缩纹理
        * @param mipLevel
        * @param texture
        */
        Context3DChild_OpenGLES_2_0.prototype.upLoadCompressedTexture2D = function (mipLevel, texture) {
            this.gl.bindTexture(this.gl.TEXTURE_2D, texture.gpu_texture);
            this.gl.compressedTexImage2D(this.gl.TEXTURE_2D, mipLevel, texture.gpu_colorformat, texture.mipmapDatas[mipLevel].width, texture.mipmapDatas[mipLevel].height, texture.gpu_border, texture.mipmapDatas[mipLevel].data);
        };
        /**
        * @language zh_CN
        * 创建 2维贴图
        */
        Context3DChild_OpenGLES_2_0.prototype.creatTexture2D = function () {
            var texture = new egret3d.openGLES.Texture2D(this.gl.createTexture(), this);
            return texture;
        };
        /**
        * @language zh_CN
        * 创建 Cube贴图
        */
        Context3DChild_OpenGLES_2_0.prototype.creatCubeTexture = function () {
            return new egret3d.openGLES.CubeTexture(this.gl.createTexture());
        };
        /**
        * @language zh_CN
        *
        * @param tex
        */
        Context3DChild_OpenGLES_2_0.prototype.uploadCubetexture = function (tex) {
            /// 创建纹理并绑定纹理数据
            this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, tex.gpu_texture);
            this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, this.gl.RGB, this.gl.RGB, this.gl.UNSIGNED_BYTE, tex.image_right.imageData);
            this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, this.gl.RGB, this.gl.RGB, this.gl.UNSIGNED_BYTE, tex.image_left.imageData);
            this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, this.gl.RGB, this.gl.RGB, this.gl.UNSIGNED_BYTE, tex.image_up.imageData);
            this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, this.gl.RGB, this.gl.RGB, this.gl.UNSIGNED_BYTE, tex.image_down.imageData);
            this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, this.gl.RGB, this.gl.RGB, this.gl.UNSIGNED_BYTE, tex.image_back.imageData);
            this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, this.gl.RGB, this.gl.RGB, this.gl.UNSIGNED_BYTE, tex.image_front.imageData);
            ///this.gl.generateMipmap(this.gl.TEXTURE_CUBE_MAP);
            ///gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
            ///this.gl.texParameterf(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR_MIPMAP_NEAREST);
            ///this.gl.texParameterf(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_NEAREST);
            ///this.gl.texParameterf(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            ///this.gl.texParameterf(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            ///this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, min_filter);
            ///this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, mag_filter);
            ///this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, wrap_u_filter);
            ///this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, wrap_v_filter);
        };
        /**
        * @language zh_CN
        *
        * @param width
        * @param height
        * @param format
        */
        Context3DChild_OpenGLES_2_0.prototype.createFramebuffer = function (width, height, format) {
            var rttframeBuffer = this.gl.createFramebuffer();
            var texture2D = this.creatTexture2D();
            var depthRenderbuffer = this.gl.createRenderbuffer();
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, rttframeBuffer);
            this.gl.bindTexture(this.gl.TEXTURE_2D, texture2D.gpu_texture);
            var float = new Float32Array(32 * 32 * 4);
            for (var i = 0; i < 32 * 32; i++) {
                float[i] = 1.0;
                float[i + 1] = 1.0;
                float[i + 2] = 1.0;
                float[i + 3] = 1.0;
            }
            switch (format) {
                case egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB:
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGB, width, height, 0, this.gl.RGB, this.gl.UNSIGNED_BYTE, null);
                    break;
                case egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGBA:
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
                    break;
                case egret3d.FrameBufferFormat.FLOAT_RGB:
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGB, width, height, 0, this.gl.RGB, this.gl.FLOAT, float);
                    break;
                case egret3d.FrameBufferFormat.FLOAT_RGBA:
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.FLOAT, float);
                    break;
            }
            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, texture2D.gpu_texture, 0);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            ///this.gl.generateMipmap(this.gl.TEXTURE_2D);  
            ///配置渲染缓冲 
            this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, depthRenderbuffer);
            this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, width, height);
            texture2D.width = width;
            texture2D.height = height;
            texture2D.frameBuffer = rttframeBuffer;
            texture2D.renderbuffer = depthRenderbuffer;
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            this.gl.bindTexture(this.gl.TEXTURE_2D, null);
            this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
            return texture2D;
        };
        /**
        * @language zh_CN
        *
        * @param texture
        * @param enableDepthAndStencil
        * @param surfaceSelector
        */
        Context3DChild_OpenGLES_2_0.prototype.setRenderToTexture = function (texture, enableDepthAndStencil, surfaceSelector) {
            if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
            if (surfaceSelector === void 0) { surfaceSelector = 0; }
            if (enableDepthAndStencil) {
            }
            this.gl.viewport(0, 0, texture.width, texture.height);
            //if (this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER) != this.gl.FRAMEBUFFER_COMPLETE)
            //{
            //    alert("缓冲失败");
            //}
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.frameBuffer);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, texture.gpu_texture, 0);
            this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, texture.renderbuffer);
        };
        /**
        * @language zh_CN
        *
        */
        Context3DChild_OpenGLES_2_0.prototype.setRenderToBackBuffer = function () {
            this.gl.bindTexture(this.gl.TEXTURE_2D, null);
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
        };
        /**
        * @language zh_CN
        *
        * @param source
        */
        Context3DChild_OpenGLES_2_0.prototype.creatVertexShader = function (source) {
            var shader = this.gl.createShader(this.gl.VERTEX_SHADER);
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);
            var tmpShader = new egret3d.openGLES.Shader(shader);
            tmpShader.id = egret3d.openGLES.Shader.ID_COUNT++;
            return tmpShader;
        };
        /**
        * @language zh_CN
        *
        * @param source
        */
        Context3DChild_OpenGLES_2_0.prototype.creatFragmentShader = function (source) {
            var shader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);
            var tmpShader = new egret3d.openGLES.Shader(shader);
            tmpShader.id = egret3d.openGLES.Shader.ID_COUNT++;
            return tmpShader;
        };
        /**
        * @language zh_CN
        * 清除渲染区域的颜色 深度
        * @param r
        * @param g
        * @param b
        * @param a
        */
        Context3DChild_OpenGLES_2_0.prototype.clear = function (r, g, b, a) {
            this.gl.clearColor(r, g, b, a);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
            ///console.log( "clean" , r , g, b, a );
        };
        /**
        * @language zh_CN
        * 清除渲染区域的 深度
        * @param depth
        */
        Context3DChild_OpenGLES_2_0.prototype.clearDepth = function (depth) {
            this.gl.clearDepth(depth);
            this.gl.clear(this.gl.DEPTH_BUFFER_BIT);
        };
        /**
        * @language zh_CN
        * 清除渲染区域的 模板
        * @param stencil
        */
        Context3DChild_OpenGLES_2_0.prototype.clearStencil = function (stencil) {
            this.gl.clearStencil(stencil);
        };
        /**
        * @language zh_CN
        * 使用显卡着色器
        * @param program
        */
        Context3DChild_OpenGLES_2_0.prototype.setProgram = function (program) {
            this.gl.useProgram(program.program);
        };
        /**
        * @language zh_CN
        * 获取矩阵变量ID
        * @param program
        * @param name
        */
        Context3DChild_OpenGLES_2_0.prototype.getUniformLocation = function (programe3D, name) {
            return this.gl.getUniformLocation(programe3D.program, name);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param x
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform1f = function (location, x) {
            this.gl.uniform1f(location, x);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param v
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform1fv = function (location, v) {
            this.gl.uniform1fv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param x
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform1i = function (location, x) {
            this.gl.uniform1i(location, x);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param v
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform1iv = function (location, v) {
            this.gl.uniform1iv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param x
        * @param y
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform2f = function (location, x, y) {
            this.gl.uniform2f(location, x, y);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param v
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform2fv = function (location, v) {
            this.gl.uniform2fv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param x
        * @param y
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform2i = function (location, x, y) {
            this.gl.uniform2i(location, x, y);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param v
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform2iv = function (location, v) {
            this.gl.uniform2iv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param x
        * @param y
        * @param z
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform3f = function (location, x, y, z) {
            this.gl.uniform3f(location, x, y, z);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param v
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform3fv = function (location, v) {
            this.gl.uniform3fv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param x
        * @param y
        * @param z
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform3i = function (location, x, y, z) {
            this.gl.uniform3i(location, x, y, z);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param v
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform3iv = function (location, v) {
            this.gl.uniform3iv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param x
        * @param y
        * @param z
        * @param w
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform4f = function (location, x, y, z, w) {
            this.gl.uniform4f(location, x, y, z, w);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param v
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform4fv = function (location, v) {
            this.gl.uniform4fv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param x
        * @param y
        * @param z
        * @param w
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform4i = function (location, x, y, z, w) {
            this.gl.uniform4i(location, x, y, z, w);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param v
        */
        Context3DChild_OpenGLES_2_0.prototype.uniform4iv = function (location, v) {
            this.gl.uniform4iv(location, v);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param transpose
        * @param value
        */
        Context3DChild_OpenGLES_2_0.prototype.uniformMatrix2fv = function (location, transpose, value) {
            this.gl.uniformMatrix2fv(location, transpose, value);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param transpose
        * @param value
        */
        Context3DChild_OpenGLES_2_0.prototype.uniformMatrix3fv = function (location, transpose, value) {
            this.gl.uniformMatrix3fv(location, transpose, value);
        };
        /**
        * @language zh_CN
        * 传值给shader
        * @param location
        * @param transpose
        * @param value
        */
        Context3DChild_OpenGLES_2_0.prototype.uniformMatrix4fv = function (location, transpose, value) {
            this.gl.uniformMatrix4fv(location, transpose, value);
        };
        /**
        * @language zh_CN
        * 设置 绘制混合模式
        * @param src
        * @param dst
        */
        Context3DChild_OpenGLES_2_0.prototype.setBlendFactors = function (src, dst) {
            this.gl.blendFunc(src, dst);
        };
        /**
        * @language zh_CN
        * 设置 绘制剔除模式
        * @param mode
        */
        Context3DChild_OpenGLES_2_0.prototype.setCulling = function (mode) {
            this.gl.cullFace(mode);
        };
        /**
        * @language zh_CN
        * 开启 绘制模式
        * @param cap
        */
        Context3DChild_OpenGLES_2_0.prototype.enbable = function (cap) {
            this.gl.enable(cap);
        };
        /**
        * @language zh_CN
        * 关闭 绘制模式
        * @param cap
        */
        Context3DChild_OpenGLES_2_0.prototype.disable = function (cap) {
            this.gl.disable(cap);
        };
        /**
        * @language zh_CN
        * 开启 深度模式 及 深度测试比较模式
        * @param flag
        * @param compareMode
        */
        Context3DChild_OpenGLES_2_0.prototype.enableDepthTest = function (flag, compareMode) {
            if (compareMode === void 0) { compareMode = 0; }
            if (flag)
                this.gl.enable(this.gl.DEPTH_TEST);
        };
        /**
        * @language zh_CN
        * 获取顶点着色器变量 索引
        * @param programe
        * @param attribName
        * @returns 着色器变量
        */
        Context3DChild_OpenGLES_2_0.prototype.getShaderAttribLocation = function (programe, attribName) {
            return this.gl.getAttribLocation(programe.program, attribName);
        };
        /**
        * @language zh_CN
        * 指定顶点着色器变量索引 及机构
        * @param programe3D
        * @param index
        * @param size
        * @param dataType
        * @param normalized
        * @param stride
        * @param offset
        */
        Context3DChild_OpenGLES_2_0.prototype.vertexAttribPointer = function (programe3D, index, size, dataType, normalized, stride, offset) {
            this.gl.vertexAttribPointer(index, size, dataType, normalized, stride, offset);
            this.gl.enableVertexAttribArray(index);
        };
        /**
        * @language zh_CN
        * 实时传入显卡顶点着色器变量数组数据
        * @param floats
        * @param offest
        * @param numLen
        */
        Context3DChild_OpenGLES_2_0.prototype.setVertexShaderConstData = function (floats, offest, numLen) {
            this.gl.vertexAttrib4fv(offest, floats.subarray(offest, numLen));
        };
        /**
        * @language zh_CN
        * 实时传入显卡片段着色器变量数组数据
        * @param floats
        * @param offest
        * @param numLen
        */
        Context3DChild_OpenGLES_2_0.prototype.setFragmentShaderConstData = function (floats, offest, numLen) {
        };
        /**
        * @language zh_CN
        * 设置贴图采样 第一个参数并不是类型
        * @param samplerIndex
        * @param uniLocation
        * @param index
        * @param texture
        */
        Context3DChild_OpenGLES_2_0.prototype.setTexture2DAt = function (samplerIndex, uniLocation, index, texture) {
            this.gl.activeTexture(samplerIndex);
            this.gl.bindTexture(this.gl.TEXTURE_2D, texture.gpu_texture);
            this.gl.uniform1i(uniLocation, index);
        };
        /**
        * @language zh_CN
        * 设置贴图采样 第一个参数并不是类型
        * @param samplerIndex
        * @param uniLocation
        * @param index
        * @param texture
        */
        Context3DChild_OpenGLES_2_0.prototype.setCubeTextureAt = function (samplerIndex, uniLocation, index, texture) {
            this.gl.activeTexture(samplerIndex);
            this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, texture.gpu_texture);
            this.gl.uniform1i(uniLocation, index);
        };
        /**
        * @language zh_CN
        * 设置矩形裁切区域
        * @param rectangle
        */
        Context3DChild_OpenGLES_2_0.prototype.setScissorRectangle = function (rectangle) {
        };
        /**
        * @language zh_CN
        * 设置模板测试
        */
        Context3DChild_OpenGLES_2_0.prototype.setStencilReferenceValue = function () {
        };
        /**
        * @language zh_CN
        * 设置模板测试
        */
        Context3DChild_OpenGLES_2_0.prototype.setStencilActions = function (triangleFace, compareMode, actionOnBothPass, actionOnDepthFail, actionOnDepthPassStencilFail) {
        };
        /**
        * @language zh_CN
        * 绑定顶点Buffer
        * @param vertexBuffer
        */
        Context3DChild_OpenGLES_2_0.prototype.bindVertexBuffer = function (vertexBuffer) {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertexBuffer.buffer);
        };
        /**
        * @language zh_CN
        * 绘制模型元素
        * @param type 图元类型
        * @param first 第一个顶点索引
        * @param length 顶点个数
        */
        Context3DChild_OpenGLES_2_0.prototype.drawArrays = function (type, first, length) {
            this.gl.drawArrays(type, first, length);
        };
        /**
        * @language zh_CN
        * 绘制模型元素
        * @param type 图元类型
        * @param indexBuffer 索引数据
        * @param offset 顶点偏移
        * @param length 顶点个数
        */
        Context3DChild_OpenGLES_2_0.prototype.drawElement = function (type, indexBuffer, offset, length) {
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, indexBuffer.buffer);
            this.gl.drawElements(type, length, this.gl.UNSIGNED_SHORT, offset);
        };
        /**
        * @language zh_CN
        * 绘制提交
        */
        Context3DChild_OpenGLES_2_0.prototype.flush = function () {
            this.gl.flush();
        };
        return Context3DChild_OpenGLES_2_0;
    })();
    egret3d.Context3DChild_OpenGLES_2_0 = Context3DChild_OpenGLES_2_0;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * 渲染混合模式
    * BlendMode 类中的一个值，用于指定要使用的混合模式。 内部绘制位图的方法有两种。 如果启用了混合模式或外部剪辑遮罩，则将通过向矢量渲染器添加有位图填充的正方形来绘制位图。 如果尝试将此属性设置为无效值，则 Flash 运行时会将此值设置为 BlendMode.NORMAL。
    * blendMode 属性影响显示对象的每个像素。每个像素都由三种原色（红色、绿色和蓝色）组成，每种原色的值介于 0x00 和 0xFF 之间。Flash Player 或 Adobe AIR 将影片剪辑中一个像素的每种原色与背景中像素的对应颜色进行比较。例如，如果 blendMode 设置为 BlendMode.LIGHTEN，则 Flash Player 或 Adobe AIR 会将显示对象的红色值与背景的红色值进行比较，然后使用两者中较亮的一种颜色作为显示颜色的红色成分的值。
    * 下表将对 blendMode 设置进行说明。BlendMode 类定义可使用的字符串值。表中的插图显示应用于交叠于显示对象 (1) 之上的圆形显示对象 (2) 的 blendMode 值。
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (BlendMode) {
        /**
         * @language zh_CN
         * 将显示对象的每个像素的 Alpha 值应用于背景。
         * @version Egret 3.0
         * @platform Web,Native
         */
        BlendMode[BlendMode["ALPHA"] = 0] = "ALPHA";
        /**
         * @language zh_CN
         * 强制为该显示对象创建一个透明度组。
         * @version Egret 3.0
         * @platform Web,Native
         */
        BlendMode[BlendMode["LAYER"] = 1] = "LAYER";
        /**
        * @language zh_CN
        * 该显示对象出现在背景前面。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["NORMAL"] = 2] = "NORMAL";
        /**
        * @language zh_CN
        * 将显示对象的原色值与背景颜色的原色值相乘，然后除以 0xFF 进行标准化，从而得到较暗的颜色。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["MULTIPLY"] = 3] = "MULTIPLY";
        /**
        * @language zh_CN
        * 将显示对象的原色值添加到它的背景颜色中，上限值为 0xFF。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["ADD"] = 4] = "ADD";
        /**
        * @language zh_CN
        * 从背景颜色的值中减去显示对象原色的值，下限值为 0。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["SUB"] = 5] = "SUB";
        /**
        * @language zh_CN
        * 将显示对象颜色的补色（反色）与背景颜色的补色相除。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["DIV"] = 6] = "DIV";
        /**
        * @language zh_CN
        * 将显示对象颜色的补色（反色）与背景颜色的补色相乘，会产生漂白效果。
        * @version Egret 3.0
        * @platform Web,Native
        */
        BlendMode[BlendMode["SCREEN"] = 7] = "SCREEN";
    })(egret3d.BlendMode || (egret3d.BlendMode = {}));
    var BlendMode = egret3d.BlendMode;
    /**
     * @private
     * @class egret3d.ContextSamplerType
     * @classdesc
     * 贴图采样类型
     */
    var ContextSamplerType = (function () {
        function ContextSamplerType() {
        }
        return ContextSamplerType;
    })();
    egret3d.ContextSamplerType = ContextSamplerType;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.UV
     * @classdesc
     * UV类，用来存储模型顶点uv数据
     *
     * @see egret3d.geometry.GeometryData
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var UV = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function UV(u, v) {
            if (u === void 0) { u = 0; }
            if (v === void 0) { v = 0; }
            /**
            * @language zh_CN
            * u
            */
            this.u = 0;
            /**
            * @language zh_CN
            * v
            */
            this.v = 0;
            this.u = u;
            this.v = v;
        }
        return UV;
    })();
    egret3d.UV = UV;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Point
     * @classdesc
     * Point 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Point = (function () {
        /**
         * @language en_US
         * Creates a new point. If you pass no parameters to this method, a point is
         * created at(0,0).
         *
         * @param x The horizontal coordinate.
         * @param y The vertical coordinate.
         */
        /**
         * @language zh_CN
         * 创建一个Point实例
         * @param x
         * @param y
         */
        function Point(x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            this.x = x;
            this.y = y;
        }
        Object.defineProperty(Point.prototype, "length", {
            /**
             * @language en_US
             * The length of the line segment from(0,0) to this point.
             * @returns length
             */
            /**
             * @language zh_CN
             * 返回从(0, 0)到(x, y)的距离
             * @returns 当前2维向量的长度
             */
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language en_US
         * Adds the coordinates of another point to the coordinates of this point to
         * create a new point.
         *
         * @param v The point to be added.
         * @returns The new point.
         */
        /**
         * @language zh_CN
         * 当前Point加上v Point，结果返回新的实例
         * @param v
         */
        Point.prototype.add = function (v) {
            return new Point(this.x + v.x, this.y + v.y);
        };
        /**
         * @language en_US
         * Creates a copy of this Point object.
         *
         * @returns The new Point object.
         */
        /**
         * @language zh_CN
         * 克隆Point
         * @param 返回克隆后的Point
         */
        Point.prototype.clone = function () {
            return new Point(this.x, this.y);
        };
        /**
         * @language zh_CN
         * 复制源Point的值
         * @param sourcePoint
         */
        Point.prototype.copyFrom = function (sourcePoint) {
            this.x = sourcePoint.x;
            this.y = sourcePoint.y;
        };
        /**
         * @language en_US
         * Determines whether two points are equal. Two points are equal if they have
         * the same <i>x</i> and <i>y</i> values.
         *
         * @param toCompare The point to be compared.
         * @returns A value of <code>true</code> if the object is equal to this Point
         *         object; <code>false</code> if it is not equal.
         */
        /**
         * @language zh_CN
         * 比较两个Point是否全等
         * @param toCompare 被比较的Point
         */
        Point.prototype.equals = function (toCompare) {
            return (this.x == toCompare.x && this.y == toCompare.y);
        };
        /**
         * @language en_US
         * Scales the line segment between(0,0) and the current point to a set
         * length.
         *
         * @param thickness The scaling value. For example, if the current point is
         *                 (0,5), and you normalize it to 1, the point returned is
         *                  at(0,1).
         */
        /**
         * @language zh_CN
         * 当前Point标准化
         * @param thickness 使当前Point的长度为thickness 原点(0, 0)到(x, y)的距离
         */
        Point.prototype.normalize = function (thickness) {
            if (thickness === void 0) { thickness = 1; }
            if (this.length != 0) {
                var invLength = thickness / this.length;
                this.x *= invLength;
                this.y *= invLength;
                return;
            }
            throw "Cannot divide by zero length.";
        };
        /**
         * @language en_US
         * Offsets the Point object by the specified amount. The value of
         * <code>dx</code> is added to the original value of <i>x</i> to create the
         * new <i>x</i> value. The value of <code>dy</code> is added to the original
         * value of <i>y</i> to create the new <i>y</i> value.
         *
         * @param dx The amount by which to offset the horizontal coordinate,
         *           <i>x</i>.
         * @param dy The amount by which to offset the vertical coordinate, <i>y</i>.
         */
        /**
         * @language zh_CN
         * 当前Point偏移位置
         * @param dx 偏移的x坐标
         * @param dx 偏移的y坐标
         */
        Point.prototype.offset = function (dx, dy) {
            this.x += dx;
            this.y += dy;
        };
        /**
         * @language en_US
         * Subtracts the coordinates of another point from the coordinates of this
         * point to create a new point.
         *
         * @param v The point to be subtracted.
         * @returns The new point.
         */
        /**
         * @language zh_CN
         * 当前Point减去v Point,结果返回一个新实例
         * @param v
         * @returns 结果返回
         */
        Point.prototype.subtract = function (v) {
            return new Point(this.x - v.x, this.y - v.y);
        };
        /**
         * @language en_US
         * Returns a string that contains the values of the <i>x</i> and <i>y</i>
         * coordinates. The string has the form <code>"(x=<i>x</i>,
         * y=<i>y</i>)"</code>, so calling the <code>toString()</code> method for a
         * point at 23,17 would return <code>"(x=23, y=17)"</code>.
         *
         * @returns The string representation of the coordinates.
         */
        /**
        * @language zh_CN
        * 当前Point以字符串形式返回
        * @returns string
        */
        Point.prototype.toString = function () {
            return "[Point] (x=" + this.x + ", y=" + this.y + ")";
        };
        /**
         * @language en_US
         * Returns the distance between <code>pt1</code> and <code>pt2</code>.
         *
         * @param pt1 The first point.
         * @param pt2 The second point.
         * @returns The distance between the first and second points.
         */
        /**
        * @language zh_CN
        * 计算两个Point之间的距离
        * @returns 返回两个Point之间的距离
        */
        Point.distance = function (pt1, pt2) {
            var dx = pt2.x - pt1.x;
            var dy = pt2.y - pt1.y;
            return Math.sqrt(dx * dx + dy * dy);
        };
        return Point;
    })();
    egret3d.Point = Point;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Vector3D
     * @classdesc
     * 用 Vector3D 表示三维空间中的位置,也可以做4维向量,当为3维向量时w始终为0。
     * 定义了一个三元的浮点向量
     * 当使用一个向量表示一个表面法线时，向量应该是标准化的
     * 其他用途的定向矢量的大小不变。当用作一个点，元素的矢量表示在三维空间中的位置
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Vector3D = (function () {
        /**
        * @language en_US
        * Creates an instance of a Vector3D object. If you do not specify a。
        * parameter for the constructor, a Vector3D object is created with
        * the elements (0,0,0,0).
        *
        * @param x The first element, such as the x coordinate.
        * @param y The second element, such as the y coordinate.
        * @param z The third element, such as the z coordinate.
        * @param w An optional element for additional data such as the angle
        *          of rotation.
        */
        /**
        * @language zh_CN
        * 创建一个对象实例，默认为(0, 0, 0, 0)
        */
        function Vector3D(x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 0; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        Object.defineProperty(Vector3D.prototype, "a", {
            /**
            * @language en_US
            *  得到w分量
            */
            get: function () {
                return this.w;
            },
            /**
            * @language en_US
            *  设置w分量
            */
            set: function (value) {
                this.w = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "r", {
            /**
            * @language en_US
            *  得到x分量
            */
            get: function () {
                return this.x;
            },
            /**
            * @language en_US
            *  设置x分量
            */
            set: function (value) {
                this.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "g", {
            /**
            * @language en_US
            *  得到y分量
            */
            get: function () {
                return this.y;
            },
            /**
            * @language en_US
            *  设置y分量
            */
            set: function (value) {
                this.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "b", {
            /**
            * @language en_US
            *  得到z分量
            */
            get: function () {
                return this.z;
            },
            /**
            * @language en_US
            *  设置z分量
            */
            set: function (value) {
                this.z = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "length", {
            /**
            * @language en_US
            * The length, magnitude, of the current Vector3D object from the
            * origin (0,0,0) to the object's x, y, and z coordinates. The w
            * property is ignored. A unit vector has a length or magnitude of
            * one.
            */
            /**
            * @language zh_CN
            * 向量的长度，原点(0, 0, 0)到(x, y, z)的距离
            */
            get: function () {
                return Math.sqrt(this.lengthSquared);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3D.prototype, "lengthSquared", {
            /**
            * @language en_US
            * The square of the length of the current Vector3D object, calculated。
            * using the x, y, and z properties. The w property is ignored. Use the
            * <code>lengthSquared()</code> method whenever possible instead of the
            * slower <code>Math.sqrt()</code> method call of the
            * <code>Vector3D.length()</code> method.
            */
            /**
            * @language zh_CN
            * 3维向量的坐标x的平方加 y的平方加 z的平方
            */
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language en_US
        * Adds the value of the x, y, and z elements of the current Vector3D。
        * object to the values of the x, y, and z elements of another Vector3D
        * object. The <code>add()</code> method does not change the current
        * Vector3D object. Instead, it returns a new Vector3D object with
        * the new values.
        *
        * <p>The result of adding two vectors together is a resultant vector.
        * One way to visualize the result is by drawing a vector from the
        * origin or tail of the first vector to the end or head of the second
        * vector. The resultant vector is the distance between the origin
        * point of the first vector and the end point of the second vector.
        * </p>
        */
        /**
        * @language zh_CN
        * 向量相加，结果返回一个新实例
        * @returns Vector3D 结果返回
        */
        Vector3D.prototype.add = function (a) {
            return new Vector3D(this.x + a.x, this.y + a.y, this.z + a.z, this.w + a.w);
        };
        /**
        * @language en_US
        * Returns a new Vector3D object that is an exact copy of the current
        * Vector3D object.
        *
        * @returns A new Vector3D object that is a copy of the current
        * Vector3D object.
        */
        /**
        * @language zh_CN
        * 克隆一个Vector3D
        * @returns 返回克隆后的实例
        */
        Vector3D.prototype.clone = function () {
            return new Vector3D(this.x, this.y, this.z, this.w);
        };
        /**
        * @language en_US
        * Copies all of vector data from the source Vector3D object into the
        * calling Vector3D object.
        *
        * @param src The Vector3D object from which to copy the data.
        */
        /**
        * @language zh_CN
        * 复制Vector3D对象
        * @param src 数据源
        */
        Vector3D.prototype.copyFrom = function (src) {
            this.x = src.x;
            this.y = src.y;
            this.z = src.z;
            this.w = src.w;
        };
        /**
        * @language en_US
        * Returns a new Vector3D object that is perpendicular (at a right。
        * angle) to the current Vector3D and another Vector3D object. If the
        * returned Vector3D object's coordinates are (0,0,0), then the two
        * Vector3D objects are parallel to each other.
        *
        * <p>You can use the normalized cross product of two vertices of a
        * polygon surface with the normalized vector of the camera or eye
        * viewpoint to get a dot product. The value of the dot product can
        * identify whether a surface of a three-dimensional object is hidden
        * from the viewpoint.</p>
        *
        * @param a A second Vector3D object.
        * @returns A new Vector3D object that is perpendicular to the current
        *          Vector3D object and the Vector3D object specified as the
        *          parameter.
        */
        /**
        * @language zh_CN
        * 两个Vector3D进行叉乘 this 叉乘 a
        * 叉乘后的结果是这两条向量的垂直向量
        * @param a
        * @returns 返回叉乘结果
        */
        Vector3D.prototype.crossProduct = function (a) {
            return new Vector3D(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x, 1);
        };
        /**
        * @language en_US
        * Decrements the value of the x, y, and z elements of the current。
        * Vector3D object by the values of the x, y, and z elements of
        * specified Vector3D object. Unlike the
        * <code>Vector3D.subtract()</code> method, the
        * <code>decrementBy()</code> method changes the current Vector3D
        * object and does not return a new Vector3D object.
        *
        * @param a The Vector3D object containing the values to subtract from
        *          the current Vector3D object.
        */
        /**
        * @language zh_CN
        * 当前向量减去a向量，结果赋值给自己
        * @param a 减去的向量
        */
        Vector3D.prototype.decrementBy = function (a) {
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
        };
        /**
        * @language en_US
        * Returns the distance between two Vector3D objects. The。
        * <code>distance()</code> method is a static method. You can use it
        * directly as a method of the Vector3D class to get the Euclidean
        * distance between two three-dimensional points.
        *
        * @param pt1 A Vector3D object as the first three-dimensional point.
        * @param pt2 A Vector3D object as the second three-dimensional point.
        * @returns The distance between two Vector3D objects.
        */
        /**
        * @language zh_CN
        * 计算两个Vector3D之间的距离
        * @param pt1 坐标1
        * @param pt2 坐标2
        * @returns 两个Vector3D之间的距离
        */
        Vector3D.distance = function (pt1, pt2) {
            var x = (pt1.x - pt2.x);
            var y = (pt1.y - pt2.y);
            var z = (pt1.z - pt2.z);
            return Math.sqrt(x * x + y * y + z * z);
        };
        /**
        * @language en_US
        * If the current Vector3D object and the one specified as the。
        * parameter are unit vertices, this method returns the cosine of the
        * angle between the two vertices. Unit vertices are vertices that
        * point to the same direction but their length is one. They remove the
        * length of the vector as a factor in the result. You can use the
        * <code>normalize()</code> method to convert a vector to a unit
        * vector.
        *
        * <p>The <code>dotProduct()</code> method finds the angle between two
        * vertices. It is also used in backface culling or lighting
        * calculations. Backface culling is a procedure for determining which
        * surfaces are hidden from the viewpoint. You can use the normalized
        * vertices from the camera, or eye, viewpoint and the cross product of
        * the vertices of a polygon surface to get the dot product. If the dot
        * product is less than zero, then the surface is facing the camera or
        * the viewer. If the two unit vertices are perpendicular to each
        * other, they are orthogonal and the dot product is zero. If the two
        * vertices are parallel to each other, the dot product is one.</p>
        *
        * @param a The second Vector3D object.
        * @returns A scalar which is the dot product of the current Vector3D
        *          object and the specified Vector3D object.
        *
        */
        /**
        * @language zh_CN
        * 计算两个Vector3D的点积,返回两个Vector3D之间的夹角关系
        * @param a 另一个Vector3D
        * @returns 返回两个Vector3D之间的夹角关系
        */
        Vector3D.prototype.dotProduct = function (a) {
            return this.x * a.x + this.y * a.y + this.z * a.z;
        };
        /**
        * @language en_US
        * @param toCompare The Vector3D object to be compared with the current
        *                  Vector3D object.
        * @param allFour   An optional parameter that specifies whether the w
        *                  property of the Vector3D objects is used in the
        *                  comparison.
        * @returns A value of true if the specified Vector3D object is equal
        *          to the current Vector3D object; false if it is not equal.
        */
        /**
        * @language zh_CN
        * 求两个Vector3D的值是否全等
        * @param toCompare 与些Vector3D进行比较
        * @param allFour 是否比较w分量
        * @returns 全等返回true
        */
        Vector3D.prototype.equals = function (toCompare, allFour) {
            if (allFour === void 0) { allFour = false; }
            return (this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z && (!allFour || this.w == toCompare.w));
        };
        /**
        * @language en_US

        * Increments the value of the x, y, and z elements of the current
        * Vector3D object by the values of the x, y, and z elements of a
        * specified Vector3D object. Unlike the <code>Vector3D.add()</code>
        * method, the <code>incrementBy()</code> method changes the current
        * Vector3D object and does not return a new Vector3D object.
        *
        * @param a The Vector3D object to be added to the current Vector3D
        *          object.
        */
        /**
        * @language zh_CN
        * 当前Vector3D加等于a Vector3D，只加x y z 3个分量
        * @param a 加等a
        */
        Vector3D.prototype.incrementBy = function (a) {
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
        };
        /**
        * @language en_US
        * Sets the current Vector3D object to its inverse. The inverse object
        * is also considered the opposite of the original object. The value of
        * the x, y, and z properties of the current Vector3D object is changed
        * to -x, -y, and -z.
        */
        /**
        * @language zh_CN
        * 当前Vector3D x y z 3个分量取反
        */
        Vector3D.prototype.negate = function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
        };
        /**
        * @language en_US
        * Scales the line segment between(0,0) and the current point to a set
        * length.
        *
        * @param thickness The scaling value. For example, if the current
        * Vector3D object is (0,3,4), and you normalize it to
        * 1, the point returned is at(0,0.6,0.8).
        */
        /**
        * @language zh_CN
        * 当前Vector3D标准化
        * @param thickness 使当前Vector3D的长度为thickness 原点(0, 0, 0)到(x, y, z)的距离
        */
        Vector3D.prototype.normalize = function (thickness) {
            if (thickness === void 0) { thickness = 1; }
            if (this.length != 0) {
                var invLength = thickness / this.length;
                this.x *= invLength;
                this.y *= invLength;
                this.z *= invLength;
                return;
            }
        };
        /**
        * @language en_US
        * Scales the current Vector3D object by a scalar, a magnitude. The
        * Vector3D object's x, y, and z elements are multiplied by the scalar
        * number specified in the parameter. For example, if the vector is
        * scaled by ten, the result is a vector that is ten times longer. The
        * scalar can also change the direction of the vector. Multiplying the
        * vector by a negative number reverses its direction.
        *
        * @param s A multiplier (scalar) used to scale a Vector3D object.
        */
        /**
        * @language zh_CN
        * 当前Vector3D扩大s倍
        * @param s 扩大的倍数
        */
        Vector3D.prototype.scaleBy = function (s) {
            this.x *= s;
            this.y *= s;
            this.z *= s;
        };
        /**
        * @language en_US
        * Sets the members of Vector3D to the specified values
        *
        * @param xa The first element, such as the x coordinate.
        * @param ya The second element, such as the y coordinate.
        * @param za The third element, such as the z coordinate.
        */
        /**
        * @language zh_CN
        * 填充当前Vector3D的x, y, z
        * @param s 扩大的倍数
        */
        Vector3D.prototype.setTo = function (xa, ya, za) {
            this.x = xa;
            this.y = ya;
            this.z = za;
        };
        /**
        * @language en_US
        * Subtracts the value of the x, y, and z elements of the current
        * Vector3D object from the values of the x, y, and z elements of
        * another Vector3D object. The <code>subtract()</code> method does not
        * change the current Vector3D object. Instead, this method returns a
        * new Vector3D object with the new values.
        *
        * @param a The Vector3D object to be subtracted from the current
        *          Vector3D object.
        * @returns A new Vector3D object that is the difference between the
        *          current Vector3D and the specified Vector3D object.
        */
        /**
        * @language zh_CN
        * 当前Vector3D减去a Vector3D 结果返回新实例
        * @param a 减去的Vector3D
        * @returns 结果返回
        */
        Vector3D.prototype.subtract = function (a) {
            return new Vector3D(this.x - a.x, this.y - a.y, this.z - a.z);
        };
        /**
        * @language zh_CN
        * 当前Vector3D乘other Vector3D 结果返回新实例
        * @param a 相乘的Vector3D
        * @returns 结果返回
        */
        Vector3D.prototype.multiply = function (other) {
            return new Vector3D(this.x * other.x, this.y * other.y, this.z * other.z);
        };
        /**
        * @language zh_CN
        * 计算两个Vector3D之间的线性差值，结果为当前对象
        * @param v0 Vector3D 1
        * @param v1 Vector3D 2
        * @param t 时刻
        */
        Vector3D.prototype.lerp = function (v0, v1, t) {
            var v0x = v0.x, v0y = v0.y, v0z = v0.z, v0w = v0.w;
            var v1x = v1.x, v1y = v1.y, v1z = v1.z, v1w = v1.w;
            this.x = (v1x - v0x) * t + v0x;
            this.y = (v1y - v0y) * t + v0y;
            this.z = (v1z - v0z) * t + v0z;
            this.w = (v1w - v0w) * t + v0w;
        };
        /**
        * @language zh_CN
        * 当前Vector3D以字符串形式返回
        * @returns string
        */
        Vector3D.prototype.toString = function () {
            return "<" + this.x + ", " + this.y + ", " + this.z + ">";
        };
        /**
        * @language zh_CN
        * 解析字符串为Vector3D
        * @param str 格式用空格间隔开，只解析为x,y,z
        */
        Vector3D.prototype.parsing = function (str) {
            var strS = str.split(" ");
            if (strS.length < 3)
                return;
            this.x = parseFloat(strS[0]);
            this.y = parseFloat(strS[1]);
            this.z = parseFloat(strS[2]);
        };
        /**
        * @language en_US
        * The x axis defined as a Vector3D object with coordinates (1,0,0).
        */
        /**
        * @language zh_CN
        * X轴坐标 (1,0,0).
        */
        Vector3D.X_AXIS = new Vector3D(1, 0, 0);
        /**
        * @language en_US
        * The y axis defined as a Vector3D object with coordinates (0,1,0).
        */
        /**
        * @language zh_CN
        * Y轴坐标 (0,1,0).
        */
        Vector3D.Y_AXIS = new Vector3D(0, 1, 0);
        /**
        * @language en_US
        * The z axis defined as a Vector3D object with coordinates (0,0,1).
        */
        /**
        * @language zh_CN
        * Z轴坐标 (0,0,1).
        */
        Vector3D.Z_AXIS = new Vector3D(0, 0, 1);
        return Vector3D;
    })();
    egret3d.Vector3D = Vector3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Rectangle
     * @classdesc
     * Rectangle 类 表示矩形
     *
     * Rectangle 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。
     *
     * Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其它属性。
     *
     * 您可以使用 new Rectangle() 构造函数创建 Rectangle 对象。
     * @version Egret 3.0
     * @platform Web,Native
    
     */
    var Rectangle = (function () {
        /**
         * @language zh_CN
         * 创建一个新 Rectangle 对象，其左上角由 x 和 y 参数指定，并具有指定的 width 和 height 参数。
         * @param x 矩形左上角的 x 坐标。
         * @param y 矩形左上角的 y 坐标。
         * @param width 矩形的宽度
         * @param height 矩形的高度
         */
        function Rectangle(x, y, width, height) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (width === void 0) { width = 32; }
            if (height === void 0) { height = 32; }
            /**
            * @language zh_CN
            * 矩形左上角的 x 坐标
            */
            this.x = 0;
            /**
            * @language zh_CN
            * 矩形左上角的 y 坐标
            */
            this.y = 0;
            /**
            * @language zh_CN
            * 矩形的宽度
            */
            this.width = 0;
            /**
            * @language zh_CN
            * 矩形的高度
            */
            this.height = 0;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        return Rectangle;
    })();
    egret3d.Rectangle = Rectangle;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Quaternion
     * @classdesc
     * Quaternion类
     *
     * 定义了一个四元数表示物体在空间的旋转。
     * 四元数通常用作替代欧拉角和旋转矩阵的方式来实现平滑插值和避免万向节锁
     * 注意，这四元数类不自动保持四元数标准化。因此，在必要的时候，必须采取单位化的四元数，通过调用单位化方法
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Quaternion = (function () {
        /**
        * @language en_US
        * Creates a new Quaternion object.
        * @param x The x value of the quaternion.
        * @param y The y value of the quaternion.
        * @param z The z value of the quaternion.
        * @param w The w value of the quaternion.
        */
        /**
        * @language zh_CN
        * 创建一个四元数.
        * @param x
        * @param y
        * @param z
        * @param w
        */
        function Quaternion(x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 1; }
            /**
            * @language en_US
            * The x value of the quaternion.
            */
            /**
            * @language zh_CN
            * 四元数的x值.
            */
            this.x = 0;
            /**
            * @language en_US
            * The y value of the quaternion.
            */
            /**
            * @language zh_CN
            * 四元数的y值.
            */
            this.y = 0;
            /**
            * @language en_US
            * The z value of the quaternion.
            */
            /**
            * @language zh_CN
            * 四元数的z值.
            */
            this.z = 0;
            /**
            * @language en_US
            * The w value of the quaternion.
            */
            /**
            * @language zh_CN
            * 四元数的w值.
            */
            this.w = 1;
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        Object.defineProperty(Quaternion.prototype, "magnitude", {
            /**
            * @language en_US
            *
            * @returns the magnitude of the quaternion object.
            */
            /**
            * @language zh_CN
            *
            * 返回四元数的大小.
            * @param w
            * @returns 四元数的大小.
            */
            get: function () {
                return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language en_US
        * Fills the quaternion object with the result from a multiplication of two quaternion objects.
        *
        * @param    qa    The first quaternion in the multiplication.
        * @param    qb    The second quaternion in the multiplication.
        */
        /**
        * @language zh_CN
        * 两个四元数相乘,然后结果给当调用者.
        * @param qa 第一个四元数
        * @param qb 第二个四元数
        */
        Quaternion.prototype.multiply = function (qa, qb) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            this.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            this.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            this.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
        };
        /**
        * @language zh_CN
        * 四元数乘以一个3维向量，结果返回一个四元数
        * @param vector 相乘的向量
        * @param target 返回的结果，如果为null就会实例化一个四元数对象返回
        * @returns 返回相乘后的结果
        */
        Quaternion.prototype.multiplyVector = function (vector, target) {
            if (target === void 0) { target = null; }
            if (target === null) {
                target = new Quaternion();
            }
            var x2 = vector.x;
            var y2 = vector.y;
            var z2 = vector.z;
            target.w = -this.x * x2 - this.y * y2 - this.z * z2;
            target.x = this.w * x2 + this.y * z2 - this.z * y2;
            target.y = this.w * y2 - this.x * z2 + this.z * x2;
            target.z = this.w * z2 + this.x * y2 - this.y * x2;
            return target;
        };
        /**
        * @language en_US
        * Fills the quaternion object with values representing the given rotation around a vector.
        *
        * @param    axis    The axis around which to rotate
        * @param    angle    The angle in radians of the rotation.
        */
        /**
        * @language zh_CN
        * 创建一个以axis轴为中心旋转angle角度的四元数
        *
        * @param axis   旋转轴
        * @param angle  旋转角度
        */
        Quaternion.prototype.fromAxisAngle = function (axis, angle) {
            angle *= Math.PI / 180.0;
            var halfAngle = angle * 0.5;
            var sin_a = Math.sin(halfAngle);
            this.w = Math.cos(halfAngle);
            this.x = axis.x * sin_a;
            this.y = axis.y * sin_a;
            this.z = axis.z * sin_a;
            this.normalize();
        };
        /**
        * @language zh_CN
        * 返回四元数绕轴心和角度
        *
        * @param axis 轴心
        * @returns 角度
        */
        Quaternion.prototype.toAxisAngle = function (axis) {
            var sqrLength = this.x * this.x + this.y * this.y + this.z * this.z;
            var angle = 0;
            if (sqrLength > 0.0) {
                angle = 2.0 * Math.acos(this.w);
                sqrLength = 1.0 / Math.sqrt(sqrLength);
                axis.x = this.x * sqrLength;
                axis.y = this.y * sqrLength;
                axis.z = this.z * sqrLength;
            }
            else {
                angle = 0;
                axis.x = 1.0;
                axis.y = 0;
                axis.z = 0;
            }
            angle /= Math.PI / 180.0;
            return angle;
        };
        /**
        * @language en_US
        * Spherically interpolates between two quaternions, providing an interpolation between rotations with constant angle change rate.
        * @param qa The first quaternion to interpolate.
        * @param qb The second quaternion to interpolate.
        * @param t The interpolation weight, a value between 0 and 1.
        */
        /**
        * @language zh_CN
        * 两个四元数之间球形插值，插值之间提供旋转恒定角变化率。
        *
        * @param qa 四元数1
        * @param qb 四元数2
        * @param t 差值时刻
        */
        Quaternion.prototype.slerp = function (qa, qb, t) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            var dot = w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2;
            // shortest direction
            if (dot < 0) {
                dot = -dot;
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            if (dot < 0.95) {
                // interpolate angle linearly
                var angle = Math.acos(dot);
                var s = 1 / Math.sin(angle);
                var s1 = Math.sin(angle * (1 - t)) * s;
                var s2 = Math.sin(angle * t) * s;
                this.w = w1 * s1 + w2 * s2;
                this.x = x1 * s1 + x2 * s2;
                this.y = y1 * s1 + y2 * s2;
                this.z = z1 * s1 + z2 * s2;
            }
            else {
                // nearly identical angle, interpolate linearly
                this.w = w1 + t * (w2 - w1);
                this.x = x1 + t * (x2 - x1);
                this.y = y1 + t * (y2 - y1);
                this.z = z1 + t * (z2 - z1);
                var len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
                this.w *= len;
                this.x *= len;
                this.y *= len;
                this.z *= len;
            }
        };
        /**
        * @language en_US
        * Linearly interpolates between two quaternions.
        * @param qa The first quaternion to interpolate.
        * @param qb The second quaternion to interpolate.
        * @param t The interpolation weight, a value between 0 and 1.
        */
        /**
        * @language zh_CN
        * 两个四元数之间的线性插值
        *
        * @param qa 四元数1
        * @param qb 四元数2
        * @param t 差值时刻
        */
        Quaternion.prototype.lerp = function (qa, qb, t) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            var len;
            // shortest direction
            if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            this.w = w1 + t * (w2 - w1);
            this.x = x1 + t * (x2 - x1);
            this.y = y1 + t * (y2 - y1);
            this.z = z1 + t * (z2 - z1);
            len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
            this.w *= len;
            this.x *= len;
            this.y *= len;
            this.z *= len;
        };
        /**
        * @language en_US
        * Fills the quaternion object with values representing the given euler rotation.
        *
        * @param    ax        The angle in radians of the rotation around the ax axis.
        * @param    ay        The angle in radians of the rotation around the ay axis.
        * @param    az        The angle in radians of the rotation around the az axis.
        */
        /**
        * @language zh_CN
        * 用数值表示给定的欧拉旋转填充四元数对象。
        *
        * @param ax x轴旋转角度
        * @param ay y轴旋转角度
        * @param az z轴旋转角度
        */
        Quaternion.prototype.fromEulerAngles = function (ax, ay, az) {
            ax *= egret3d.Matrix3DUtils.DEGREES_TO_RADIANS;
            ay *= egret3d.Matrix3DUtils.DEGREES_TO_RADIANS;
            az *= egret3d.Matrix3DUtils.DEGREES_TO_RADIANS;
            var halfX = ax * 0.5, halfY = ay * 0.5, halfZ = az * 0.5;
            var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
            var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
            var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
            this.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            this.x = sinX * cosY * cosZ - cosX * sinY * sinZ;
            this.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
            this.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
            return this;
        };
        /**
        * @language en_US
        * Fills a target Vector3D object with the Euler angles that form the rotation represented by this quaternion.
        * @param target An optional Vector3D object to contain the Euler angles. If not provided, a new object is created.
        * @returns The Vector3D containing the Euler angles.
        */
        /**
        * @language zh_CN
        * 把四元数转成欧拉角返回
        *
        * @param target 转成的欧拉返回值，如果为null就新建一个对象返回
        * @retruns 转成的欧拉返回值
        */
        Quaternion.prototype.toEulerAngles = function (target) {
            if (target === void 0) { target = null; }
            if (target === null) {
                target = new egret3d.Vector3D();
            }
            target.x = Math.atan2(2.0 * (this.w * this.x + this.y * this.z), 1.0 - 2.0 * (this.x * this.x + this.y * this.y));
            var temp = 2.0 * (this.w * this.y - this.z * this.x);
            temp = egret3d.Matrix3DUtils.clampf(temp, -1.0, 1.0);
            target.y = Math.asin(temp);
            target.z = Math.atan2(2.0 * (this.w * this.z + this.x * this.y), 1.0 - 2.0 * (this.y * this.y + this.z * this.z));
            target.x /= egret3d.Matrix3DUtils.DEGREES_TO_RADIANS;
            target.y /= egret3d.Matrix3DUtils.DEGREES_TO_RADIANS;
            target.z /= egret3d.Matrix3DUtils.DEGREES_TO_RADIANS;
            return target;
        };
        /**
        * @language en_US
        * Normalises the quaternion object.
        */
        /**
        * @language zh_CN
        * 单位化四元数
        */
        Quaternion.prototype.normalize = function (val) {
            if (val === void 0) { val = 1; }
            var mag = val / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            this.x *= mag;
            this.y *= mag;
            this.z *= mag;
            this.w *= mag;
        };
        /**
        * @language en_US
        * Used to trace the values of a quaternion.
        *
        * @returns A string representation of the quaternion object.
        */
        /**
        * @language zh_CN
        * 以字符串形式返回四元数的值
        * @returns
        */
        Quaternion.prototype.toString = function () {
            return "{x:" + this.x + " y:" + this.y + " z:" + this.z + " w:" + this.w + "}";
        };
        /**
        * @language en_US
        * Converts the quaternion to a Matrix3D object representing an equivalent rotation.
        * @param target An optional Matrix3D container to store the transformation in. If not provided, a new object is created.
        * @returns A Matrix3D object representing an equivalent rotation.
        */
        /**
        * @language zh_CN
        * 把一个四元数转换成矩阵
        * @param target 返回转换后的矩阵，如果为null就新建一个对象返回
        * @see egret3d.geom.Matrix4_4
        * @returns 返回转换后的矩阵
        */
        Quaternion.prototype.toMatrix3D = function (target) {
            if (target === void 0) { target = null; }
            var rawData = egret3d.Matrix3DUtils.RAW_DATA_CONTAINER;
            var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
            var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
            var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;
            rawData[0] = xx - yy - zz + ww;
            rawData[4] = xy2 - zw2;
            rawData[8] = xz2 + yw2;
            rawData[12] = 0;
            rawData[1] = xy2 + zw2;
            rawData[5] = -xx + yy - zz + ww;
            rawData[9] = yz2 - xw2;
            rawData[13] = 0;
            rawData[2] = xz2 - yw2;
            rawData[6] = yz2 + xw2;
            rawData[10] = -xx - yy + zz + ww;
            rawData[14] = 0;
            rawData[3] = 0.0;
            rawData[7] = 0.0;
            rawData[11] = 0;
            rawData[15] = 1;
            if (!target)
                return new egret3d.Matrix4_4(new Float32Array(rawData));
            target.copyRawDataFrom(rawData);
            return target;
        };
        /**
        * @language en_US
        * Extracts a quaternion rotation matrix out of a given Matrix3D object.
        * @param matrix The Matrix3D out of which the rotation will be extracted.
        */
        /**
        * @language zh_CN
        * 用一个旋转矩阵生成四元数
        * @param matrix 旋转矩阵
        */
        Quaternion.prototype.fromMatrix = function (matrix) {
            var v = matrix.decompose(egret3d.Orientation3D.QUATERNION)[1];
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = v.w;
        };
        /**
        * @language en_US
        * Clones the quaternion.
        * @returns An exact duplicate of the current Quaternion.
        */
        /**
        * @language zh_CN
        * 克隆一个四元数
        * @returns 当前四元数复制后返回.
        */
        Quaternion.prototype.clone = function () {
            return new Quaternion(this.x, this.y, this.z, this.w);
        };
        /**
        * @language en_US
        * Rotates a point.
        * @param vector The Vector3D object to be rotated.
        * @param target An optional Vector3D object that will contain the rotated coordinates. If not provided, a new object will be created.
        * @returns A Vector3D object containing the rotated point.
        */
        /**
        * @language zh_CN
        * 旋转一个3量坐标点
        * @param vector 被旋转的对象
        * @param target 旋转后的坐标对象。如果为null，将创建一个新的对象
        * @returns 返回旋转后的坐标对象
        */
        Quaternion.prototype.rotatePoint = function (vector, target) {
            if (target === void 0) { target = null; }
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            if (target === null) {
                target = new egret3d.Vector3D();
            }
            // p*q'
            w1 = -this.x * x2 - this.y * y2 - this.z * z2;
            x1 = this.w * x2 + this.y * z2 - this.z * y2;
            y1 = this.w * y2 - this.x * z2 + this.z * x2;
            z1 = this.w * z2 + this.x * y2 - this.y * x2;
            target.x = -w1 * this.x + x1 * this.w - y1 * this.z + z1 * this.y;
            target.y = -w1 * this.y + x1 * this.z + y1 * this.w - z1 * this.x;
            target.z = -w1 * this.z - x1 * this.y + y1 * this.x + z1 * this.w;
            return target;
        };
        /**
        * @language en_US
        * Copies the data from a quaternion into this instance.
        * @param q The quaternion to copy from.
        */
        /**
        * @language zh_CN
        * 将数据从四元数复制到该实例
        * @param q 被复制的四元数对象
        */
        Quaternion.prototype.copyFrom = function (q) {
            this.x = q.x;
            this.y = q.y;
            this.z = q.z;
            this.w = q.w;
        };
        return Quaternion;
    })();
    egret3d.Quaternion = Quaternion;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Orientation3D
     * @classdesc
     * 定义 Orientation3D 常量
     * Matrix4_4.decompose 会分 axisAngle、eulerAngles、quaternion这3种类型进行分解
     * 比如: matrix.decompose(Orientation3D.QUATERNION)
     *
     * @see egret3d.geom.Matrix4_4
     * @see egret3d.geom.Quaternion
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Orientation3D = (function () {
        function Orientation3D() {
        }
        /**
        * @language zh_CN
        * 按轴旋转角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Orientation3D.AXIS_ANGLE = "axisAngle";
        /**
        * @language zh_CN
        * 按欧拉角旋转角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Orientation3D.EULER_ANGLES = "eulerAngles";
        /**
        * @language zh_CN
        * 四元数旋转角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Orientation3D.QUATERNION = "quaternion";
        return Orientation3D;
    })();
    egret3d.Orientation3D = Orientation3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Plane3D
     * @classdesc
     * Plane3D 类 3D空间中的平面表示数据
     * 由a,b,c,d4个分量组成 在三维空间中定义了一个平面 Ax + By + Cz + D = 0
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Plane3D = (function () {
        /**
         * @language en_US
         * Create a Plane3D with ABCD coefficients
         */
        /**
         * @language zh_CN
         * 创建一个平面实例
         * @param a
         * @param b
         * @param c
         * @param d
         */
        function Plane3D(a, b, c, d) {
            if (a === void 0) { a = 0; }
            if (b === void 0) { b = 0; }
            if (c === void 0) { c = 0; }
            if (d === void 0) { d = 0; }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
        }
        /**
         * @language zh_CN
         * 填充平面的各分量的值
         * @param a
         * @param b
         * @param c
         * @param d
         */
        Plane3D.prototype.setTo = function (a, b, c, d) {
            if (a === void 0) { a = 0; }
            if (b === void 0) { b = 0; }
            if (c === void 0) { c = 0; }
            if (d === void 0) { d = 0; }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
        };
        /**
         * @language en_US
         * Fills this Plane3D with the coefficients from 3 points in 3d space.
         * @param p0 Vector3D
         * @param p1 Vector3D
         * @param p2 Vector3D
         */
        /**
         * @language zh_CN
         * 由3个坐标来创建一个3d平面
         * @param p0 Vector3D
         * @param p1 Vector3D
         * @param p2 Vector3D
         */
        Plane3D.prototype.fromPoints = function (p0, p1, p2) {
            var d1x = p1.x - p0.x;
            var d1y = p1.y - p0.y;
            var d1z = p1.z - p0.z;
            var d2x = p2.x - p0.x;
            var d2y = p2.y - p0.y;
            var d2z = p2.z - p0.z;
            this.a = d1y * d2z - d1z * d2y;
            this.b = d1z * d2x - d1x * d2z;
            this.c = d1x * d2y - d1y * d2x;
            this.d = -(this.a * p0.x + this.b * p0.y + this.c * p0.z);
        };
        /**
         * @language en_US
         * Fills this Plane3D with the coefficients from the plane's normal and a point in 3d space.
         * @param normal Vector3D
         * @param point  Vector3D
         */
        /**
         * @language zh_CN
         * 由一条normal向量和一个坐标创建一个3d平面
         * @param normal Vector3D
         * @param point  Vector3D
         */
        Plane3D.prototype.fromNormalAndPoint = function (normal, point) {
            this.a = normal.x;
            this.b = normal.y;
            this.c = normal.z;
            this.d = -(this.a * point.x + this.b * point.y + this.c * point.z);
        };
        /**
         * @language en_US
         * Normalize this Plane3D
         * @returns Plane3D This Plane3D.
         */
        /**
         * @language zh_CN
         * 单位化3d平面
         * @returns 返回平面长度
         */
        Plane3D.prototype.normalize = function () {
            var len = Math.sqrt(this.a * this.a + this.b * this.b + this.c * this.c);
            if (len > 0.0) {
                var invLength = 1.0 / len;
                this.a *= invLength;
                this.b *= invLength;
                this.c *= invLength;
                this.d *= invLength;
            }
            return len;
        };
        /**
         * @language en_US
         * Returns the signed distance between this Plane3D and the point p.
         * @param p Vector3D
         * @returns Number
         */
        /**
         * @language zh_CN
         * 计算3d平面到点p的距离
         * @param p Vector3D
         * @returns 返回计算后的距离
         */
        Plane3D.prototype.distance = function (p) {
            return this.a * p.x + this.b * p.y + this.c * p.z + this.d;
        };
        /**
         * @language en_US
         * Classify a point against this Plane3D. (in front, back or intersecting)
         * @param p Vector3D
         * @param epsilon
         * @returns PlaneClassification.FRONT在平面正面
         * PlaneClassification.BACK在平面背面面
         * PlaneClassification.INTERSECT在平面上
         */
        /**
         * @language zh_CN
         * 计算3d平面和点p的空间关系
         * @param p Vector3D
         * @param epsilon 相对偏移值
         * @returns int Plane3.FRONT or Plane3D.BACK or Plane3D.INTERSECT
         */
        Plane3D.prototype.classifyPoint = function (p, epsilon) {
            if (epsilon === void 0) { epsilon = 0.01; }
            var dis = this.distance(p);
            if (dis < -epsilon) {
                return egret3d.PlaneClassification.BACK;
            }
            else if (dis > epsilon) {
                return egret3d.PlaneClassification.FRONT;
            }
            return egret3d.PlaneClassification.INTERSECT;
        };
        /**
         * @language zh_CN
         * 当前Plane3D以字符串形式返回
         * @returns string
         */
        Plane3D.prototype.toString = function () {
            return "Plane3D [a:" + this.a + ", b:" + this.b + ", c:" + this.c + ", d:" + this.d + "]";
        };
        // indicates the alignment of the plane
        /**
         * @private
         */
        Plane3D.ALIGN_ANY = 0;
        /**
         * @private
         */
        Plane3D.ALIGN_XY_AXIS = 1;
        /**
         * @private
         */
        Plane3D.ALIGN_YZ_AXIS = 2;
        /**
         * @private
         */
        Plane3D.ALIGN_XZ_AXIS = 3;
        return Plane3D;
    })();
    egret3d.Plane3D = Plane3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.CubeBoxBound
     * @classdesc
     * 可使用 CubeBoxBound 类 取得包围盒的数据。
     * 包含包围盒的各顶点信息，当包围盒要进行世界变换时，应当变换各顶点信息.
     * @version Egret 3.0
     * @platform Web,Native
     */
    var CubeBoxBound = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param min
        * @param max
        */
        function CubeBoxBound(min, max) {
            if (min === void 0) { min = new egret3d.Vector3D(); }
            if (max === void 0) { max = new egret3d.Vector3D(); }
            /**
            * @language zh_CN
            * 盒子最小点
            */
            this.min = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 盒子最大点
            */
            this.max = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 盒子顶点
            */
            this.vexData = new Array();
            /**
            * @language zh_CN
            * 盒子索引
            */
            this.indexData = new Array();
            /**
            * @language zh_CN
            * 盒子宽
            */
            this.width = 0;
            /**
            * @language zh_CN
            * 盒子高
            */
            this.heigth = 0;
            /**
            * @language zh_CN
            * 盒子长
            */
            this.depth = 0;
            /**
            * @language zh_CN
            * 盒子体积
            */
            this.volume = 0;
            /**
            * @language zh_CN
            * 盒子包围球中心点
            */
            this.center = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 盒子包围球半径
            */
            this.radius = 0;
            this.matTransform = new egret3d.Matrix4_4();
            this.min.copyFrom(min);
            this.max.copyFrom(max);
            this.calculateBox();
        }
        /**
        * @language zh_CN
        * 拷贝一个包围盒
        * @param box
        */
        CubeBoxBound.prototype.copyFrom = function (box) {
            this.min.copyFrom(box.min);
            this.max.copyFrom(box.max);
            this.calculateBox();
        };
        /**
        * @language zh_CN
        * 填充当前包围盒
        * @param box
        */
        CubeBoxBound.prototype.fillBox = function (min, max) {
            this.min.copyFrom(min);
            this.max.copyFrom(max);
            this.calculateBox();
        };
        /**
        * @language zh_CN
        * 检测一个点是否包围盒内
        * @param pos 检测的点
        * @returns 成功返回true
        */
        CubeBoxBound.prototype.inBox = function (pos) {
            if (pos.x <= this.max.x && pos.x >= this.min.x &&
                pos.y <= this.max.y && pos.y >= this.min.y &&
                pos.z <= this.max.z && pos.z >= this.min.z) {
                return true;
            }
            return false;
        };
        /**
        * @language zh_CN
        * 检测两个包围盒是否相交
        * @param box2 其中一个包围盒
        * @param boxIntersect 相交的包围盒
        * @returns 成功返回true
        */
        CubeBoxBound.prototype.intersectAABBs = function (box2, boxIntersect) {
            if (this.min.x > box2.max.x) {
                return false;
            }
            if (this.max.x < box2.min.x) {
                return false;
            }
            if (this.min.y > box2.max.y) {
                return false;
            }
            if (this.max.y < box2.min.y) {
                return false;
            }
            if (this.min.z > box2.max.z) {
                return false;
            }
            if (this.max.z < box2.min.z) {
                return false;
            }
            if (boxIntersect != null) {
                boxIntersect.min.x = Math.max(this.min.x, box2.min.x);
                boxIntersect.max.x = Math.min(this.max.x, box2.max.x);
                boxIntersect.min.y = Math.max(this.min.y, box2.min.y);
                boxIntersect.max.y = Math.min(this.max.y, box2.max.y);
                boxIntersect.min.z = Math.max(this.min.z, box2.min.z);
                boxIntersect.max.z = Math.min(this.max.z, box2.max.z);
            }
            return true;
        };
        Object.defineProperty(CubeBoxBound.prototype, "Transform", {
            /**
            * @language zh_CN
            * 得到变换矩阵
            * @returns 变换矩阵
            */
            get: function () {
                return this.matTransform;
            },
            /**
            * @language zh_CN
            * 设置变换矩阵
            * @param mat 变换矩阵
            */
            set: function (mat) {
                this.matTransform.copyFrom(mat);
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 以字符串形式返回box的值
        * @returns 字符串
        */
        CubeBoxBound.prototype.toString = function () {
            return "CubeBoxBound [min:(" + this.min.x + ", " + this.min.y + ", " + this.min.z + ") max:(" + this.max.x + ", " + this.max.y + ", " + this.max.z + ")]";
        };
        /**
        * @language zh_CN
        * 计算包围盒数据
        */
        CubeBoxBound.prototype.calculateBox = function () {
            this.vexData.length = 0;
            this.indexData.length = 0;
            var sub = this.max.subtract(this.min);
            this.vexData.push(this.min.x);
            this.vexData.push(this.min.y);
            this.vexData.push(this.min.z);
            this.vexData.push(this.min.x);
            this.vexData.push(this.min.y);
            this.vexData.push(this.min.z + sub.z);
            this.vexData.push(this.min.x + sub.x);
            this.vexData.push(this.min.y);
            this.vexData.push(this.min.z + sub.z);
            this.vexData.push(this.min.x + sub.x);
            this.vexData.push(this.min.y);
            this.vexData.push(this.min.z);
            this.vexData.push(this.max.x - sub.x);
            this.vexData.push(this.max.y);
            this.vexData.push(this.max.z - sub.z);
            this.vexData.push(this.max.x - sub.x);
            this.vexData.push(this.max.y);
            this.vexData.push(this.max.z);
            this.vexData.push(this.max.x);
            this.vexData.push(this.max.y);
            this.vexData.push(this.max.z);
            this.vexData.push(this.max.x);
            this.vexData.push(this.max.y);
            this.vexData.push(this.max.z - sub.z);
            this.indexData.push(0, 4, 7, 0, 7, 3, 2, 6, 5, 2, 5, 1, 4, 5, 6, 4, 6, 7, 0, 3, 2, 0, 2, 1, 0, 1, 5, 0, 5, 4, 3, 7, 6, 3, 6, 2);
            this.width = this.max.x - this.min.x;
            this.heigth = this.max.y - this.min.y;
            this.depth = this.max.z - this.min.z;
            this.volume = this.width * this.heigth * this.depth;
            var c = this.max.subtract(this.min);
            c.scaleBy(0.5);
            this.radius = c.length;
            this.center.copyFrom(this.min);
            var tmp = this.center.add(c);
            this.center.copyFrom(tmp);
        };
        return CubeBoxBound;
    })();
    egret3d.CubeBoxBound = CubeBoxBound;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Matrix4_4
     * @classdesc
     *
     * Matrix4_4 类表示一个转换矩阵，该矩阵确定三维 (3D) 显示对象的位置和方向。
     * 该矩阵可以执行转换功能，包括平移（沿 x、y 和 z 轴重新定位）、旋转和缩放（调整大小）.
     * Matrix4_4 类还可以执行透视投影，这会将 3D 坐标空间中的点映射到二维 (2D) 视图.
     * 单一矩阵可以将多个转换组合在一起，并一次性对 3D 显示对象应用这些转换.
     * 例如，可以将一个矩阵应用于 3D 坐标，以便依次执行旋转和平移.
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Matrix4_4 = (function () {
        /**
        * @language zh_CN
        * 构造
        * @param datas {number[16]}
        */
        function Matrix4_4(datas) {
            if (datas === void 0) { datas = null; }
            this.oRawData = new Float32Array(16);
            if (datas) {
                this.rawData = datas;
            }
            else
                this.rawData = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        }
        /**
        * @language en_US
        * Build a lookat matrix. (left-handed)
        * @param eye The eye position.
        * @param at The target position.
        * @param up The up direction.
        */
        /**
        * @language zh_CN
        * 生成一个注视目标的矩阵.
        * @param eye 眼睛的位置.
        * @param at 目标的位置.
        * @param up 向上的方向.
        */
        Matrix4_4.prototype.lookAt = function (eye, at, up) {
            var zaxis = at.subtract(eye);
            zaxis.normalize();
            var xaxis = up.crossProduct(zaxis);
            xaxis.normalize();
            var yaxis = zaxis.crossProduct(xaxis);
            this.rawData[0] = xaxis.x;
            this.rawData[1] = yaxis.x;
            this.rawData[2] = zaxis.x;
            this.rawData[3] = 0;
            this.rawData[4] = xaxis.y;
            this.rawData[5] = yaxis.y;
            this.rawData[6] = zaxis.y;
            this.rawData[7] = 0;
            this.rawData[8] = xaxis.z;
            this.rawData[9] = yaxis.z;
            this.rawData[10] = zaxis.z;
            this.rawData[11] = 0;
            this.rawData[12] = -xaxis.dotProduct(eye);
            this.rawData[13] = -yaxis.dotProduct(eye);
            this.rawData[14] = -zaxis.dotProduct(eye);
            this.rawData[15] = 1;
        };
        /**
        * @language en_US
        * Build a perspective projection matrix. (left-handed)
        * @param fovy .
        * @param aspect .
        * @param zn min z.
        * @param zf max z.
        */
        /**
        * @language zh_CN
        * 生成一个透视投影矩阵.
        * @param fovy 观察时y 轴方向的角度，就是观察范围夹角。
        * @param aspect 横纵比，在视空间宽度除以高度.
        * @param zn 近裁剪面位置Z值.
        * @param zf 远裁剪面位置Z值.
        */
        Matrix4_4.prototype.perspective = function (fovy, aspect, zn, zf) {
            var angle = fovy * (Math.PI / 180.0);
            var yScale = Math.tan((Math.PI - angle) / 2.0);
            var xScale = yScale / aspect;
            this.rawData[0] = xScale;
            this.rawData[1] = 0;
            this.rawData[2] = 0;
            this.rawData[3] = 0;
            this.rawData[4] = 0;
            this.rawData[5] = yScale;
            this.rawData[6] = 0;
            this.rawData[7] = 0;
            this.rawData[8] = 0;
            this.rawData[9] = 0;
            this.rawData[10] = zf / (zf - zn);
            this.rawData[11] = 1;
            this.rawData[12] = 0;
            this.rawData[13] = 0;
            this.rawData[14] = -zn * zf / (zf - zn);
            this.rawData[15] = 0;
        };
        /**
        * @language en_US
        * Build an ortho matrix. (left-handed)
        * @param w screen width.
        * @param h screen height.
        * @param zn min z.
        * @param zf max z.
        */
        /**
        * @language zh_CN
        * 生成一个透视投影矩阵.
        * @param w 屏幕的宽度。
        * @param h 屏幕的高度.
        * @param zn 近裁剪面位置Z值.
        * @param zf 远裁剪面位置Z值.
        */
        Matrix4_4.prototype.ortho = function (w, h, zn, zf) {
            this.rawData[0] = 2 / w;
            this.rawData[1] = 0;
            this.rawData[2] = 0;
            this.rawData[3] = 0;
            this.rawData[4] = 0;
            this.rawData[5] = 2 / h;
            this.rawData[6] = 0;
            this.rawData[7] = 0;
            this.rawData[8] = 0;
            this.rawData[9] = 0;
            this.rawData[10] = 1 / (zf - zn);
            this.rawData[11] = 0;
            this.rawData[12] = 0;
            this.rawData[13] = 0;
            this.rawData[14] = zn / (zn - zf);
            this.rawData[15] = 1;
        };
        /**
        * @language en_US
        * Build an ortho matrix. (left-handed)
        * @param l min x.
        * @param r max x.
        * @param b min y.
        * @param t max y.
        * @param zn min z.
        * @param zf max z.
        */
        /**
        * @language zh_CN
        * 生成一个透视投影矩阵.
        * @param l 观察时X轴最小值.
        * @param r 观察时X轴最大值.
        * @param b 观察时Y轴最小值。
        * @param t 观察时Y轴最大值.
        * @param zn 近裁剪面位置Z值.
        * @param zf 远裁剪面位置Z值.
        */
        Matrix4_4.prototype.orthoOffCenter = function (l, r, b, t, zn, zf) {
            this.rawData[0] = 2 / (r - 1);
            this.rawData[1] = 0;
            this.rawData[2] = 0;
            this.rawData[3] = 0;
            this.rawData[4] = 0;
            this.rawData[5] = 2 / (t - b);
            this.rawData[6] = 0;
            this.rawData[7] = 0;
            this.rawData[8] = 0;
            this.rawData[9] = 0;
            this.rawData[10] = 1 / (zf - zn);
            this.rawData[11] = 0;
            this.rawData[12] = (1 + r) / (1 - r);
            this.rawData[13] = (t + b) / (b - t);
            this.rawData[14] = zn / (zn - zf);
            this.rawData[15] = 1;
        };
        /**
        * @language en_US
        * matrix multiply
        * @param lhs .
        */
        /**
        * @language zh_CN
        * 通过将当前 Matrix4_4 对象与另一个 Matrix4_4 对象相乘来前置一个矩阵
        * @param lhs 目标矩阵.
        */
        Matrix4_4.prototype.append = function (lhs) {
            var m111 = this.rawData[0], m121 = this.rawData[4], m131 = this.rawData[8], m141 = this.rawData[12], m112 = this.rawData[1], m122 = this.rawData[5], m132 = this.rawData[9], m142 = this.rawData[13], m113 = this.rawData[2], m123 = this.rawData[6], m133 = this.rawData[10], m143 = this.rawData[14], m114 = this.rawData[3], m124 = this.rawData[7], m134 = this.rawData[11], m144 = this.rawData[15], m211 = lhs.rawData[0], m221 = lhs.rawData[4], m231 = lhs.rawData[8], m241 = lhs.rawData[12], m212 = lhs.rawData[1], m222 = lhs.rawData[5], m232 = lhs.rawData[9], m242 = lhs.rawData[13], m213 = lhs.rawData[2], m223 = lhs.rawData[6], m233 = lhs.rawData[10], m243 = lhs.rawData[14], m214 = lhs.rawData[3], m224 = lhs.rawData[7], m234 = lhs.rawData[11], m244 = lhs.rawData[15];
            this.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
            this.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
            this.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
            this.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
            this.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
            this.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
            this.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
            this.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
            this.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
            this.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
            this.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
            this.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
            this.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
            this.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
            this.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
            this.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
        };
        /**
        * @language en_US
        * matrix add
        * @param lhs
        * @returns
        */
        /**
        * @language zh_CN
        * 矩阵相加.
        * @param lhs 目标矩阵.
        * @returns 相加后的结果.
        */
        Matrix4_4.prototype.add = function (lhs) {
            var m111 = this.rawData[0], m121 = this.rawData[4], m131 = this.rawData[8], m141 = this.rawData[12], m112 = this.rawData[1], m122 = this.rawData[5], m132 = this.rawData[9], m142 = this.rawData[13], m113 = this.rawData[2], m123 = this.rawData[6], m133 = this.rawData[10], m143 = this.rawData[14], m114 = this.rawData[3], m124 = this.rawData[7], m134 = this.rawData[11], m144 = this.rawData[15], m211 = lhs.rawData[0], m221 = lhs.rawData[4], m231 = lhs.rawData[8], m241 = lhs.rawData[12], m212 = lhs.rawData[1], m222 = lhs.rawData[5], m232 = lhs.rawData[9], m242 = lhs.rawData[13], m213 = lhs.rawData[2], m223 = lhs.rawData[6], m233 = lhs.rawData[10], m243 = lhs.rawData[14], m214 = lhs.rawData[3], m224 = lhs.rawData[7], m234 = lhs.rawData[11], m244 = lhs.rawData[15];
            this.rawData[0] = m111 + m211;
            this.rawData[1] = m112 + m212;
            this.rawData[2] = m113 + m213;
            this.rawData[3] = m114 + m214;
            this.rawData[4] = m121 + m221;
            this.rawData[5] = m122 + m222;
            this.rawData[6] = m123 + m223;
            this.rawData[7] = m124 + m224;
            this.rawData[8] = m131 + m231;
            this.rawData[9] = m132 + m232;
            this.rawData[10] = m133 + m233;
            this.rawData[11] = m134 + m234;
            this.rawData[12] = m141 + m241;
            this.rawData[13] = m142 + m242;
            this.rawData[14] = m143 + m243;
            this.rawData[15] = m144 + m244;
            return this;
        };
        /**
        * @language en_US
        * matrix add
        * @param lhs
        * @returns reslut
        */
        /**
        * @language zh_CN
        * 矩阵相减.
        * @param lhs 目标矩阵.
        * @returns 相加减的结果.
        */
        Matrix4_4.prototype.sub = function (lhs) {
            var m111 = this.rawData[0], m121 = this.rawData[4], m131 = this.rawData[8], m141 = this.rawData[12], m112 = this.rawData[1], m122 = this.rawData[5], m132 = this.rawData[9], m142 = this.rawData[13], m113 = this.rawData[2], m123 = this.rawData[6], m133 = this.rawData[10], m143 = this.rawData[14], m114 = this.rawData[3], m124 = this.rawData[7], m134 = this.rawData[11], m144 = this.rawData[15], m211 = lhs.rawData[0], m221 = lhs.rawData[4], m231 = lhs.rawData[8], m241 = lhs.rawData[12], m212 = lhs.rawData[1], m222 = lhs.rawData[5], m232 = lhs.rawData[9], m242 = lhs.rawData[13], m213 = lhs.rawData[2], m223 = lhs.rawData[6], m233 = lhs.rawData[10], m243 = lhs.rawData[14], m214 = lhs.rawData[3], m224 = lhs.rawData[7], m234 = lhs.rawData[11], m244 = lhs.rawData[15];
            this.rawData[0] = m111 - m211;
            this.rawData[1] = m112 - m212;
            this.rawData[2] = m113 - m213;
            this.rawData[3] = m114 - m214;
            this.rawData[4] = m121 - m221;
            this.rawData[5] = m122 - m222;
            this.rawData[6] = m123 - m223;
            this.rawData[7] = m124 - m224;
            this.rawData[8] = m131 - m231;
            this.rawData[9] = m132 - m232;
            this.rawData[10] = m133 - m233;
            this.rawData[11] = m134 - m234;
            this.rawData[12] = m141 - m241;
            this.rawData[13] = m142 - m242;
            this.rawData[14] = m143 - m243;
            this.rawData[15] = m144 - m244;
            return this;
        };
        /**
        * @language zh_CN
        * 矩阵乘分量.
        * @param v .
        * @returns 返回一个相乘后的结果 矩阵.
        */
        Matrix4_4.prototype.mult = function (v) {
            this.rawData[0] *= v;
            this.rawData[1] *= v;
            this.rawData[2] *= v;
            this.rawData[3] *= v;
            this.rawData[4] *= v;
            this.rawData[5] *= v;
            this.rawData[6] *= v;
            this.rawData[7] *= v;
            this.rawData[8] *= v;
            this.rawData[9] *= v;
            this.rawData[10] *= v;
            this.rawData[11] *= v;
            this.rawData[12] *= v;
            this.rawData[13] *= v;
            this.rawData[14] *= v;
            this.rawData[15] *= v;
            return this;
        };
        /**
        * @language zh_CN
        * 创建一个欧拉旋转矩阵.
        * @param x 绕x轴旋转角度.
        * @param y 绕y轴旋转角度.
        * @param z 绕z轴旋转角度.
        */
        Matrix4_4.prototype.rotation = function (x, y, z) {
            this.appendRotation(x, egret3d.Vector3D.X_AXIS);
            this.appendRotation(y, egret3d.Vector3D.Y_AXIS);
            this.appendRotation(z, egret3d.Vector3D.Z_AXIS);
        };
        /**
        * @language zh_CN
        * 当前矩阵乘 (按axis轴旋转degrees角度创建出来的矩阵)
        * @param degrees 旋转角度.
        * @param axis 绕axis轴旋转角度.
        */
        Matrix4_4.prototype.appendRotation = function (degrees, axis) {
            var m = Matrix4_4.getAxisRotation(axis.x, axis.y, axis.z, degrees);
            ///this.append(m);
            var tmp = new Matrix4_4();
            var s, c;
            var angle = degrees * egret3d.Matrix3DUtils.DEGREES_TO_RADIANS;
            s = Math.sin(angle);
            c = Math.cos(angle);
            if (axis.x == 1) {
                tmp.rawData[0] = 1.0;
                tmp.rawData[1] = 0.0;
                tmp.rawData[2] = 0.0;
                tmp.rawData[3] = 0.0;
                tmp.rawData[4] = 0.0;
                tmp.rawData[5] = c;
                tmp.rawData[6] = s;
                tmp.rawData[7] = 0.0;
                tmp.rawData[8] = 0.0;
                tmp.rawData[9] = -s;
                tmp.rawData[10] = c;
                tmp.rawData[7] = 0.0;
                tmp.rawData[12] = 0.0;
                tmp.rawData[13] = 0.0;
                tmp.rawData[14] = 0.0;
                tmp.rawData[15] = 1.0;
            }
            if (axis.y == 1) {
                tmp.rawData[0] = c;
                tmp.rawData[1] = 0.0;
                tmp.rawData[2] = -s;
                tmp.rawData[3] = 0.0;
                tmp.rawData[4] = 0.0;
                tmp.rawData[5] = 1.0;
                tmp.rawData[6] = 0.0;
                tmp.rawData[7] = 0.0;
                tmp.rawData[8] = s;
                tmp.rawData[9] = 0.0;
                tmp.rawData[10] = c;
                tmp.rawData[11] = 0.0;
                tmp.rawData[12] = 0.0;
                tmp.rawData[13] = 0.0;
                tmp.rawData[14] = 0.0;
                tmp.rawData[15] = 1.0;
            }
            if (axis.z == 1) {
                tmp.rawData[0] = c;
                tmp.rawData[1] = s;
                tmp.rawData[2] = 0.0;
                tmp.rawData[3] = 0.0;
                tmp.rawData[4] = -s;
                tmp.rawData[5] = c;
                tmp.rawData[6] = 0.0;
                tmp.rawData[7] = 0.0;
                tmp.rawData[8] = 0.0;
                tmp.rawData[9] = 0.0;
                tmp.rawData[10] = 1.0;
                tmp.rawData[11] = 0.0;
                tmp.rawData[12] = 0.0;
                tmp.rawData[13] = 0.0;
                tmp.rawData[14] = 0.0;
                tmp.rawData[15] = 1.0;
            }
            this.append(tmp);
        };
        /**
        * @language zh_CN
        * 生成一个缩放矩阵
        * @param xScale x轴缩放
        * @param yScale y轴缩放
        * @param zScale z轴缩放
        */
        Matrix4_4.prototype.appendScale = function (xScale, yScale, zScale) {
            this.rawData[0] = xScale;
            this.rawData[1] = 0.0;
            this.rawData[2] = 0.0;
            this.rawData[4] = 0.0;
            this.rawData[5] = yScale;
            this.rawData[6] = 0.0;
            this.rawData[8] = 0.0;
            this.rawData[9] = 0.0;
            this.rawData[10] = zScale;
        };
        /**
        * @language zh_CN
        * 加上一个平移矩阵
        * @param x x轴坐标
        * @param y y轴坐标
        * @param z z轴坐标
        */
        Matrix4_4.prototype.appendTranslation = function (x, y, z) {
            this.rawData[12] += x;
            this.rawData[13] += y;
            this.rawData[14] += z;
        };
        /**
        * @language zh_CN
        * 返回一个当前矩阵的克隆矩阵
        * @returns 克隆后的矩阵
        */
        Matrix4_4.prototype.clone = function () {
            var ret = new Matrix4_4();
            ret.copyFrom(this);
            return ret;
        };
        /**
        * @language zh_CN
        * 给当前矩阵其中一行赋值
        * @param column 拷贝的行
        * @param vector3D 拷贝的值
        */
        Matrix4_4.prototype.copyColumnFrom = function (column, vector3D) {
            switch (column) {
                case 0:
                    this.rawData[0] = vector3D.x;
                    this.rawData[1] = vector3D.y;
                    this.rawData[2] = vector3D.z;
                    this.rawData[3] = vector3D.w;
                    break;
                case 1:
                    this.rawData[4] = vector3D.x;
                    this.rawData[5] = vector3D.y;
                    this.rawData[6] = vector3D.z;
                    this.rawData[7] = vector3D.w;
                    break;
                case 2:
                    this.rawData[8] = vector3D.x;
                    this.rawData[9] = vector3D.y;
                    this.rawData[10] = vector3D.z;
                    this.rawData[11] = vector3D.w;
                    break;
                case 3:
                    this.rawData[12] = vector3D.x;
                    this.rawData[13] = vector3D.y;
                    this.rawData[14] = vector3D.z;
                    this.rawData[15] = vector3D.w;
                    break;
                default:
            }
        };
        /**
        * @language zh_CN
        * 拷贝矩阵中的其中一行 把值存在vector3D.
        * @param column 拷贝的行
        * @param vector3D 拷贝存值目标
        */
        Matrix4_4.prototype.copyRowTo = function (column, vector3D) {
            switch (column) {
                case 0:
                    vector3D.x = this.rawData[0];
                    vector3D.y = this.rawData[1];
                    vector3D.z = this.rawData[2];
                    vector3D.w = this.rawData[3];
                    break;
                case 1:
                    vector3D.x = this.rawData[4];
                    vector3D.y = this.rawData[5];
                    vector3D.z = this.rawData[6];
                    vector3D.w = this.rawData[7];
                    break;
                case 2:
                    vector3D.x = this.rawData[8];
                    vector3D.y = this.rawData[9];
                    vector3D.z = this.rawData[10];
                    vector3D.w = this.rawData[11];
                    break;
                case 3:
                    vector3D.x = this.rawData[12];
                    vector3D.y = this.rawData[13];
                    vector3D.z = this.rawData[14];
                    vector3D.w = this.rawData[15];
                    break;
                default:
            }
        };
        /**
        * @language zh_CN
        * 把一个矩阵的值赋给当前矩阵.
        * @param sourceMatrix3D 源矩阵.
        * @returns 返回当前矩阵
        */
        Matrix4_4.prototype.copyFrom = function (sourceMatrix3D) {
            var len = sourceMatrix3D.rawData.length;
            for (var c = 0; c < len; c++)
                this.rawData[c] = sourceMatrix3D.rawData[c];
            return this;
        };
        /**
        * @language zh_CN
        * 把一个 float 数组赋值给当前矩阵.
        * @param vector 源数组.
        * @param index 从数组的index 开始copy.
        * @param transpose 是否转置当前矩阵.
        */
        Matrix4_4.prototype.copyRawDataFrom = function (vector, index, transpose) {
            if (index === void 0) { index = 0; }
            if (transpose === void 0) { transpose = false; }
            if (transpose)
                this.transpose();
            var len = vector.length - index;
            for (var c = 0; c < len; c++)
                this.rawData[c] = vector[c + index];
            if (transpose)
                this.transpose();
        };
        /**
        * @language zh_CN
        * 把当前矩阵的值拷贝给一个 float 数组.
        * @param vector 目标数组.
        * @param index 从数组的index 开始copy.
        * @param transpose 是否转置当前矩阵.
        */
        Matrix4_4.prototype.copyRawDataTo = function (vector, index, transpose) {
            if (index === void 0) { index = 0; }
            if (transpose === void 0) { transpose = false; }
            if (transpose)
                this.transpose();
            var len = this.rawData.length;
            for (var c = 0; c < len; c++)
                vector[c + index] = this.rawData[c];
            if (transpose)
                this.transpose();
        };
        /**
        * @language zh_CN
        * 给当前矩阵的某一列 赋值
        * @param col 列
        * @param vector3D 值来源
        */
        Matrix4_4.prototype.copyColFrom = function (col, vector3D) {
            switch (col) {
                case 0:
                    this.rawData[0] = vector3D.x;
                    this.rawData[4] = vector3D.y;
                    this.rawData[8] = vector3D.z;
                    this.rawData[12] = vector3D.w;
                    break;
                case 1:
                    this.rawData[1] = vector3D.x;
                    this.rawData[5] = vector3D.y;
                    this.rawData[9] = vector3D.z;
                    this.rawData[13] = vector3D.w;
                    break;
                case 2:
                    this.rawData[2] = vector3D.x;
                    this.rawData[6] = vector3D.y;
                    this.rawData[10] = vector3D.z;
                    this.rawData[14] = vector3D.w;
                    break;
                case 3:
                    this.rawData[3] = vector3D.x;
                    this.rawData[7] = vector3D.y;
                    this.rawData[11] = vector3D.z;
                    this.rawData[15] = vector3D.w;
                    break;
                default:
                    new Error("no more raw!");
            }
        };
        /**
        * @language zh_CN
        * 拷贝当前矩阵的某一列
        * @param col 列
        * @param vector3D 拷贝目标
        */
        Matrix4_4.prototype.copyColTo = function (col, vector3D) {
            switch (col) {
                case 0:
                    vector3D.x = this.rawData[0];
                    vector3D.y = this.rawData[4];
                    vector3D.z = this.rawData[8];
                    vector3D.w = this.rawData[12];
                    break;
                case 1:
                    vector3D.x = this.rawData[1];
                    vector3D.y = this.rawData[5];
                    vector3D.z = this.rawData[9];
                    vector3D.w = this.rawData[13];
                    break;
                case 2:
                    vector3D.x = this.rawData[2];
                    vector3D.y = this.rawData[6];
                    vector3D.z = this.rawData[10];
                    vector3D.w = this.rawData[14];
                    break;
                case 3:
                    vector3D.x = this.rawData[3];
                    vector3D.y = this.rawData[7];
                    vector3D.z = this.rawData[11];
                    vector3D.w = this.rawData[15];
                    break;
                default:
                    new Error("no more raw!");
            }
        };
        /**
        * @language zh_CN
        * 拷贝当前矩阵
        * @param dest 拷贝目标
        */
        Matrix4_4.prototype.copyToMatrix3D = function (dest) {
            dest.rawData = this.rawData.slice(0);
        };
        /**
        * @language zh_CN
        * 分解当前矩阵
        * @param orientationStyle 分解类型
        * @returns Vector3D[3] pos rot scale
        */
        Matrix4_4.prototype.decompose = function (orientationStyle) {
            if (orientationStyle === void 0) { orientationStyle = "eulerAngles"; }
            var q;
            var vec = [];
            var m = this.clone();
            var mr = m.rawData;
            var pos = new egret3d.Vector3D(mr[12], mr[13], mr[14]);
            mr[12] = 0;
            mr[13] = 0;
            mr[14] = 0;
            var scale = new egret3d.Vector3D();
            scale.x = Math.sqrt(mr[0] * mr[0] + mr[1] * mr[1] + mr[2] * mr[2]);
            scale.y = Math.sqrt(mr[4] * mr[4] + mr[5] * mr[5] + mr[6] * mr[6]);
            scale.z = Math.sqrt(mr[8] * mr[8] + mr[9] * mr[9] + mr[10] * mr[10]);
            if (mr[0] * (mr[5] * mr[10] - mr[6] * mr[9]) - mr[1] * (mr[4] * mr[10] - mr[6] * mr[8]) + mr[2] * (mr[4] * mr[9] - mr[5] * mr[8]) < 0)
                scale.z = -scale.z;
            mr[0] /= scale.x;
            mr[1] /= scale.x;
            mr[2] /= scale.x;
            mr[4] /= scale.y;
            mr[5] /= scale.y;
            mr[6] /= scale.y;
            mr[8] /= scale.z;
            mr[9] /= scale.z;
            mr[10] /= scale.z;
            var rot = new egret3d.Vector3D();
            switch (orientationStyle) {
                case egret3d.Orientation3D.AXIS_ANGLE:
                    rot.w = Math.acos((mr[0] + mr[5] + mr[10] - 1) / 2);
                    var len = Math.sqrt((mr[6] - mr[9]) * (mr[6] - mr[9]) + (mr[8] - mr[2]) * (mr[8] - mr[2]) + (mr[1] - mr[4]) * (mr[1] - mr[4]));
                    rot.x = (mr[6] - mr[9]) / len;
                    rot.y = (mr[8] - mr[2]) / len;
                    rot.z = (mr[1] - mr[4]) / len;
                    break;
                case egret3d.Orientation3D.QUATERNION:
                    var tr = mr[0] + mr[5] + mr[10];
                    if (tr > 0) {
                        rot.w = Math.sqrt(1 + tr) / 2;
                        rot.x = (mr[6] - mr[9]) / (4 * rot.w);
                        rot.y = (mr[8] - mr[2]) / (4 * rot.w);
                        rot.z = (mr[1] - mr[4]) / (4 * rot.w);
                    }
                    else if ((mr[0] > mr[5]) && (mr[0] > mr[10])) {
                        rot.x = Math.sqrt(1 + mr[0] - mr[5] - mr[10]) / 2;
                        rot.w = (mr[6] - mr[9]) / (4 * rot.x);
                        rot.y = (mr[1] + mr[4]) / (4 * rot.x);
                        rot.z = (mr[8] + mr[2]) / (4 * rot.x);
                    }
                    else if (mr[5] > mr[10]) {
                        rot.y = Math.sqrt(1 + mr[5] - mr[0] - mr[10]) / 2;
                        rot.x = (mr[1] + mr[4]) / (4 * rot.y);
                        rot.w = (mr[8] - mr[2]) / (4 * rot.y);
                        rot.z = (mr[6] + mr[9]) / (4 * rot.y);
                    }
                    else {
                        rot.z = Math.sqrt(1 + mr[10] - mr[0] - mr[5]) / 2;
                        rot.x = (mr[8] + mr[2]) / (4 * rot.z);
                        rot.y = (mr[6] + mr[9]) / (4 * rot.z);
                        rot.w = (mr[1] - mr[4]) / (4 * rot.z);
                    }
                    break;
                case egret3d.Orientation3D.EULER_ANGLES:
                    rot.y = Math.asin(-mr[2]);
                    if (mr[2] != 1 && mr[2] != -1) {
                        rot.x = Math.atan2(mr[6], mr[10]);
                        rot.z = Math.atan2(mr[1], mr[0]);
                    }
                    else {
                        rot.z = 0;
                        rot.x = Math.atan2(mr[4], mr[5]);
                    }
                    break;
            }
            vec.push(pos);
            vec.push(rot);
            vec.push(scale);
            return vec;
        };
        /**
        * @language zh_CN
        * 当前矩阵变换一个向量
        * @param v 要变换的向量
        * @returns 变换后的向量
        */
        Matrix4_4.prototype.deltaTransformVector = function (v) {
            var x = v.x;
            var y = v.y;
            var z = v.z;
            return new egret3d.Vector3D((x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8]), (x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9]), (x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10]), (x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11]));
        };
        /**
        * @language zh_CN
        * 单位化当前矩阵
        */
        Matrix4_4.prototype.identity = function () {
            this.rawData[1] = 0;
            this.rawData[2] = 0;
            this.rawData[3] = 0;
            this.rawData[4] = 0;
            this.rawData[6] = 0;
            this.rawData[7] = 0;
            this.rawData[8] = 0;
            this.rawData[9] = 0;
            this.rawData[11] = 0;
            this.rawData[12] = 0;
            this.rawData[13] = 0;
            this.rawData[14] = 0;
            this.rawData[0] = 1;
            this.rawData[5] = 1;
            this.rawData[10] = 1;
            this.rawData[15] = 1;
        };
        /**
        * @language zh_CN
        * 填充当前矩阵
        * @param value 填充的值
        */
        Matrix4_4.prototype.fill = function (value) {
            this.rawData[1] = value;
            this.rawData[2] = value;
            this.rawData[3] = value;
            this.rawData[4] = value;
            this.rawData[6] = value;
            this.rawData[7] = value;
            this.rawData[8] = value;
            this.rawData[9] = value;
            this.rawData[11] = value;
            this.rawData[12] = value;
            this.rawData[13] = value;
            this.rawData[14] = value;
            this.rawData[0] = value;
            this.rawData[5] = value;
            this.rawData[10] = value;
            this.rawData[15] = value;
        };
        /**
        * @language zh_CN
        * 当前矩阵求逆
        */
        Matrix4_4.prototype.invers33 = function () {
            /// Invert a 3x3 using cofactors.  This is about 8 times faster than
            /// the Numerical Recipes code which uses Gaussian elimination.
            var rkInverse_00 = this.rawData[5] * this.rawData[10] - this.rawData[9] * this.rawData[6];
            var rkInverse_01 = this.rawData[8] * this.rawData[6] - this.rawData[4] * this.rawData[10];
            var rkInverse_02 = this.rawData[4] * this.rawData[9] - this.rawData[8] * this.rawData[5];
            var rkInverse_10 = this.rawData[9] * this.rawData[2] - this.rawData[1] * this.rawData[10];
            var rkInverse_11 = this.rawData[0] * this.rawData[10] - this.rawData[8] * this.rawData[2];
            var rkInverse_12 = this.rawData[8] * this.rawData[1] - this.rawData[0] * this.rawData[9];
            var rkInverse_20 = this.rawData[1] * this.rawData[6] - this.rawData[5] * this.rawData[2];
            var rkInverse_21 = this.rawData[4] * this.rawData[2] - this.rawData[0] * this.rawData[6];
            var rkInverse_22 = this.rawData[0] * this.rawData[5] - this.rawData[4] * this.rawData[1];
            var fDet = this.rawData[0] * rkInverse_00 +
                this.rawData[4] * rkInverse_10 +
                this.rawData[8] * rkInverse_20;
            if (Math.abs(fDet) > 0.00000000001) {
                var fInvDet = 1.0 / fDet;
                this.rawData[0] = fInvDet * rkInverse_00;
                this.rawData[4] = fInvDet * rkInverse_01;
                this.rawData[8] = fInvDet * rkInverse_02;
                this.rawData[1] = fInvDet * rkInverse_10;
                this.rawData[5] = fInvDet * rkInverse_11;
                this.rawData[9] = fInvDet * rkInverse_12;
                this.rawData[2] = fInvDet * rkInverse_20;
                this.rawData[6] = fInvDet * rkInverse_21;
                this.rawData[10] = fInvDet * rkInverse_22;
            }
        };
        /**
        * @language zh_CN
        * 当前矩阵求逆
        * @returns 是否能求逆
        */
        Matrix4_4.prototype.invert = function () {
            var d = this.determinant;
            var invertable = Math.abs(d) > 0.00000000001;
            if (invertable) {
                d = 1 / d;
                var m11 = this.rawData[0];
                var m21 = this.rawData[4];
                var m31 = this.rawData[8];
                var m41 = this.rawData[12];
                var m12 = this.rawData[1];
                var m22 = this.rawData[5];
                var m32 = this.rawData[9];
                var m42 = this.rawData[13];
                var m13 = this.rawData[2];
                var m23 = this.rawData[6];
                var m33 = this.rawData[10];
                var m43 = this.rawData[14];
                var m14 = this.rawData[3];
                var m24 = this.rawData[7];
                var m34 = this.rawData[11];
                var m44 = this.rawData[15];
                this.rawData[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
                this.rawData[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
                this.rawData[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
                this.rawData[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
                this.rawData[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
                this.rawData[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
                this.rawData[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
                this.rawData[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
                this.rawData[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
                this.rawData[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
                this.rawData[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
                this.rawData[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
                this.rawData[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
                this.rawData[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
                this.rawData[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
                this.rawData[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
            }
            return invertable;
        };
        /**
        * @language zh_CN
        * 生成一个变换矩阵
        * @param pos  位移
        * @param scale 缩放
        * @param rot 旋转
        */
        Matrix4_4.prototype.makeTransform = function (pos, scale, rot) {
            rot.toMatrix3D(egret3d.Matrix3DUtils.CALCULATION_MATRIX);
            this.rawData[0] = egret3d.Matrix3DUtils.CALCULATION_MATRIX.rawData[0] * scale.x;
            this.rawData[1] = egret3d.Matrix3DUtils.CALCULATION_MATRIX.rawData[1] * scale.y;
            this.rawData[2] = egret3d.Matrix3DUtils.CALCULATION_MATRIX.rawData[2] * scale.z;
            this.rawData[3] = 0;
            this.rawData[4] = egret3d.Matrix3DUtils.CALCULATION_MATRIX.rawData[4] * scale.x;
            this.rawData[5] = egret3d.Matrix3DUtils.CALCULATION_MATRIX.rawData[5] * scale.y;
            this.rawData[6] = egret3d.Matrix3DUtils.CALCULATION_MATRIX.rawData[6] * scale.z;
            this.rawData[7] = 0;
            this.rawData[8] = egret3d.Matrix3DUtils.CALCULATION_MATRIX.rawData[8] * scale.x;
            this.rawData[9] = egret3d.Matrix3DUtils.CALCULATION_MATRIX.rawData[9] * scale.y;
            this.rawData[10] = egret3d.Matrix3DUtils.CALCULATION_MATRIX.rawData[10] * scale.z;
            this.rawData[11] = 0;
            this.rawData[12] = pos.x;
            this.rawData[13] = pos.y;
            this.rawData[14] = pos.z;
            this.rawData[15] = 1;
        };
        /**
        * @language zh_CN
        * 生成一个变换矩阵
        * @param components Vector3D[3] 位移 旋转 缩放
        * @returns 生成是否成功
        */
        Matrix4_4.prototype.recompose = function (components) {
            if (components.length < 3)
                return false;
            this.identity();
            this.appendScale(components[2].x, components[2].y, components[2].z);
            var angle;
            angle = -components[1].x * egret3d.Matrix3DUtils.DEGREES_TO_RADIANS;
            egret3d.Matrix3DUtils.CALCULATION_MATRIX.copyRawDataFrom(new Float32Array([1, 0, 0, 0, 0, Math.cos(angle), -Math.sin(angle), 0, 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 0]));
            this.append(egret3d.Matrix3DUtils.CALCULATION_MATRIX);
            angle = -components[1].y * egret3d.Matrix3DUtils.DEGREES_TO_RADIANS;
            egret3d.Matrix3DUtils.CALCULATION_MATRIX.copyRawDataFrom(new Float32Array([Math.cos(angle), 0, Math.sin(angle), 0, 0, 1, 0, 0, -Math.sin(angle), 0, Math.cos(angle), 0, 0, 0, 0, 0]));
            this.append(egret3d.Matrix3DUtils.CALCULATION_MATRIX);
            angle = -components[1].z * egret3d.Matrix3DUtils.DEGREES_TO_RADIANS;
            egret3d.Matrix3DUtils.CALCULATION_MATRIX.copyRawDataFrom(new Float32Array([Math.cos(angle), -Math.sin(angle), 0, 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]));
            this.append(egret3d.Matrix3DUtils.CALCULATION_MATRIX);
            this.rawData[12] = components[0].x;
            this.rawData[13] = components[0].y;
            this.rawData[14] = components[0].z;
            this.rawData[15] = 1;
            return true;
        };
        /**
        * @language zh_CN
        * 用当前矩阵变换一个3D向量
        * @param v 变换的向量
        * @returns 变换后的向量
        */
        Matrix4_4.prototype.transformVector = function (v) {
            if (v == null)
                return new egret3d.Vector3D();
            var x = v.x;
            var y = v.y;
            var z = v.z;
            var out = new egret3d.Vector3D();
            out.x = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12];
            out.y = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13];
            out.z = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14];
            out.w = x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11] + this.rawData[15];
            return out;
        };
        /**
        * @language zh_CN
        * 用当前矩阵变换一个3D平面
        * @param plane 变换的平面
        * @returns 变换后的平面
        */
        Matrix4_4.prototype.transformPlane = function (plane) {
            var mat = new Matrix4_4();
            mat.copyFrom(this);
            mat.invert();
            mat.transpose();
            var v = new egret3d.Vector3D(plane.a, plane.b, plane.c, plane.d);
            v.copyFrom(mat.transformVector(v));
            var p = new egret3d.Plane3D();
            p.a = v.x;
            p.b = v.y;
            p.c = v.z;
            p.d = v.w / Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
            return p;
        };
        /**
        * @language zh_CN
        * 当前矩阵转置
        */
        Matrix4_4.prototype.transpose = function () {
            for (var i = 0; i < this.oRawData.length; i++) {
                this.oRawData[i] = this.rawData[i];
            }
            this.rawData[1] = this.oRawData[4];
            this.rawData[2] = this.oRawData[8];
            this.rawData[3] = this.oRawData[12];
            this.rawData[4] = this.oRawData[1];
            this.rawData[6] = this.oRawData[9];
            this.rawData[7] = this.oRawData[13];
            this.rawData[8] = this.oRawData[2];
            this.rawData[9] = this.oRawData[6];
            this.rawData[11] = this.oRawData[14];
            this.rawData[12] = this.oRawData[3];
            this.rawData[13] = this.oRawData[7];
            this.rawData[14] = this.oRawData[11];
        };
        /**
        * @language zh_CN
        * 生成一个(以x,y,z为中心轴旋转degrees角度)的矩阵
        * @param x 中心轴的x
        * @param y 中心轴的y
        * @param z 中心轴的z
        * @param degrees 旋转角度
        */
        Matrix4_4.getAxisRotation = function (x, y, z, degrees) {
            var m = new Matrix4_4();
            var rad = degrees * (Math.PI / 180);
            var c = Math.cos(rad);
            var s = Math.sin(rad);
            var t = 1 - c;
            var tmp1, tmp2;
            m.rawData[0] = c + x * x * t;
            m.rawData[5] = c + y * y * t;
            m.rawData[10] = c + z * z * t;
            tmp1 = x * y * t;
            tmp2 = z * s;
            m.rawData[1] = tmp1 + tmp2;
            m.rawData[4] = tmp1 - tmp2;
            tmp1 = x * z * t;
            tmp2 = y * s;
            m.rawData[8] = tmp1 + tmp2;
            m.rawData[2] = tmp1 - tmp2;
            tmp1 = y * z * t;
            tmp2 = x * s;
            m.rawData[9] = tmp1 - tmp2;
            m.rawData[6] = tmp1 + tmp2;
            return m;
        };
        Object.defineProperty(Matrix4_4.prototype, "determinant", {
            /**
            * @language zh_CN
            * 返回矩阵行列式
            *
            * @returns 行列式值
            */
            get: function () {
                return ((this.rawData[0] * this.rawData[5] - this.rawData[4] * this.rawData[1]) * (this.rawData[10] * this.rawData[15] - this.rawData[14] * this.rawData[11]) - (this.rawData[0] * this.rawData[9] - this.rawData[8] * this.rawData[1]) * (this.rawData[6] * this.rawData[15] - this.rawData[14] * this.rawData[7]) + (this.rawData[0] * this.rawData[13] - this.rawData[12] * this.rawData[1]) * (this.rawData[6] * this.rawData[11] - this.rawData[10] * this.rawData[7]) + (this.rawData[4] * this.rawData[9] - this.rawData[8] * this.rawData[5]) * (this.rawData[2] * this.rawData[15] - this.rawData[14] * this.rawData[3]) - (this.rawData[4] * this.rawData[13] - this.rawData[12] * this.rawData[5]) * (this.rawData[2] * this.rawData[11] - this.rawData[10] * this.rawData[3]) + (this.rawData[8] * this.rawData[13] - this.rawData[12] * this.rawData[9]) * (this.rawData[2] * this.rawData[7] - this.rawData[6] * this.rawData[3]));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4_4.prototype, "position", {
            /**
            * @language zh_CN
            * 返回矩阵位移
            *
            * @returns 位移
            */
            get: function () {
                return new egret3d.Vector3D(this.rawData[12], this.rawData[13], this.rawData[14]);
            },
            /**
            * @language zh_CN
            * 设置矩阵位移
            *
            * @param value 位移
            */
            set: function (value) {
                this.rawData[12] = value.x;
                this.rawData[13] = value.y;
                this.rawData[14] = value.z;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix4_4.prototype, "scale", {
            /**
            * @language zh_CN
            * 返回矩阵缩放
            *
            * @returns 缩放
            */
            get: function () {
                return new egret3d.Vector3D(this.rawData[0], this.rawData[5], this.rawData[10]);
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 以字符串返回矩阵的值
        *
        * @returns 字符
        */
        Matrix4_4.prototype.toString = function () {
            return "matrix3d(" + Math.round(this.rawData[0] * 1000) / 1000 + "," + Math.round(this.rawData[1] * 1000) / 1000 + "," + Math.round(this.rawData[2] * 1000) / 1000 + "," + Math.round(this.rawData[3] * 1000) / 1000 + "," + Math.round(this.rawData[4] * 1000) / 1000 + "," + Math.round(this.rawData[5] * 1000) / 1000 + "," + Math.round(this.rawData[6] * 1000) / 1000 + "," + Math.round(this.rawData[7] * 1000) / 1000 + "," + Math.round(this.rawData[8] * 1000) / 1000 + "," + Math.round(this.rawData[9] * 1000) / 1000 + "," + Math.round(this.rawData[10] * 1000) / 1000 + "," + Math.round(this.rawData[11] * 1000) / 1000 + "," + Math.round(this.rawData[12] * 1000) / 1000 + "," + Math.round(this.rawData[13] * 1000) / 1000 + "," + Math.round(this.rawData[14] * 1000) / 1000 + "," + Math.round(this.rawData[15] * 1000) / 1000 + ")";
        };
        /**
        * @language zh_CN
        * 求两个矩阵之间的差值
        * @param m0 矩阵0
        * @param m1 矩阵1
        * @param t 时间差 0.0 - 1.0
        */
        Matrix4_4.prototype.lerp = function (m0, m1, t) {
            ///t(m1 - m0) + m0
            this.copyFrom(m1).sub(m0).mult(t).add(m0);
        };
        return Matrix4_4;
    })();
    egret3d.Matrix4_4 = Matrix4_4;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.EyesMatrix
     * @classdesc
     * 可使用 EyesMatrix 类 对左，右眼睛矩阵的操作
     * 它会在摄像机的位置做一个左 右偏移 模拟出眼睛的矩阵
     * @version Egret 3.0
     * @platform Web,Native
     */
    var EyesMatrix = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function EyesMatrix() {
            this.eyePosition = new egret3d.Vector3D();
            this.eyeRotation = new egret3d.Vector3D(0, 1, 0);
            this.eyeSpace = 1.0;
            this.eyeFocalLength = 180;
            this.leftPos = new egret3d.Vector3D();
            this.rightPos = new egret3d.Vector3D();
            this.targetPos = new egret3d.Vector3D(0.0, 0.0, this.eyeFocalLength);
            this.lookAtPos = new egret3d.Vector3D();
            this.quaternion = new egret3d.Quaternion();
            this.leftEyeMatrix = new egret3d.Matrix4_4();
            this.rightEyeMatrix = new egret3d.Matrix4_4();
        }
        /**
        * @language zh_CN
        * 数据更新
        * @param matrix 当前相机矩阵
        */
        EyesMatrix.prototype.updte = function (matrix) {
            /// this.leftEyeMatrix = matrix;
            /// this.rightEyeMatrix = matrix;
            //////this.leftEyeMatrix.copyFrom(matrix);
            //////this.rightEyeMatrix.copyFrom(matrix);
            /// return;
            this.targetPos.z = this.eyeFocalLength;
            this.eyePosition = matrix.position;
            this.quaternion.fromMatrix(matrix);
            ///this.quaternion.toEulerAngles(this.eyeRotation);
            ///this.eyeRotation.normalize();
            this.leftEyeMatrix.copyRawDataFrom(matrix.rawData);
            this.rightEyeMatrix.copyRawDataFrom(matrix.rawData);
            this.leftEyeMatrix.appendTranslation(-this.eyeSpace * 0.5, 0.0, 0.0);
            this.rightEyeMatrix.appendTranslation(this.eyeSpace * 0.5, 0.0, 0.0);
            /// this.quaternion.rotatePoint(this.targetPos, this.lookAtPos);
            ///this.leftEyeMatrix.lookAt(this.leftEyeMatrix.position, this.lookAtPos, this.eyeRotation);
            /// this.rightEyeMatrix.lookAt(this.rightEyeMatrix.position, this.lookAtPos, this.eyeRotation);
        };
        return EyesMatrix;
    })();
    egret3d.EyesMatrix = EyesMatrix;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.PlaneClassification
     * @classdesc
     * 定义 PlaneClassification 常量
     * @version Egret 3.0
     * @platform Web,Native
     */
    var PlaneClassification = (function () {
        function PlaneClassification() {
        }
        PlaneClassification.BACK = 0;
        PlaneClassification.FRONT = 1;
        PlaneClassification.IN = 0;
        PlaneClassification.OUT = 1;
        PlaneClassification.INTERSECT = 2;
        return PlaneClassification;
    })();
    egret3d.PlaneClassification = PlaneClassification;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var MathUtil = (function () {
        function MathUtil() {
        }
        /**
      * @language zh_CN
      * 1弧度为多少角度
      */
        MathUtil.RADIANS_TO_DEGREES = 180 / Math.PI;
        /**
        * @language zh_CN
        * 1角度为多少弧度
        */
        MathUtil.DEGREES_TO_RADIANS = Math.PI / 180;
        return MathUtil;
    })();
    egret3d.MathUtil = MathUtil;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.Matrix3DUtils
    * @classdesc
    * 可使用 Matrix3DUtils 类 进行3d矩阵的计算
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Matrix3DUtils = (function () {
        function Matrix3DUtils() {
        }
        /**
        * @language zh_CN
        * 四元数转矩阵
        * @param quarternion 源四元数
        * @param m 目标矩阵
        * @returns 返回转出矩阵
        */
        Matrix3DUtils.quaternion2matrix = function (quarternion, m) {
            if (m === void 0) { m = null; }
            var x = quarternion.x;
            var y = quarternion.y;
            var z = quarternion.z;
            var w = quarternion.w;
            var xx = x * x;
            var xy = x * y;
            var xz = x * z;
            var xw = x * w;
            var yy = y * y;
            var yz = y * z;
            var yw = y * w;
            var zz = z * z;
            var zw = z * w;
            var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
            raw[0] = 1 - 2 * (yy + zz);
            raw[1] = 2 * (xy + zw);
            raw[2] = 2 * (xz - yw);
            raw[4] = 2 * (xy - zw);
            raw[5] = 1 - 2 * (xx + zz);
            raw[6] = 2 * (yz + xw);
            raw[8] = 2 * (xz + yw);
            raw[9] = 2 * (yz - xw);
            raw[10] = 1 - 2 * (xx + yy);
            raw[3] = raw[7] = raw[11] = raw[12] = raw[13] = raw[14] = 0;
            raw[15] = 1;
            if (m) {
                m.copyRawDataFrom(raw);
                return m;
            }
            else
                return new egret3d.Matrix4_4(new Float32Array(raw));
        };
        /**
        * @language zh_CN
        * 得到矩阵朝前的方向
        * @param m 源矩阵
        * @param v 返回的方向 可为null
        * @returns 返回方向
        */
        Matrix3DUtils.getForward = function (m, v) {
            if (v === void 0) { v = null; }
            if (v === null) {
                v = new egret3d.Vector3D(0.0, 0.0, 0.0);
            }
            m.copyRowTo(2, v);
            v.normalize();
            return v;
        };
        /**
        * @language zh_CN
        * 得到矩阵朝上的方向
        * @param m 源矩阵
        * @param v 返回的方向 可为null
        * @returns 返回方向
        */
        Matrix3DUtils.getUp = function (m, v) {
            //v ||= new Vector3D(0.0, 0.0, 0.0);
            if (v === void 0) { v = null; }
            if (v === null) {
                v = new egret3d.Vector3D(0.0, 0.0, 0.0);
            }
            m.copyRowTo(1, v);
            v.normalize();
            return v;
        };
        /**
        * @language zh_CN
        * 得到矩阵朝右的方向
        * @param m 源矩阵
        * @param v 返回的方向 可为null
        * @returns 返回方向
        */
        Matrix3DUtils.getRight = function (m, v) {
            if (v === void 0) { v = null; }
            //v ||= new Vector3D(0.0, 0.0, 0.0);
            if (v === null) {
                v = new egret3d.Vector3D(0.0, 0.0, 0.0);
            }
            m.copyRowTo(0, v);
            v.normalize();
            return v;
        };
        /**
        * @language zh_CN
        * 比较两个矩阵是否相同
        * @param m1 矩阵1
        * @param m2 矩阵2
        * @returns 相同返回true
        */
        Matrix3DUtils.compare = function (m1, m2) {
            var r1 = Matrix3DUtils.RAW_DATA_CONTAINER;
            var r2 = m2.rawData;
            m1.copyRawDataTo(r1);
            for (var i = 0; i < 16; ++i) {
                if (r1[i] != r2[i])
                    return false;
            }
            return true;
        };
        /**
        * @language zh_CN
        * 得到平面的反射矩阵
        * @param plane 反射的面
        * @param target 计算返回的矩阵
        * @returns 返回计算的结果
        */
        Matrix3DUtils.reflection = function (plane, target) {
            if (target === void 0) { target = null; }
            if (target === null)
                target = new egret3d.Matrix4_4();
            var a = plane.a, b = plane.b, c = plane.c, d = plane.d;
            var rawData = Matrix3DUtils.RAW_DATA_CONTAINER;
            var ab2 = -2 * a * b;
            var ac2 = -2 * a * c;
            var bc2 = -2 * b * c;
            // reflection matrix
            rawData[0] = 1 - 2 * a * a;
            rawData[4] = ab2;
            rawData[8] = ac2;
            rawData[12] = -2 * a * d;
            rawData[1] = ab2;
            rawData[5] = 1 - 2 * b * b;
            rawData[9] = bc2;
            rawData[13] = -2 * b * d;
            rawData[2] = ac2;
            rawData[6] = bc2;
            rawData[10] = 1 - 2 * c * c;
            rawData[14] = -2 * c * d;
            rawData[3] = 0;
            rawData[7] = 0;
            rawData[11] = 0;
            rawData[15] = 1;
            target.copyRawDataFrom(rawData);
            return target;
        };
        /**
        * @language zh_CN
        * 得到矩阵的平移
        * @param transform 计算的矩阵
        * @param result 计算返回平移坐标
        * @returns 返回平移坐标
        */
        Matrix3DUtils.getTranslation = function (transform, result) {
            if (result === void 0) { result = null; }
            if (!result)
                result = new egret3d.Vector3D();
            transform.copyRowTo(3, result);
            return result;
        };
        /**
        * @language zh_CN
        * 把一个值固定在一个范围之内
        * @param value 当前判定的值
        * @param min_inclusive 最小取值
        * @param max_inclusive 最大取值
        * @returns 计算后的结果
        */
        Matrix3DUtils.clampf = function (value, min_inclusive, max_inclusive) {
            if (min_inclusive > max_inclusive) {
                var temp = min_inclusive;
                min_inclusive = max_inclusive;
                max_inclusive = temp;
            }
            return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
        };
        /**
        * @language zh_CN
        * 1弧度为多少角度
        */
        Matrix3DUtils.RADIANS_TO_DEGREES = 180 / Math.PI;
        /**
        * @language zh_CN
        * 1角度为多少弧度
        */
        Matrix3DUtils.DEGREES_TO_RADIANS = Math.PI / 180;
        /**
        * @private
        * 1角度为多少弧度
        */
        Matrix3DUtils.RAW_DATA_CONTAINER = new Float32Array(16);
        /**
        * @private
        */
        Matrix3DUtils.CALCULATION_MATRIX = new egret3d.Matrix4_4();
        return Matrix3DUtils;
    })();
    egret3d.Matrix3DUtils = Matrix3DUtils;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Ray
     * @classdesc
     * 射线是指直线上的一点和它一旁的部分所组成的直线，射线有且仅有一个端点，无法测量，由一个原点,和一个方向构成
     * 用于检测射线,也可用于鼠标拣选场景中的模型
     *
     * @see egret3d.core.traverse.Picker
     * @see egret3d.geom.Vector3D
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Ray = (function () {
        /**
        * @language zh_CN
        * constructor
        * @origin 射线原点
        * @direction 射线方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Ray(origin, direction) {
            if (origin === void 0) { origin = new egret3d.Vector3D(); }
            if (direction === void 0) { direction = new egret3d.Vector3D(); }
            /**
            * @language zh_CN
            * 射线原点
            */
            this.origin = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 射线方向
            */
            this.dir = new egret3d.Vector3D();
            this.invViewMat = new egret3d.Matrix4_4();
            this.origin.copyFrom(origin);
            this.dir.copyFrom(direction);
        }
        /**
        * @language zh_CN
        * 计算一个三角形和一个射线的交点
        * @param v0 三角形的第一个顶点
        * @param v1 三角形的第二个顶点
        * @param v2 三角形的第三个顶点
        * @param ret t(交点到射线起始点的距离) u(交点在v1-v0上的投影的位置) v(交点在v1-v2上的投影的位置, 交点为ret=v0+pU*(v1-v0)+pV*(v2-v0))
        * @returns 相交返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.IntersectTriangle = function (v0, v1, v2, ret) {
            if (ret === void 0) { ret = null; }
            var edge1 = v1.subtract(v0);
            var edge2 = v2.subtract(v0);
            var pvec = this.dir.crossProduct(edge2);
            var det = edge1.dotProduct(pvec);
            var tvec;
            if (det > 0) {
                tvec = this.origin.subtract(v0);
            }
            else {
                tvec = v0.subtract(this.origin);
                det = -det;
            }
            if (det < 0.0001) {
                return false;
            }
            // Calculate U parameter and test bounds
            var u = tvec.dotProduct(pvec);
            if (ret != null) {
                ret[1] = u;
            }
            if (u < 0.0 || u > det) {
                return false;
            }
            // Prepare to test V parameter
            var qvec = tvec.crossProduct(edge1);
            // Calculate V parameter and test bounds
            var v = this.dir.dotProduct(qvec);
            if (ret != null) {
                ret[2] = v;
            }
            if (v < 0.0 || u + v > det) {
                return false;
            }
            // Calculate T, scale parameters, ray intersects triangle
            var t = edge2.dotProduct(qvec);
            var invDet = 1.0 / det;
            t *= invDet;
            u *= invDet;
            v *= invDet;
            if (ret != null) {
                ret[0] = t;
                ret[1] = u;
                ret[2] = v;
            }
            if (t < 0) {
                return false;
            }
            return true;
        };
        /**
        * @language zh_CN
        * 检测射线相交模型
        * @param mesh 检测的模型
        * @param inPos 相交点
        * @returns 相交返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.IntersectMeshEx = function (mesh, uv_offset, result) {
            return this.IntersectMesh(mesh.geometry.verticesData, mesh.geometry.indexData, mesh.geometry.vertexAttLength, mesh.geometry.indexData.length / 3, uv_offset, mesh.modelMatrix, result);
        };
        /**
        * @language zh_CN
        * 检测射线相交模型
        * @param verticesData 检测的模型的顶点数据
        * @param indexData 检测的模型的索引数据
        * @param offset 每个顶点的大小
        * @param faces 模型面数
        * @param inPos 返回相交点
        * @param mMat 顶点的世界变换矩阵
        * @returns 相交返回true
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.IntersectMesh = function (verticesData, indexData, offset, faces, uv_offset, mMat, result) {
            var modletriangle = new Array();
            modletriangle.push(new egret3d.Vector3D());
            modletriangle.push(new egret3d.Vector3D());
            modletriangle.push(new egret3d.Vector3D());
            var uvarray = new Array();
            uvarray.push(new egret3d.Vector3D());
            uvarray.push(new egret3d.Vector3D());
            uvarray.push(new egret3d.Vector3D());
            var triangle = new Array();
            var v0 = new egret3d.Vector3D();
            var v1 = new egret3d.Vector3D();
            var v2 = new egret3d.Vector3D();
            triangle.push(v0);
            triangle.push(v1);
            triangle.push(v2);
            var pos = new egret3d.Vector3D();
            var uv = new egret3d.Point();
            var ret = new Array();
            ret.push(0.0);
            ret.push(0.0);
            ret.push(0.0);
            var face = -1;
            var t = Number.MAX_VALUE;
            var u = 0;
            var v = 0;
            for (var i = 0; i < faces; ++i) {
                for (var j = 0; j < 3; ++j) {
                    var index = indexData[3 * i + j];
                    pos.setTo(verticesData[offset * index + 0], verticesData[offset * index + 1], verticesData[offset * index + 2]);
                    pos.copyFrom(mMat.transformVector(pos));
                    triangle[j].x = pos.x;
                    triangle[j].y = pos.y;
                    triangle[j].z = pos.z;
                }
                if (this.IntersectTriangle(v0, v1, v2, ret)) {
                    if (ret[0] < t) {
                        face = i;
                        t = ret[0];
                        u = ret[1];
                        v = ret[2];
                    }
                }
            }
            if (face < faces && face >= 0) {
                for (var i = 0; i < 3; ++i) {
                    var index = indexData[3 * face + i];
                    pos.setTo(verticesData[offset * index + 0], verticesData[offset * index + 1], verticesData[offset * index + 2]);
                    modletriangle[i].copyFrom(pos);
                    if (uv_offset > 0) {
                        uv.x = verticesData[offset * index + 0 + uv_offset];
                        uv.y = verticesData[offset * index + 1 + uv_offset];
                        uvarray[i].x = uv.x;
                        uvarray[i].y = uv.y;
                    }
                    pos.copyFrom(mMat.transformVector(pos));
                    triangle[i].x = pos.x;
                    triangle[i].y = pos.y;
                    triangle[i].z = pos.z;
                }
                var tmp0 = v1.subtract(v0);
                tmp0.scaleBy(u);
                var tmp1 = v2.subtract(v0);
                tmp1.scaleBy(v);
                result.globalPosition.copyFrom(v0.add(tmp0.add(tmp1)));
                tmp0 = modletriangle[1].subtract(modletriangle[0]);
                tmp0.scaleBy(u);
                tmp1 = modletriangle[2].subtract(modletriangle[0]);
                tmp1.scaleBy(v);
                result.localPosition.copyFrom(modletriangle[0].add(tmp0.add(tmp1)));
                if (uv_offset > 0) {
                    tmp0 = uvarray[1].subtract(uvarray[0]);
                    tmp0.scaleBy(u);
                    tmp1 = uvarray[2].subtract(uvarray[0]);
                    tmp1.scaleBy(v);
                    result.uv.copyFrom(uvarray[0].add(tmp0.add(tmp1)));
                }
                return true;
            }
            return false;
        };
        /**
        * @language zh_CN
        * 计算摄像机的射线
        * @param width 视口宽
        * @param height 视口高
        * @param viewMat 相机视图矩阵
        * @param projMat 相机投影矩阵
        * @param x 鼠标x
        * @param y 鼠标y
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.CalculateAndTransformRay = function (width, height, viewMat, projMat, x, y) {
            this.reset();
            this.dir.x = (2.0 * x / width - 1.0) / projMat.rawData[0];
            this.dir.y = (-2.0 * y / height + 1.0) / projMat.rawData[5];
            this.dir.z = 1.0;
            this.invViewMat.copyFrom(viewMat);
            this.origin.copyFrom(this.invViewMat.transformVector(this.origin));
            this.dir.copyFrom(this.invViewMat.deltaTransformVector(this.dir));
            this.dir.normalize();
        };
        /**
        * @language zh_CN
        * 射线重置
        * @version Egret 3.0
        * @platform Web,Native
        */
        Ray.prototype.reset = function () {
            this.origin.setTo(0, 0, 0);
            this.dir.setTo(0, 0, 0);
        };
        return Ray;
    })();
    egret3d.Ray = Ray;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
     * @language zh_CN
     * @class egret3d.Color
     * @classdesc
     * 可使用 Color 类调整显示对象的颜色值
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Color = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param r red
        * @param g green
        * @param b blue
        * @param a alpha
        */
        function Color(r, g, b, a) {
            if (r === void 0) { r = 0; }
            if (g === void 0) { g = 0; }
            if (b === void 0) { b = 0; }
            if (a === void 0) { a = 255; }
            /**
            * @language zh_CN
            * alpha
            */
            this.a = 255;
            /**
            * @language zh_CN
            * red
            */
            this.r = 255;
            /**
            * @language zh_CN
            * green
            */
            this.g = 255;
            /**
            * @language zh_CN
            * blue
            */
            this.b = 255;
            this.a = a;
            this.r = r;
            this.g = g;
            this.b = b;
        }
        /**
        * @language zh_CN
        * 返回白色
        * @retrun 白色
        */
        Color.white = function () {
            return new Color(255, 255, 255, 255);
        };
        /**
        * @language zh_CN
        * 返回黑色
        * @retrun 黑色
        */
        Color.black = function () {
            return new Color(0, 0, 0, 255);
        };
        /**
        * @language zh_CN
        * 返回白色
        * @retrun 白色
        */
        Color.red = function () {
            return new Color(255, 0, 0, 255);
        };
        /**
        * @language zh_CN
        * 返回绿色
        * @retrun 绿色
        */
        Color.green = function () {
            return new Color(0, 255, 0, 255);
        };
        /**
        * @language zh_CN
        * 返回蓝色
        * @retrun 蓝色
        */
        Color.blue = function () {
            return new Color(0, 0, 255, 255);
        };
        /**
        * @language zh_CN
        * 以number值返加颜色
        * @param colorFormat 格式
        * @returns 颜色
        */
        Color.prototype.getColor = function (colorFormat) {
            if (colorFormat === void 0) { colorFormat = egret3d.Egret3DDrive.ColorFormat_RGBA8888; }
            if (colorFormat == egret3d.Egret3DDrive.ColorFormat_RGB565)
                return 0;
            if (colorFormat == egret3d.Egret3DDrive.ColorFormat_RGBA5551)
                return 0;
            if (colorFormat == egret3d.Egret3DDrive.ColorFormat_RGBA4444)
                return 0;
            return this.r << 24 | this.g << 16 | this.b << 8 | this.a;
        };
        /**
        * @language zh_CN
        * 颜色取差值
        * @param c0
        * @param c1
        * @param t (0.0-1.0)
        */
        Color.prototype.lerp = function (c0, c1, t) {
            ///t(c1 - c0) + c0
            this.a = t * (c1.a - c0.a) + c0.a;
            this.r = t * (c1.r - c0.r) + c0.r;
            this.g = t * (c1.g - c0.g) + c0.g;
            this.b = t * (c1.b - c0.b) + c0.b;
        };
        return Color;
    })();
    egret3d.Color = Color;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.PickResult
    * @classdesc
    * 鼠标拾取返回数据。
    * 鼠标拾取模型上的交点 (本地坐标、世界坐标)
    * 鼠标拾取模型的uv
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PickResult = (function () {
        function PickResult() {
            /**
            * @language zh_CN
            * 鼠标拾取模型上的交点 (本地坐标)。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.localPosition = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 鼠标拾取模型上的交点 (世界坐标)。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.globalPosition = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 鼠标拾取模型的uv。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.uv = new egret3d.Vector3D();
        }
        return PickResult;
    })();
    egret3d.PickResult = PickResult;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.EventDispatcher
    * @classdesc
    * EventDispatcher 类是可调度事件的所有类的基类。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EventDispatcher = (function () {
        function EventDispatcher() {
            /**
             * @language zh_CN
             * @private
             */
            this.listeners = {};
        }
        /**
         * @language zh_CN
         * 派发一个 Event3D 事件到所有注册了特定类型侦听器的对象中。
         * @param event {any} 事件类型。
         * @version Egret 3.0
         * @platform Web,Native
         */
        EventDispatcher.prototype.dispatchEvent = function (event) {
            var e;
            var type;
            if (event instanceof Event3D) {
                type = event.type;
                e = event;
            }
            else {
                type = event;
                e = new Event3D(type);
            }
            if (this.listeners[type] != null) {
                e.currentTarget = this;
                for (var i = 0; i < this.listeners[type].length; i++) {
                    var listener = this.listeners[type][i];
                    try {
                        listener.handler(e);
                    }
                    catch (error) {
                        if (window.console) {
                            console.error(error.stack);
                        }
                    }
                }
            }
        };
        /**
        * @language zh_CN
        * 使用 EventDispatcher 对象注册事件侦听器对象，以使侦听器能够接收事件通知。可以为特定类型的事件和优先级注册事件侦听器。成功注册一个事件侦听器后，无法通过额外调用 addEventListener() 来更改其优先级。要更改侦听器的优先级，必须首先调用 removeListener()。然后，可以使用新的优先级再次注册该侦听器。
        * @param type {string} 事件的类型。
        * @param callback {Function} 处理事件的侦听器函数。此函数必须接受 Event3D 对象作为其唯一的参数，并且不能返回任何结果，
        * 如下面的示例所示： function(evt:Event3D):void 函数可以有任何名称。
        * @param  priority {number} 事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在
        * 优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
         * @version Egret 3.0
         * @platform Web,Native
        */
        EventDispatcher.prototype.addEventListener = function (type, callback, priolity) {
            if (priolity === void 0) { priolity = 0; }
            if (this.listeners[type] == null) {
                this.listeners[type] = [];
            }
            this.listeners[type].push(new EventListener(type, callback, priolity));
            this.listeners[type].sort(function (listener1, listener2) {
                return listener2.priolity - listener1.priolity;
            });
        };
        /**
         * @language zh_CN
         * 移除事件侦听器。
         * @param type {string} 事件名。
         * @param callback {Function} 侦听函数。
         * @version Egret 3.0
         * @platform Web,Native
         */
        EventDispatcher.prototype.removeEventListener = function (type, callback) {
            if (this.hasEventListener(type, callback)) {
                for (var i = 0; i < this.listeners[type].length; i++) {
                    var listener = this.listeners[type][i];
                    if (listener.equalCurrentListener(type, callback)) {
                        listener.handler = null;
                        this.listeners[type].splice(i, 1);
                        return;
                    }
                }
            }
        };
        /**
         * @language zh_CN
         * 移除所有事件侦听器。
         * @version Egret 3.0
         * @platform Web,Native
         */
        EventDispatcher.prototype.clearEventListener = function () {
            this.listeners = {};
        };
        /**
        * @language zh_CN
        * 检测是否存在监听器。
        * @param type {string}
        * @returns {boolean}
         * @version Egret 3.0
         * @platform Web,Native
        */
        EventDispatcher.prototype.containEventListener = function (type) {
            if (this.listeners[type] == null)
                return false;
            return this.listeners[type].length > 0;
        };
        /**
        * @language zh_CN
        * 检测是否存在监听器。
        * @param type {string} 事件名
        * @param callback {Function} 处理事件的侦听器函数
        * @returns {boolean}
        * @version Egret 3.0
        * @platform Web,Native
        */
        EventDispatcher.prototype.hasEventListener = function (type, callback) {
            if (this.listeners[type] == null)
                return false;
            for (var i = 0; i < this.listeners[type].length; i++) {
                var listener = this.listeners[type][i];
                if (listener.equalCurrentListener(type, callback)) {
                    return true;
                }
            }
            return false;
        };
        return EventDispatcher;
    })();
    egret3d.EventDispatcher = EventDispatcher;
    /**
    *
    * @language zh_CN
    * @class egret3d.EventListener
    * @classdesc
    * EventListener 类 用于添加或删除事件侦听器。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EventListener = (function () {
        /**
        * @language zh_CN
        * @param type 事件的类型。
        * @param handler 处理事件的侦听器函数
        * @param  priority 事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在
        * 优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function EventListener(type, handler, priolity) {
            if (type === void 0) { type = null; }
            if (handler === void 0) { handler = null; }
            if (priolity === void 0) { priolity = 0; }
            this.type = type;
            this.handler = handler;
            this.priolity = priolity;
        }
        /**
        * @language zh_CN
        * 比较两个事件是否相等。
        * @param type {string} 事件的类型。
        * @param handler {Function} 处理事件的侦听器函数
        * @version Egret 3.0
        * @platform Web,Native
        */
        EventListener.prototype.equalCurrentListener = function (type, handler) {
            if (this.type == type && this.handler == handler) {
                return true;
            }
            return false;
        };
        return EventListener;
    })();
    /**
    * @language zh_CN
    * @class egret3d.Event3D
    * @classdesc
    * Event3D 类作为创建 Event3D 对象的基类，当发生事件时，Event3D 对象将作为参数传递给事件侦听器。Event3D 类的属性包含有关事件的基本信息，例如事件的类型。对于许多事件（如由 Event3D 类常量表示的事件），此基本信息就足够了。但其他事件可能需要更详细的信息。例如，与鼠标单击关联的事件需要包括有关单击事件的位置以及在单击事件期间是否按下了任何键的其他信息。您可以通过扩展 Event3D 类（MouseEvent 类执行的操作）将此类其他信息传递给事件侦听器。
    * @includeExample events/Event3D.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Event3D = (function () {
        /**
        * @language zh_CN
        * 创建一个作为参数传递给事件侦听器的 Event3D 对象。
        * @param typeName {string} 事件类型
        * @param data {any}附加数据(可选)
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Event3D(type, data) {
            if (type === void 0) { type = null; }
            if (data === void 0) { data = null; }
            this._type = type;
            this._data = data;
        }
        Object.defineProperty(Event3D.prototype, "currentTarget", {
            /**
            * @language zh_CN
            * 事件当前对象。
            * @returns {any}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._currentTarget;
            },
            /**
            * @language zh_CN
            * 事件当前对象。
            * @param value {any}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._currentTarget = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Event3D.prototype, "type", {
            /**
            * @language zh_CN
            * 事件类型。
            * @returns {string}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._type;
            },
            /**
            * @language zh_CN
            * 事件类型。
            * @param value {string}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._type = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Event3D.prototype, "data", {
            /**
            * @language zh_CN
            * 附加数据。
            * @returns {any}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._data;
            },
            /**
            * @language zh_CN
            * 附加数据。
            * @param value {any}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._data = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * EVENT_LOAD_COMPLETE 常量定义 load_complete 事件对象的 type 属性的值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.EVENT_LOAD_COMPLETE = "load_complete";
        /**
        * @language zh_CN
        * MOUSE_CLICK 常量定义 onClick 事件对象的 type 属性的值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.MOUSE_CLICK = "onClick";
        /**
        * @language zh_CN
        * MOUSE_DOWN 常量定义 onMouseDown 事件对象的 type 属性的值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.MOUSE_DOWN = "onMouseDown";
        /**
        * @language zh_CN
        * MOUSE_UP 常量定义 onMouseUp 事件对象的 type 属性的值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.MOUSE_UP = "onMouseUp";
        /**
        * @language zh_CN
        * MOUSE_MOVE 常量定义 onMouseMove 事件对象的 type 属性的值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.MOUSE_MOVE = "onMouseMove";
        /**
        * @language zh_CN
        * TOUCH_MOVE 常量定义 onTouchMove 事件对象的 type 属性的值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.TOUCH_MOVE = "onTouchMove";
        /**
        * @language zh_CN
        * TOUCH_START 常量定义 onTouchStart 事件对象的 type 属性的值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.TOUCH_START = "onTouchStart";
        /**
        * @language zh_CN
        * TOUCH_END 常量定义 onTouchEnd 事件对象的 type 属性的值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.TOUCH_END = "onTouchEnd";
        /**
        * @language zh_CN
        * COMPLETE 常量定义 complete 事件对象的 type 属性的值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.COMPLETE = "complete";
        /**
        * @language zh_CN
        * CHANGE_PROPERTY 常量定义 changeProperty 事件对象的 type 属性的值。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Event3D.CHANGE_PROPERTY = "changeProperty";
        return Event3D;
    })();
    egret3d.Event3D = Event3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.Mouse3DManager
    * @classdesc
    * 鼠标事件管理。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Mouse3DManager = (function () {
        /**
        * @language zh_CN
        * 创建一个新的 Mouse3DManager 对象。
        * @param camera {Camera3D}
        * @param collect {CollectBase}
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Mouse3DManager(camera) {
            var _this = this;
            this._camera = camera;
            egret3d.Input.instance.addListenerKeyClick(function (code) { return _this.onMouseClick(code); });
            egret3d.Input.instance.addListenerKeyDown(function (code) { return _this.onMouseDown(code); });
            egret3d.Input.instance.addListenerKeyUp(function (code) { return _this.onMouseUp(code); });
            egret3d.Input.instance.addListenerMouseMove(function (e) { return _this.onMouseMove(e); });
            egret3d.Input.instance.addTouchStartCallback(function (e) { return _this.onTouchMove(e); });
            egret3d.Input.instance.addTouchEndCallback(function (e) { return _this.onTouchEnd(e); });
            egret3d.Input.instance.addTouchMoveCallback(function (e) { return _this.onTouchStart(e); });
        }
        Mouse3DManager.prototype.onTouchMove = function (e) {
            if (!this._collect)
                return;
            var ret = egret3d.Picker.pickObject3DList(this._camera, this._collect.mousePickList);
            var event;
            for (var i = 0; i < ret.length; i++) {
                event = new egret3d.Event3D(egret3d.Event3D.TOUCH_MOVE);
                event.currentTarget = ret[i];
                event.data = e;
                ret[i].dispatchEvent(event);
            }
        };
        Mouse3DManager.prototype.onTouchEnd = function (e) {
            if (!this._collect)
                return;
            var ret = egret3d.Picker.pickObject3DList(this._camera, this._collect.mousePickList);
            var event;
            for (var i = 0; i < ret.length; i++) {
                event = new egret3d.Event3D(egret3d.Event3D.TOUCH_END);
                event.currentTarget = ret[i];
                event.data = e;
                ret[i].dispatchEvent(event);
            }
        };
        Mouse3DManager.prototype.onTouchStart = function (e) {
            if (!this._collect)
                return;
            var ret = egret3d.Picker.pickObject3DList(this._camera, this._collect.mousePickList);
            var event;
            for (var i = 0; i < ret.length; i++) {
                event = new egret3d.Event3D(egret3d.Event3D.TOUCH_START);
                event.currentTarget = ret[i];
                event.data = e;
                ret[i].dispatchEvent(event);
            }
        };
        Mouse3DManager.prototype.onMouseClick = function (code) {
            if (!this._collect)
                return;
            var ret = egret3d.Picker.pickObject3DList(this._camera, this._collect.mousePickList);
            var event;
            for (var i = 0; i < ret.length; i++) {
                event = new egret3d.Event3D(egret3d.Event3D.MOUSE_CLICK);
                event.data = code;
                event.currentTarget = ret[i];
                ret[i].dispatchEvent(event);
            }
        };
        Mouse3DManager.prototype.onMouseDown = function (code) {
            if (!this._collect)
                return;
            var ret = egret3d.Picker.pickObject3DList(this._camera, this._collect.mousePickList);
            var event;
            for (var i = 0; i < ret.length; i++) {
                event = new egret3d.Event3D(egret3d.Event3D.MOUSE_DOWN);
                event.currentTarget = ret[i];
                event.data = code;
                ret[i].dispatchEvent(event);
            }
        };
        Mouse3DManager.prototype.onMouseUp = function (code) {
            if (!this._collect)
                return;
            var ret = egret3d.Picker.pickObject3DList(this._camera, this._collect.mousePickList);
            var event;
            for (var i = 0; i < ret.length; i++) {
                event = new egret3d.Event3D(egret3d.Event3D.MOUSE_UP);
                event.currentTarget = ret[i];
                event.data = code;
                ret[i].dispatchEvent(event);
            }
        };
        Mouse3DManager.prototype.onMouseMove = function (e) {
            if (!this._collect)
                return;
            var ret = egret3d.Picker.pickObject3DList(this._camera, this._collect.mousePickList);
            var event;
            for (var i = 0; i < ret.length; i++) {
                event = new egret3d.Event3D(egret3d.Event3D.MOUSE_MOVE);
                event.currentTarget = ret[i];
                event.data = e;
                ret[i].dispatchEvent(event);
            }
        };
        Mouse3DManager.prototype.update = function (collect) {
            this._collect = collect;
        };
        Mouse3DManager.left_mouse_over = "left_mouse_over";
        Mouse3DManager.left_mouse_down = "left_mouse_down";
        Mouse3DManager.left_mouse_up = "left_mouse_up";
        Mouse3DManager.left_mouse_click = "left_mouse_click";
        Mouse3DManager.right_mouse_over = "right_mouse_over";
        Mouse3DManager.right_mouse_down = "right_mouse_down";
        Mouse3DManager.right_mouse_up = "right_mouse_up";
        Mouse3DManager.right_mouse_click = "right_mouse_click";
        Mouse3DManager.middle_mouse_over = "middle_mouse_over";
        Mouse3DManager.middle_mouse_down = "middle_mouse_down";
        Mouse3DManager.middle_mouse_up = "middle_mouse_up";
        Mouse3DManager.middle_mouse_click = "middle_mouse_click";
        Mouse3DManager.mouse_move = "mouse_move";
        return Mouse3DManager;
    })();
    egret3d.Mouse3DManager = Mouse3DManager;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.TextureBase
    * @private
    * @classdesc
    * TextureBase 类为 贴图基类。
    *
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample texture/TextureBase.ts
    */
    var TextureBase = (function () {
        /**
         * @language zh_CN
         * 构造函数
         */
        function TextureBase() {
            this.border = 0;
            this.useMipmap = true;
            this.imageData = null;
            this.colorFormat = egret3d.Egret3DDrive.ColorFormat_RGBA8888;
            this.internalFormat = egret3d.InternalFormat.PixelArray;
            this.mimapData = new Array();
        }
        /**
         * @language zh_CN
         * 上传贴图数据给GPU
         * @param context3D
         */
        TextureBase.prototype.upload = function (context3D) {
            if (!this.texture) {
                this.texture = context3D.creatTexture2D();
                this.texture.gpu_internalformat = this.internalFormat;
                this.texture.gpu_colorformat = this.colorFormat;
                this.texture.mipmapDatas = this.mimapData;
                this.texture.image = this.imageData;
                this.texture.gpu_border = 0;
                if (this.useMipmap) {
                    for (var i = 0; i < this.mimapData.length; i++) {
                        context3D.upLoadTextureData(i, this.texture);
                    }
                }
                else {
                    context3D.upLoadTextureData(0, this.texture);
                }
            }
        };
        TextureBase.prototype.uploadForcing = function (context3D) {
            this.texture = context3D.creatTexture2D();
            this.texture.gpu_internalformat = this.internalFormat;
            this.texture.gpu_colorformat = this.colorFormat;
            this.texture.mipmapDatas = this.mimapData;
            this.texture.image = this.imageData;
            this.texture.gpu_border = 0;
            if (this.useMipmap) {
                for (var i = 0; i < this.mimapData.length; i++) {
                    context3D.upLoadTextureData(i, this.texture);
                }
            }
            else {
                context3D.upLoadTextureData(0, this.texture);
            }
        };
        Object.defineProperty(TextureBase.prototype, "width", {
            /**
             * @language zh_CN
             * 获取宽度值
             *
             * @returns width
             */
            get: function () {
                if (this.imageData)
                    return this.imageData.width;
                else if (this.mimapData.length > 0)
                    return this.mimapData[0].width;
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureBase.prototype, "height", {
            /**
             * @language zh_CN
             * 获取高度值
             *
             * @returns height
             */
            get: function () {
                if (this.imageData)
                    return this.imageData.height;
                else if (this.mimapData.length > 0)
                    return this.mimapData[0].height;
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        return TextureBase;
    })();
    egret3d.TextureBase = TextureBase;
})(egret3d || (egret3d = {}));
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.RenderTexture
    * @private
    * @classdesc
    * RenderTexture 类为渲染目标纹理，用于离屏渲染中。
    *
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample texture/RenderTexture.ts
    */
    var RenderTexture = (function (_super) {
        __extends(RenderTexture, _super);
        /**
         * @language zh_CN
         * 构造函数
         * @param texture ITexture2D对象
         */
        function RenderTexture(texture) {
            _super.call(this);
            this.useMipmap = false;
            this.texture = texture;
        }
        return RenderTexture;
    })(egret3d.TextureBase);
    egret3d.RenderTexture = RenderTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.SkyTexture
    * @classdesc
    * SkyTexture 类为天空贴图
    *
    * 天空贴图用于Sky类使用，其内部是将6张HTMLImageElement（网页图片元素）封装到CubeTexture对象，CubeTexture为引擎内部使用对象。
    *
    * 示例：
    * 假设html中已有
    *     <img id="t1" src="image_front.png" />
    *     <img id="t2" src="image_back.png" />
    *     <img id="t3" src="image_left.png" />
    *     <img id="t4" src="image_right.png" />
    *     <img id="t5" src="image_up.png" />
    *     <img id="t6" src="image_down.png" />
    *
    * 使用示例：
    * var skyTexture: egret3d.SkyTexture = new egret3d.SkyTexture(
    *     <HTMLImageElement>document.getElementById("t1"),
    *     <HTMLImageElement>document.getElementById("t2"),
    *     <HTMLImageElement>document.getElementById("t3"),
    *     <HTMLImageElement>document.getElementById("t4"),
    *     <HTMLImageElement>document.getElementById("t5"),
    *     <HTMLImageElement>document.getElementById("t6")
    * );
    *
    * view3D.sky = new egret3d.Sky(skyTexture);
    *
    * @see egret3d.Sky
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample texture/SkyTexture.ts
    */
    var SkyTexture = (function (_super) {
        __extends(SkyTexture, _super);
        /**
         * @language zh_CN
         * 构造函数
         * @param image_front 前部HTMLImageElement图片元素
         * @param image_back 背部HTMLImageElement图片元素
         * @param image_left 左部HTMLImageElement图片元素
         * @param image_right 右部HTMLImageElement图片元素
         * @param image_up 顶部HTMLImageElement图片元素
         * @param image_down 底部HTMLImageElement图片元素
         */
        function SkyTexture(image_front, image_back, image_left, image_right, image_up, image_down) {
            _super.call(this);
            imageData: HTMLImageElement;
            this.image_front = image_front;
            this.image_back = image_back;
            this.image_left = image_left;
            this.image_right = image_right;
            this.image_up = image_up;
            this.image_down = image_down;
        }
        /**
         * @language zh_CN
         * 上传贴图数据给GPU
         * 更新上传 cube 贴图纹理到GPU 现存中缓存起来
         * @param context3D
         */
        SkyTexture.prototype.upload = function (context3D) {
            if (!this.cubeTexture) {
                this.cubeTexture = context3D.creatCubeTexture();
                this.cubeTexture.image_front = this.image_front;
                this.cubeTexture.image_back = this.image_back;
                this.cubeTexture.image_left = this.image_left;
                this.cubeTexture.image_right = this.image_right;
                this.cubeTexture.image_up = this.image_up;
                this.cubeTexture.image_down = this.image_down;
                context3D.uploadCubetexture(this.cubeTexture);
            }
        };
        return SkyTexture;
    })(egret3d.TextureBase);
    egret3d.SkyTexture = SkyTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.ImageTexture
    * @classdesc
    * ImageTexture 类为 图像贴图
    *
    * 图像贴图用于封装 HTMLImageElement（网页图像元素）到引擎内部可使用的Texture2D对象，HTMLImageElement 可通过内嵌HTML文件中获取。
    *
    * 示例：
    * 假设html中已有 <img id="t1" src="xxx.png" />
    *
    * TS代码：
    * var img: HTMLImageElement = <HTMLImageElement>document.getElementById("t1");
    *
    * var imageTexture: egret3d.ImageTexture = new egret3d.ImageTexture(img);
    *
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample texture/ImageTexture.ts
    */
    var ImageTexture = (function (_super) {
        __extends(ImageTexture, _super);
        /**
         * @language zh_CN
         * 构造函数
         * @param img HTMLImageElement（网页图像元素）
         */
        function ImageTexture(img) {
            _super.call(this);
            this.imageData = img;
        }
        /**
         * @language zh_CN
         * 上传贴图数据给GPU
         * @param context3D
         */
        ImageTexture.prototype.upload = function (context3D) {
            if (!this.texture) {
                this.texture = context3D.creatTexture2D();
                this.texture.gpu_internalformat = egret3d.InternalFormat.ImageData;
                this.texture.gpu_colorformat = egret3d.Egret3DDrive.ColorFormat_RGBA8888;
                this.texture.image = this.imageData;
                this.useMipmap = false;
                context3D.upLoadTextureData(0, this.texture);
            }
        };
        return ImageTexture;
    })(egret3d.TextureBase);
    egret3d.ImageTexture = ImageTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.CheckerboardTexture
    * @classdesc
    * CheckerboardTexture 类为 棋盘格纹理类
    *
    * 棋盘格纹理为黑白间隔色块组成的一张纹理，主要用于判别模型UV的正确性，若某模型UV值不正确，其纹理表现必定乱序不规整。
    * 使用示例;
    * var material: egret3d.TextureMaterial = new egret3d.TextureMaterial(egret3d.CheckerboardTexture.texture );
    * var mesh: egret3d.Mesh = new egret3d.Mesh(new egret3d.CubeGeometry(), material);
    *
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample texture/CheckerboardTexture.ts
    */
    var CheckerboardTexture = (function (_super) {
        __extends(CheckerboardTexture, _super);
        /**
         * @language zh_CN
         * 构造函数
         */
        function CheckerboardTexture() {
            _super.call(this);
            this._width = 32;
            this._height = 32;
            this.buildCheckerboard();
            this.mimapData = new Array();
            this.mimapData.push(new egret3d.MipmapData(this._pixelArray, this._width, this._height));
        }
        /**
         * @language zh_CN
         * 上传贴图数据给GPU
         * @param context3D
         */
        CheckerboardTexture.prototype.upload = function (context3D) {
            if (!this.texture) {
                this.texture = context3D.creatTexture2D();
                this.texture.gpu_border = 0;
                this.texture.gpu_internalformat = egret3d.InternalFormat.PixelArray;
                this.texture.gpu_colorformat = egret3d.Egret3DDrive.ColorFormat_RGBA8888;
                this.texture.mipmapDatas = this.mimapData;
                this.useMipmap = false;
                context3D.upLoadTextureData(0, this.texture);
            }
        };
        CheckerboardTexture.prototype.buildCheckerboard = function () {
            if (!this._pixelArray) {
                this._pixelArray = new Uint8Array(this._width * this._height * 4);
                var colors = [egret3d.Color.white(), egret3d.Color.black()];
                var colorIndex = 0;
                var blockSize = 4;
                for (var y = 0; y < this._height; y++) {
                    for (var x = 0; x < this._width; x++) {
                        if ((x % blockSize) == 0) {
                            colorIndex = (colorIndex + 1) % 2;
                        }
                        if ((y % blockSize) == 0 && x == 0) {
                            var tmp = colors[0];
                            colors[0] = colors[1];
                            colors[1] = tmp;
                            colorIndex = 0;
                        }
                        this._pixelArray[(y * (this._width * 4) + x * 4) + 0] = colors[colorIndex].r;
                        this._pixelArray[(y * (this._width * 4) + x * 4) + 1] = colors[colorIndex].g;
                        this._pixelArray[(y * (this._width * 4) + x * 4) + 2] = colors[colorIndex].b;
                        this._pixelArray[(y * (this._width * 4) + x * 4) + 3] = colors[colorIndex].a;
                    }
                }
            }
        };
        /**
         * @language zh_CN
         * 公用棋盘格实例对象
         */
        CheckerboardTexture.texture = new CheckerboardTexture();
        return CheckerboardTexture;
    })(egret3d.TextureBase);
    egret3d.CheckerboardTexture = CheckerboardTexture;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.AnimNodeBase
     * @classdesc
     * 动画节点基类
     *
     * 动画驱动的基本节点父类，实现基本统一的动画节点结构
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample animation/AnimNodeBase.ts
     */
    var AnimNodeBase = (function () {
        function AnimNodeBase() {
        }
        /**
        * @language zh_CN
        * 填充GeomtryData
        * @param geometry: Geometry对象
        * @private
        */
        AnimNodeBase.prototype.fillGeomtryData = function (geometry) {
        };
        return AnimNodeBase;
    })();
    egret3d.AnimNodeBase = AnimNodeBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.AnimaNodeCollection
     * @classdesc
     * 动画功能节点收集器
     * 动画功能的收集，整理，初始化容器，一般在粒子系统里使用
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample animation/AnimaNodeCollection.ts
     */
    var AnimaNodeCollection = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @priavte
        */
        function AnimaNodeCollection() {
            /**
            * @language zh_CN
            * 动画节点容器
            * @priavte
            */
            this.nodes = new Array();
            /**
            * @language zh_CN
            * @priavte
            */
            this._vertexAttributes = {};
            this.nodes = new Array();
        }
        /**
        * @language zh_CN
        * 添加动画功能节点
        * 添加继承 animNodeBase 功能节点 例如粒子的 加速度功能节点，匀速功能节点
        * @param node 节点对象
        */
        AnimaNodeCollection.prototype.addNode = function (node) {
            this.nodes.push(node);
        };
        /**
        * @language zh_CN
        * 移除动画功能节点
        * 删除指定的动画功能节点，但是不能动态删除，需要进行 功能重置
        * @param node 节点对象
        */
        AnimaNodeCollection.prototype.removeNode = function (node) {
            var index = this.nodes.indexOf(node);
            if (index != -1)
                this.nodes.splice(index, 1);
        };
        /**
        * @language zh_CN
        * 获取节点容器
        * 获取整体的功能节点列表
        * @return 节点容器
        */
        AnimaNodeCollection.prototype.getNodes = function () {
            return this.nodes;
        };
        /**
        * @language zh_CN
        * 获取节点顶点Shader
        * @return 顶点Shader容器
        * @private
        */
        AnimaNodeCollection.prototype.getNodesVertexShaders = function () {
            var shaderNames = [];
            for (var i = 0; i < this.nodes.length; i++) {
                if (this.nodes[i].vertexShader != "" && this.nodes[i].vertexShader != undefined && this.nodes[i].vertexShader != null)
                    shaderNames.push(this.nodes[i].vertexShader);
            }
            return shaderNames;
        };
        /**
        * @language zh_CN
        * 获取节点片元Shader
        * @return 片元Shader容器
        * @private
        */
        AnimaNodeCollection.prototype.getNodesFragmentShaders = function () {
            var shaderNames = [];
            for (var i = 0; i < this.nodes.length; i++) {
                if (this.nodes[i].fragmentShader != "" && this.nodes[i].fragmentShader != undefined && this.nodes[i].fragmentShader != null)
                    shaderNames.push(this.nodes[i].fragmentShader);
            }
            return shaderNames;
        };
        /**
        * @language zh_CN
        * 计算节点
        * @private
        */
        AnimaNodeCollection.prototype.calculateNode = function () {
            ///init data to updata gpu
            ///this.vertexInfos = this.vertexInfos || new Array<VertexInfo>();
            ///this.vertexInfos.length = 0; 
            var offset = 4 + 3 + 2;
            for (var i = 0; i < this.nodes.length; i++) {
                if (this.nodes[i].usageAttributeLen > 0) {
                    this.nodes[i].offset = offset;
                    this.nodes[i].offsetBytes = offset * Float32Array.BYTES_PER_ELEMENT;
                    offset += this.nodes[i].usageAttributeLen;
                }
            }
            this.numberOfVertices = offset;
            this.vertexSizeInBytes = offset * Float32Array.BYTES_PER_ELEMENT;
        };
        return AnimaNodeCollection;
    })();
    egret3d.AnimaNodeCollection = AnimaNodeCollection;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.Joint
     * @classdesc
     * Joint 类表示骨骼关节，属于骨架类的组成部分， Joint类属于骨架实现的内部类，无需直接实例化。
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample animation/skeletonAnimation/Joint.ts
     */
    var Joint = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @param name 骨骼名称
        */
        function Joint(name) {
            /**
            * @language zh_CN
            * 骨骼矩阵是否有效
            */
            this.jointMatrixValid = false;
            /**
            * @language zh_CN
            * 骨骼世界矩阵是否有效
            */
            this.worldMatrixValid = false;
            /**
            * @language zh_CN
            * 骨骼矩阵
            */
            this.jointMatrix = new egret3d.Matrix4_4();
            /**
            * @language zh_CN
            * 骨骼世界矩阵
            */
            this.worldMatrix = new egret3d.Matrix4_4();
            /**
            * @language zh_CN
            * 骨骼名称
            */
            this.name = null;
            /**
            * @language zh_CN
            * 父骨骼名称
            */
            this.parent = null;
            /**
            * @language zh_CN
            * 父骨骼索引编号
            */
            this.parentIndex = -1;
            /**
            * @language zh_CN
            * 骨骼逆矩阵
            */
            this.inverseBindPose = null;
            /**
            * @language zh_CN
            * 骨骼缩放量
            */
            this.scale = null;
            /**
            * @language zh_CN
            * 骨骼旋转量
            */
            this.orientation = null;
            /**
            * @language zh_CN
            * 骨骼平移量
            */
            this.translation = null;
            /**
            * @language zh_CN
            * 骨骼本地矩阵
            */
            this.localMatrix = null;
            this.name = name;
        }
        /**
        * @language zh_CN
        * 克隆新骨骼对象
        * @return 新骨骼对象
        */
        Joint.prototype.clone = function () {
            var cloneObj = new Joint(this.name);
            cloneObj.parent = this.parent;
            cloneObj.parentIndex = this.parentIndex;
            if (this.inverseBindPose) {
                cloneObj.inverseBindPose = new egret3d.Matrix4_4;
                cloneObj.inverseBindPose.copyFrom(this.inverseBindPose);
            }
            if (this.scale) {
                cloneObj.scale = new egret3d.Vector3D();
                cloneObj.scale.copyFrom(this.scale);
            }
            if (this.orientation) {
                cloneObj.orientation = new egret3d.Quaternion();
                cloneObj.orientation.copyFrom(this.orientation);
            }
            if (this.translation) {
                cloneObj.translation = new egret3d.Vector3D();
                cloneObj.translation.copyFrom(this.translation);
            }
            if (this.scale && this.orientation && this.translation) {
                cloneObj.setLocalTransform(cloneObj.orientation, cloneObj.scale, cloneObj.translation);
            }
            return cloneObj;
        };
        /**
        * @language zh_CN
        * 设置骨骼逆矩阵
        * @param translation 平移量
        * @param rotation 旋转量
        * @param scaling 缩放量
        */
        Joint.prototype.setInverseBindPose = function (translation, rotation, scaling) {
            if (!this.inverseBindPose) {
                this.inverseBindPose = new egret3d.Matrix4_4();
            }
            this.inverseBindPose.recompose([translation, rotation, scaling]);
        };
        /**
        * @language zh_CN
        * 设置骨骼本地置换
        * @param orientation 旋转量
        * @param scale 缩放量
        * @param translation 平移量
        */
        Joint.prototype.setLocalTransform = function (orientation, scale, translation) {
            this.translation = translation;
            this.orientation = orientation;
            this.scale = scale;
            if (!this.localMatrix) {
                this.localMatrix = new egret3d.Matrix4_4();
            }
            this.localMatrix.makeTransform(this.translation, this.scale, this.orientation);
        };
        return Joint;
    })();
    egret3d.Joint = Joint;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.Skeleton
     * @classdesc
     * Skeleton 类表示骨架类，其中包含若干个 Joint（骨骼关节） 对象，Skeleton（骨架类）是组成骨骼动画的单帧单位。
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample animation/skeletonAnimation/Skeleton.ts
     */
    var Skeleton = (function () {
        function Skeleton(initialSkeleton) {
            if (initialSkeleton === void 0) { initialSkeleton = null; }
            /**
            * @language zh_CN
            * 当前骨架帧时间
            */
            this.frameTime = 0;
            /**
            * @language zh_CN
            * 骨架包含的骨骼
            */
            this.joints = [];
            /**
            * @language zh_CN
            * 骨架矩阵是否有效
            */
            this.skeletonMatrixValid = false;
            this._skeletonMatrix = null;
            this._initialSkeleton = null;
            this._temp_q0 = new egret3d.Quaternion();
            this._temp_q1 = new egret3d.Quaternion();
            this._temp_q2 = new egret3d.Quaternion();
            this._temp_v0 = new egret3d.Vector3D();
            this._temp_v1 = new egret3d.Vector3D();
            this._temp_v2 = new egret3d.Vector3D();
            if (initialSkeleton) {
                this.initialSkeleton = initialSkeleton;
            }
        }
        /**
        * @language zh_CN
        * 克隆新骨架对象
        * @return 新骨架对象
        */
        Skeleton.prototype.clone = function () {
            var cloneObj = new Skeleton(this.initialSkeleton);
            cloneObj.frameTime = this.frameTime;
            for (var i = 0; i < this.joints.length; i++) {
                cloneObj.joints.push(this.joints[i].clone());
            }
            return cloneObj;
        };
        /**
        * @language zh_CN
        * 重置骨架数据
        */
        Skeleton.prototype.reset = function () {
            for (var i = 0; i < this.joints.length; i++) {
                this.joints[i].jointMatrix.identity();
                this.joints[i].jointMatrixValid = false;
                this.joints[i].worldMatrix.identity();
                this.joints[i].worldMatrixValid = false;
                this.joints[i].orientation.x =
                    this.joints[i].orientation.y =
                        this.joints[i].orientation.z =
                            this.joints[i].orientation.w = 0;
                this.joints[i].scale.x =
                    this.joints[i].scale.y =
                        this.joints[i].scale.z =
                            this.joints[i].scale.w = 0;
                this.joints[i].translation.x =
                    this.joints[i].translation.y =
                        this.joints[i].translation.z =
                            this.joints[i].translation.w = 0;
            }
        };
        Object.defineProperty(Skeleton.prototype, "initialSkeleton", {
            /**
            * @language zh_CN
            * 初始骨架
            */
            get: function () {
                return this._initialSkeleton;
            },
            /**
            * @language zh_CN
            * 设置初始骨架
            * @param value 初始骨架
            */
            set: function (value) {
                this._initialSkeleton = value;
                if (!this._skeletonMatrix) {
                    this._skeletonMatrix = new Float32Array(this._initialSkeleton.numJoint * 8);
                    this.skeletonMatrixValid = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Skeleton.prototype, "skeletonMatrix", {
            /**
            * @language zh_CN
            * 骨架矩阵阵列
            */
            get: function () {
                return this._skeletonMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Skeleton.prototype, "numJoint", {
            /**
            * @language zh_CN
            * 骨骼数量
            */
            get: function () {
                return this.joints.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 通过名称查找指定骨骼
        * @param name 骨骼名称
        * @return 骨骼对象
        */
        Skeleton.prototype.findJoint = function (name) {
            for (var i = 0; i < this.joints.length; i++) {
                if (this.joints[i].name == name)
                    return this.joints[i];
            }
            return null;
        };
        /**
        * @language zh_CN
        * 通过名称查找骨骼索引编号
        * @param name 骨骼名称
        * @return 骨骼索引编号
        */
        Skeleton.prototype.findJointIndex = function (name) {
            for (var i = 0; i < this.joints.length; i++) {
                if (this.joints[i].name == name)
                    return i;
            }
            return -1;
        };
        /**
        * @language zh_CN
        * 骨架插值
        * @param skeleton0 骨架0
        * @param skeleton1 骨架1
        * @param tNow 新骨架帧时间（骨架0.frameTime ~ 骨架1.frameTime）
        */
        Skeleton.prototype.skeletonLerp = function (skeleton0, skeleton1, tNow) {
            this.frameTime = tNow;
            var t = (tNow - skeleton0.frameTime) / Math.abs(skeleton1.frameTime - skeleton0.frameTime);
            this.lerp(skeleton0, skeleton1, t);
        };
        /**
        * @language zh_CN
        * 骨架插值计算
        * @param skeleton0 骨架0
        * @param skeleton1 骨架1
        * @param t 时间因子(0.0~1.0);
        */
        Skeleton.prototype.lerp = function (skeleton0, skeleton1, t) {
            for (var index = 0; index < skeleton0.joints.length; index++) {
                if (index >= this.joints.length) {
                    this.joints.push(new egret3d.Joint(null));
                }
                var newJointPose = this.joints[index];
                newJointPose.name = skeleton0.joints[index].name;
                newJointPose.worldMatrixValid = true;
                this._temp_q0.fromMatrix(skeleton0.joints[index].worldMatrix);
                this._temp_q1.fromMatrix(skeleton1.joints[index].worldMatrix);
                this._temp_q2.lerp(this._temp_q0, this._temp_q1, t);
                skeleton0.joints[index].worldMatrix.copyRowTo(3, this._temp_v0);
                skeleton1.joints[index].worldMatrix.copyRowTo(3, this._temp_v1);
                this._temp_v2.lerp(this._temp_v0, this._temp_v1, t);
                this._temp_q2.toMatrix3D(newJointPose.worldMatrix);
                newJointPose.worldMatrix.rawData[12] = this._temp_v2.x;
                newJointPose.worldMatrix.rawData[13] = this._temp_v2.y;
                newJointPose.worldMatrix.rawData[14] = this._temp_v2.z;
                newJointPose.jointMatrixValid = false;
                this.skeletonMatrixValid = false;
            }
        };
        /**
        * @language zh_CN
        * 骨架转矩阵阵列数组
        * @param target 用于储存的矩阵阵列数组
        * @return 矩阵阵列数组
        */
        Skeleton.prototype.toMatrixData = function (target) {
            if (target === void 0) { target = null; }
            var joints = this._initialSkeleton.joints;
            if (!target) {
                target = new Float32Array(this.joints.length * 8);
            }
            for (var i = 0; i < joints.length; i++) {
                for (var j = 0; j < this.joints.length; j++) {
                    if (this.joints[j].name != joints[i].name)
                        continue;
                    this._temp_q0.fromMatrix(this.joints[j].jointMatrix);
                    target[i * 8 + 0] = this._temp_q0.x;
                    target[i * 8 + 1] = this._temp_q0.y;
                    target[i * 8 + 2] = this._temp_q0.z;
                    target[i * 8 + 3] = this._temp_q0.w;
                    target[i * 8 + 4] = this.joints[j].jointMatrix.rawData[12];
                    target[i * 8 + 5] = this.joints[j].jointMatrix.rawData[13];
                    target[i * 8 + 6] = this.joints[j].jointMatrix.rawData[14];
                    target[i * 8 + 7] = 1;
                    break;
                }
            }
            return target;
        };
        /**
        * @language zh_CN
        * 更新骨架矩阵
        */
        Skeleton.prototype.updateSkeletonMatrix = function () {
            if (this.skeletonMatrixValid) {
                return;
            }
            this.toMatrixData(this._skeletonMatrix);
            this.skeletonMatrixValid = true;
        };
        /**
        * @language zh_CN
        * 计算骨骼世界矩阵
        * @param initialSkeleton 初始骨架对象
        */
        Skeleton.prototype.calculateJointWorldMatrix = function (initialSkeleton) {
            for (var i = 0; i < this.joints.length; i++) {
                var jointPose = this.joints[i];
                this.calculateAbsoluteMatrix(this.joints, i, initialSkeleton);
            }
            for (var i = 0; i < this.joints.length; i++) {
                var jointPose = this.joints[i];
                if (!jointPose.jointMatrixValid) {
                    jointPose.jointMatrix = new egret3d.Matrix4_4();
                    if (initialSkeleton.joints[i].inverseBindPose) {
                        jointPose.jointMatrix.copyFrom(initialSkeleton.joints[i].inverseBindPose);
                        jointPose.jointMatrix.append(jointPose.worldMatrix);
                    }
                    jointPose.jointMatrixValid = true;
                }
            }
            this.skeletonMatrixValid = false;
        };
        Skeleton.prototype.calculateAbsoluteMatrix = function (currentSkeletonPose, jointIndex, initialSkeleton) {
            var currentJointPose = currentSkeletonPose[jointIndex];
            var currentJointParentIndex = initialSkeleton.joints[jointIndex].parentIndex;
            if (currentJointParentIndex >= 0) {
                this.calculateAbsoluteMatrix(currentSkeletonPose, currentJointParentIndex, initialSkeleton);
            }
            if (!currentJointPose.worldMatrixValid) {
                currentJointPose.worldMatrix.copyFrom(currentJointPose.localMatrix);
                if (currentJointParentIndex >= 0) {
                    currentJointPose.worldMatrix.append(currentSkeletonPose[currentJointParentIndex].worldMatrix);
                }
                currentJointPose.worldMatrixValid = true;
            }
        };
        return Skeleton;
    })();
    egret3d.Skeleton = Skeleton;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.SkeletonAnimationClip
     * @classdesc
     * SkeletonAnimationClip 类为骨骼动画
     *
     * SkeletonAnimationClip类为骨骼动画，其中保存管理若干个Skeleton（骨架对象），每个骨架对象都为该动画某时刻的骨骼帧信息。
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample animation/skeletonAnimation/SkeletonAnimationClip.ts
     */
    var SkeletonAnimationClip = (function () {
        function SkeletonAnimationClip(animName) {
            /**
            * @language zh_CN
            * 帧数
            */
            this.frameCount = 0;
            this._animName = null;
            this._sampling = 1;
            this._loop = true;
            this._playing = true;
            this._enabled = true;
            this._weight = 1.0;
            this._length = 0;
            this._parent = null;
            this._poseArray = null;
            this._animName = animName;
        }
        Object.defineProperty(SkeletonAnimationClip.prototype, "parent", {
            /**
            * @language zh_CN
            * 父对象
            */
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationClip.prototype, "poseArray", {
            /**
            * @language zh_CN
            * 动画Pose骨架序列
            */
            get: function () {
                return this._poseArray;
            },
            /**
            * @language zh_CN
            * 动画Pose骨架序列
            */
            set: function (array) {
                this._poseArray = array;
                this._length = array[array.length - 1].frameTime;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 克隆新的SkeletonAnimationClip对象
        * @return 新的SkeletonAnimationClip
        */
        SkeletonAnimationClip.prototype.clone = function () {
            var cloneObj = new SkeletonAnimationClip(this.animationName);
            cloneObj.frameCount = this.frameCount;
            cloneObj.poseArray = this._poseArray;
            return cloneObj;
        };
        /**
        * @language zh_CN
        * 是否已经结束
        * @return 是否已经结束
        */
        SkeletonAnimationClip.prototype.hasEnded = function () {
            return ((this._timePosition >= this._length) && !this._loop);
        };
        /**
        * @language zh_CN
        * 添加动画播放时间偏移量
        * @param offset 时间增量
        */
        SkeletonAnimationClip.prototype.addTime = function (offset) {
            this.timePosition += offset;
        };
        Object.defineProperty(SkeletonAnimationClip.prototype, "currentFrameIndex", {
            /**
            * @language zh_CN
            * 当前帧索引
            */
            get: function () {
                var currentFrameIndex = Math.floor(this._timePosition / 80) % this._poseArray.length;
                return currentFrameIndex;
            },
            /**
            * @language zh_CN
            * 当前帧索引
            */
            set: function (value) {
                value = Math.abs(value) % this._poseArray.length;
                this.timePosition = value * 80;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationClip.prototype, "nextFrameIndex", {
            /**
            * @language zh_CN
            * 下一帧的索引
            */
            get: function () {
                return (this.currentFrameIndex + 1) % this._poseArray.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationClip.prototype, "animationName", {
            /**
            * @language zh_CN
            * 动画名称
            */
            get: function () {
                return this._animName;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationClip.prototype, "length", {
            /**
            * @language zh_CN
            * 动画长度
            */
            get: function () {
                return this._length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationClip.prototype, "sampling", {
            /**
            * @language zh_CN
            * 采样率
            */
            get: function () {
                return this._sampling;
            },
            /**
            * @language zh_CN
            * 采样率
            */
            set: function (value) {
                this._sampling = Math.max(value, 1);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationClip.prototype, "loop", {
            /**
            * @language zh_CN
            * 是否循环
            */
            get: function () {
                return this._loop;
            },
            /**
            * @language zh_CN
            * 是否循环
            */
            set: function (value) {
                this._loop = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationClip.prototype, "play", {
            /**
            * @language zh_CN
            * 是否播放中
            */
            get: function () {
                return this._playing;
            },
            /**
            * @language zh_CN
            * 是否播放
            */
            set: function (value) {
                this._playing = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationClip.prototype, "enabled", {
            /**
            * @language zh_CN
            * 是否启用
            */
            get: function () {
                return this._enabled;
            },
            /**
            * @language zh_CN
            * 是否启用
            */
            set: function (value) {
                this._enabled = value;
                //this.parent.notifyAnimationStateEnabled(this, value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationClip.prototype, "weight", {
            /**
            * @language zh_CN
            * 混合权重
            */
            get: function () {
                return this._weight;
            },
            /**
            * @language zh_CN
            * 混合权重
            */
            set: function (value) {
                this._weight = value;
                if (this._enabled) {
                    ; //this.parent.notifyDirty();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimationClip.prototype, "timePosition", {
            /**
            * @language zh_CN
            * 播放的时间位置
            */
            get: function () {
                return this._timePosition;
            },
            /**
            * @language zh_CN
            * 播放的时间位置
            */
            set: function (value) {
                if (value != this._timePosition) {
                    this._timePosition = value;
                    if (this._loop) {
                        this._timePosition = value % this._length;
                        if (this._timePosition < 0) {
                            this._timePosition += this._length;
                        }
                    }
                    else {
                        if (this._timePosition < 0) {
                            this._timePosition = 0;
                        }
                        else if (this._timePosition > this._length) {
                            this._timePosition = this._length;
                            this._playing = false;
                        }
                    }
                    if (this.enabled) {
                        ; //this.parent.notifyDirty();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 填充帧
        * @param initialSkeleton 初始骨架
        */
        SkeletonAnimationClip.prototype.fillFrame = function (initialSkeleton) {
            for (var i = 0; i < this._poseArray.length; i++) {
                this._poseArray[i].calculateJointWorldMatrix(initialSkeleton);
            }
            if (this.frameCount == this._poseArray.length - 1)
                return;
            var skeletonPose = new Array();
            var fps = 60.0;
            var gpf = 1000.0 / fps;
            skeletonPose.push(this._poseArray[0]);
            for (var frameIndex = 1; frameIndex <= this.frameCount; frameIndex++) {
                var currFrame = skeletonPose[frameIndex - 1];
                var nextFrame = this._poseArray[(Math.floor(frameIndex / this.sampling) + 1) % this._poseArray.length];
                var targetSkeletonPose = new egret3d.Skeleton();
                targetSkeletonPose.skeletonLerp(currFrame, nextFrame, frameIndex * gpf);
                skeletonPose.push(targetSkeletonPose);
            }
            this.poseArray = skeletonPose;
        };
        return SkeletonAnimationClip;
    })();
    egret3d.SkeletonAnimationClip = SkeletonAnimationClip;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.SkeletonAnimation
     * @classdesc
     * SkeletonAnimation 类表示骨骼动画控制类
     *
     * 骨骼动画控制类中管理若干个 SkeletonAnimationClip（骨骼动画） 对象，每个SkeletonAnimationClip对象，都是对*.eam 文件的实例。
     *
     * @see egret3d.SkeletonAnimationClip
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample animation/skeletonAnimation/SkeletonAnimation.ts
     */
    var SkeletonAnimation = (function (_super) {
        __extends(SkeletonAnimation, _super);
        function SkeletonAnimation(initialSkeleton) {
            _super.call(this);
            /**
            * @language zh_CN
            * 是否开启平滑
            */
            this.smooth = false;
            this._initialSkeleton = null;
            this._animList = [];
            this._animationSkeleton = new egret3d.Skeleton();
            this._bindList = {};
            this._enabledSkeletonAnimationClips = [];
            this._eventCallbackList = [];
            this._skeletonAnimationClips = {};
            this._blendSkeleton = null;
            this._useCache = true;
            this._playSpeed = 1.0;
            this._playing = false;
            this._currentFrame = 0;
            this._temp_smooth = new egret3d.Skeleton();
            this._temp_quat = new egret3d.Quaternion();
            this._temp_vec3 = new egret3d.Vector3D();
            this._initialSkeleton = initialSkeleton;
            this._skeletonMatrix = new Float32Array(this._initialSkeleton.numJoint * 8);
        }
        Object.defineProperty(SkeletonAnimation.prototype, "skeletonAnimationController", {
            /**
            * @language zh_CN
            * 骨骼动画容器
            * @return SkeletonAnimation对象
            */
            get: function () {
                return this;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 初始化Shader
        * @param vertexShader 顶点Shader
        * @param pixelShader 片元Shader
        * @return xxx
        */
        SkeletonAnimation.prototype.initShader = function (vertexShader, pixelShader) {
            vertexShader.maxBone = this.jointNumber * 2;
        };
        /**
        * @language zh_CN
        * 克隆新的SkeletonAnimation对象
        * @return 新的SkeletonAnimation对象
        */
        SkeletonAnimation.prototype.clone = function () {
            var ret = new SkeletonAnimation(this._initialSkeleton);
            for (var id in this._skeletonAnimationClips) {
                ret._skeletonAnimationClips[id] = this._skeletonAnimationClips[id].clone();
            }
            ret._animationSkeleton = this._animationSkeleton;
            ret._animList = this._animList;
            ret._blendSkeleton = this._blendSkeleton.clone();
            return ret;
        };
        Object.defineProperty(SkeletonAnimation.prototype, "currentSkeletonMatrixData", {
            /**
            * @language zh_CN
            * 当前播放的骨架矩阵阵列数组
            */
            get: function () {
                return this._skeletonMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkeletonAnimation.prototype, "jointNumber", {
            /**
            * @language zh_CN
            * 骨骼数
            */
            get: function () {
                return this._initialSkeleton.numJoint;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 添加SkeletonAnimationClip对象
        * @param animationState SkeletonAnimationClip对象
        * @return SkeletonAnimationClip对象
        */
        SkeletonAnimation.prototype.addSkeletonAnimationClip = function (animationState) {
            if (this._skeletonAnimationClips[animationState.animationName]) {
                return this._skeletonAnimationClips[animationState.animationName];
            }
            if (this._animationSkeleton.numJoint < animationState.poseArray[0].joints.length && this._animationSkeleton.numJoint != animationState.poseArray[0].joints.length) {
                this._animationSkeleton.joints = [];
                var jointPoses = animationState.poseArray[0].joints;
                for (var i = 0; i < jointPoses.length; i++) {
                    var joint = new egret3d.Joint(jointPoses[i].name);
                    joint.parentIndex = animationState.poseArray[0].findJointIndex(jointPoses[i].parent);
                    var inverseBindPoseJoint = this._initialSkeleton.findJoint(joint.name);
                    if (inverseBindPoseJoint) {
                        joint.inverseBindPose = inverseBindPoseJoint.inverseBindPose;
                    }
                    else {
                        joint.inverseBindPose = null;
                    }
                    this._animationSkeleton.joints.push(joint);
                }
            }
            animationState.fillFrame(this._animationSkeleton);
            animationState.parent = this;
            for (var i = 0; i < animationState.poseArray.length; i++) {
                animationState.poseArray[i].initialSkeleton = this._initialSkeleton;
            }
            this._skeletonAnimationClips[animationState.animationName] = animationState;
            this._animList.push(animationState.animationName);
            if (!this._blendSkeleton) {
                this._blendSkeleton = animationState.poseArray[0].clone();
            }
            return animationState;
        };
        /**
        * @language zh_CN
        * 更新
        * @param time 总时间
        * @param delay 延迟时间
        */
        SkeletonAnimation.prototype.updata = function (time, delay) {
            if (this._enabledSkeletonAnimationClips.length <= 0)
                return;
            var currentFrameIndex = 0;
            var currentSkeleton = null;
            var animationState = null;
            var currentSkeleton1 = null;
            var animationState1 = null;
            this._blendSkeleton.reset();
            var blendSpeed = delay / 300 * 1;
            for (var i = 0; i < this._enabledSkeletonAnimationClips.length; i++) {
                animationState = this._enabledSkeletonAnimationClips[i];
                if (i != this._enabledSkeletonAnimationClips.length - 1) {
                    animationState.weight = Math.max(0, animationState.weight - blendSpeed);
                    if (animationState.weight <= 0) {
                        this._enabledSkeletonAnimationClips.splice(i, 1);
                        i--;
                        continue;
                    }
                }
                else {
                    animationState.weight = Math.min(1, animationState.weight + blendSpeed);
                }
                animationState.addTime(delay * this._playSpeed * 5);
            }
            if (this._enabledSkeletonAnimationClips.length > 1) {
                animationState = this._enabledSkeletonAnimationClips[0];
                currentSkeleton = animationState.poseArray[animationState.currentFrameIndex];
                if (!currentSkeleton.skeletonMatrixValid) {
                    currentSkeleton.calculateJointWorldMatrix(this._animationSkeleton);
                }
                animationState1 = this._enabledSkeletonAnimationClips[1];
                currentSkeleton1 = animationState1.poseArray[animationState1.currentFrameIndex];
                if (!currentSkeleton1.skeletonMatrixValid) {
                    currentSkeleton1.calculateJointWorldMatrix(this._animationSkeleton);
                }
                for (var i = 0; i < this._blendSkeleton.numJoint; i++) {
                    this._blendSkeleton.joints[i].orientation.lerp(currentSkeleton.joints[i].orientation, currentSkeleton1.joints[i].orientation, animationState1.weight);
                    this._blendSkeleton.joints[i].scale.lerp(currentSkeleton.joints[i].scale, currentSkeleton1.joints[i].scale, animationState1.weight);
                    this._blendSkeleton.joints[i].translation.lerp(currentSkeleton.joints[i].translation, currentSkeleton1.joints[i].translation, animationState1.weight);
                    this._blendSkeleton.joints[i].setLocalTransform(this._blendSkeleton.joints[i].orientation, this._blendSkeleton.joints[i].scale, this._blendSkeleton.joints[i].translation);
                }
                this._blendSkeleton.calculateJointWorldMatrix(this._animationSkeleton);
                this._blendSkeleton.toMatrixData(this._skeletonMatrix);
            }
            else {
                animationState = this._enabledSkeletonAnimationClips[0];
                currentSkeleton = animationState.poseArray[animationState.currentFrameIndex];
                if (!currentSkeleton.skeletonMatrixValid) {
                    currentSkeleton.calculateJointWorldMatrix(this._animationSkeleton);
                }
                currentSkeleton.toMatrixData(this._skeletonMatrix);
            }
        };
        /**
        * @language zh_CN
        * 播放
        * @param animName 动画名称
        * @param speed 速度
        * @return 是否成功
        */
        SkeletonAnimation.prototype.play = function (animName, speed) {
            if (animName === void 0) { animName = null; }
            if (speed === void 0) { speed = 1.0; }
            if (!this._skeletonAnimationClips[animName])
                return false;
            this._enabledSkeletonAnimationClips.push(this._skeletonAnimationClips[animName]);
            this._enabledSkeletonAnimationClips[this._enabledSkeletonAnimationClips.length - 1].weight = this._enabledSkeletonAnimationClips.length > 1 ? 0 : 1;
            this._enabledSkeletonAnimationClips[this._enabledSkeletonAnimationClips.length - 1].play = true;
            this._enabledSkeletonAnimationClips[this._enabledSkeletonAnimationClips.length - 1].timePosition = 0;
            /*if (this._playing && this.currentAnim == animName)
                return true;

            if (this.currentAnim != animName) {

                if (!this._skeletonAnimationClips[animName])
                    return false;

                this.currentAnim = animName;

                this._enabledSkeletonAnimationClips = [];

                this._enabledSkeletonAnimationClips.push(this._skeletonAnimationClips[animName]);
            }

            this._enabledSkeletonAnimationClips[0].play = true;

            this._enabledSkeletonAnimationClips[0].timePosition = 0;*/
            this._currentFrame = 0;
            this._playSpeed = speed;
            this._playing = true;
            return true;
        };
        /**
        * @language zh_CN
        * 播放一次
        * @param animName 动画名称
        * @param speed 播放速度
        * @return 是否成功
        */
        SkeletonAnimation.prototype.playOnce = function (animName, speed) {
            ///if (this._playing && this.currentAnim == animName)
            ///    return true;
            if (animName === void 0) { animName = null; }
            if (speed === void 0) { speed = 1.0; }
            if (this.currentAnim != animName) {
                if (!this._skeletonAnimationClips[animName])
                    return false;
                this.currentAnim = animName;
                this._enabledSkeletonAnimationClips = [];
                this._enabledSkeletonAnimationClips.push(this._skeletonAnimationClips[animName]);
            }
            this._currentFrame = 0;
            this._enabledSkeletonAnimationClips[0].play = true;
            this._enabledSkeletonAnimationClips[0].timePosition = 0;
            this._enabledSkeletonAnimationClips[0].loop = false;
            this._playSpeed = speed;
            this._playing = true;
            return true;
        };
        Object.defineProperty(SkeletonAnimation.prototype, "currentFrame", {
            /**
            * @language zh_CN
            * 当前帧索引
            */
            get: function () {
                return this._currentFrame;
            },
            /**
            * @language zh_CN
            * 当前帧索引
            */
            set: function (value) {
                if (this._enabledSkeletonAnimationClips.length <= 0)
                    return;
                this._enabledSkeletonAnimationClips[0].timePosition = value * 160;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 获取总帧数
        * @param animName 动画名称
        * @return 动画总帧数
        */
        SkeletonAnimation.prototype.getTotalNumberOfFrame = function (animName) {
            if (animName === void 0) { animName = null; }
            animName = animName ? animName : this.currentAnim;
            var animation = this._skeletonAnimationClips[animName];
            if (!animation)
                return 0;
            return animation.poseArray.length;
        };
        /**
        * @language zh_CN
        * 停止动画播放
        */
        SkeletonAnimation.prototype.stop = function () {
            this._playing = false;
        };
        /**
        * @language zh_CN
        * 动画是否在播放
        * @return 是否在播放
        */
        SkeletonAnimation.prototype.isPlay = function () {
            if (false == this._enabledSkeletonAnimationClips[0].play) {
                return false;
            }
            return this._playing && this._enabledSkeletonAnimationClips.length > 0;
        };
        /**
        * @language zh_CN
        * 设置动画播放速度
        * @param speed 播放速度
        */
        SkeletonAnimation.prototype.setPlaySpeed = function (speed) {
            this._playSpeed = speed;
        };
        /**
        * @language zh_CN
        * 绑定3D对象到骨骼
        * @param jointName 骨骼名称
        * @param obj3d 3D对象
        * @return 是否成功
        */
        SkeletonAnimation.prototype.bindToJointPose = function (jointName, obj3d) {
            var jointIndex = this._animationSkeleton.findJointIndex(jointName);
            if (jointIndex < 0)
                return false;
            var list = null;
            if (this._bindList[jointIndex]) {
                list = this._bindList[jointIndex];
            }
            else {
                list = new Array();
                this._bindList[jointIndex] = list;
            }
            list.push(obj3d);
            return true;
        };
        SkeletonAnimation.prototype.updateBindList = function (skeletonPose) {
            var list = null;
            var jointPose = null;
            var obj3D = null;
            for (var jointIndex in this._bindList) {
                list = this._bindList[jointIndex];
                if (list.length <= 0)
                    continue;
                jointPose = skeletonPose.joints[jointIndex];
                if (!jointPose)
                    continue;
                for (var i = 0; i < list.length; i++) {
                    obj3D = list[i];
                    this._temp_quat.fromMatrix(jointPose.worldMatrix);
                    this._temp_quat.toEulerAngles(this._temp_vec3);
                    obj3D.rotationX = this._temp_vec3.x;
                    obj3D.rotationY = this._temp_vec3.y;
                    obj3D.rotationZ = this._temp_vec3.z;
                    ///obj3D.scaleX = jointPose.worldMatrix.scale.x;
                    ///obj3D.scaleY = jointPose.worldMatrix.scale.y;
                    ///obj3D.scaleZ = jointPose.worldMatrix.scale.z;
                    obj3D.x = jointPose.worldMatrix.position.x;
                    obj3D.y = jointPose.worldMatrix.position.y;
                    obj3D.z = jointPose.worldMatrix.position.z;
                }
            }
        };
        /**
        * @language zh_CN
        * 获取动画列表
        * @return 动画列表
        */
        SkeletonAnimation.prototype.getAnimList = function () {
            return this._animList;
        };
        /**
        * @language zh_CN
        * 获取动画节点
        */
        SkeletonAnimation.prototype.getAnimNode = function () {
            return null;
        };
        Object.defineProperty(SkeletonAnimation.prototype, "dirtyFrameNumber", {
            /**
            * @language zh_CN
            * 脏帧数
            * @return xxx
            */
            get: function () {
                return this._dirtyFrameNumber;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 获取SkeletonAnimationClip对象
        * @param name 动画名称
        * @return SkeletonAnimationClip对象
        */
        SkeletonAnimation.prototype.getAnimationState = function (name) {
            return this._skeletonAnimationClips[name];
        };
        /**
        * @language zh_CN
        * 移除动画
        * @param name 动画名称
        */
        SkeletonAnimation.prototype.removeAnimationState = function (name) {
            if (!this._skeletonAnimationClips[name]) {
                console.log("animation named: " + name + "not exists. SkeletonAnimationClip::removeAnimationState");
            }
            delete this._skeletonAnimationClips[name];
        };
        /**
        * @language zh_CN
        * 移除所有动画
        */
        SkeletonAnimation.prototype.removeAllAnimationStates = function () {
            this._skeletonAnimationClips = {};
            this._enabledSkeletonAnimationClips = [];
        };
        /**
        * @language zh_CN
        * 动画播放完一个周期的事件
        */
        SkeletonAnimation.EVENT_PLAY_COMPLETE = "event_play_complete";
        /**
        * @language zh_CN
        * 动画帧更改的事件
        */
        SkeletonAnimation.EVENT_FRAME_CHANGE = "event_frame_change";
        return SkeletonAnimation;
    })(egret3d.EventDispatcher);
    egret3d.SkeletonAnimation = SkeletonAnimation;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.VarConstName
        * @classdesc
        * shader 变量 名字定义
        * 用户在写自定义shader时，按照引擎中已经列取出来的变量名进行命名
        */
        var VarConstName = (function () {
            function VarConstName() {
            }
            VarConstName.attribute_position = "attribute_position";
            VarConstName.attribute_normal = "attribute_normal";
            VarConstName.attribute_tangent = "attribute_tangent";
            VarConstName.attribute_vertexColor = "attribute_vertexColor";
            VarConstName.attribute_uv0 = "attribute_uv0";
            VarConstName.attribute_uv1 = "attribute_uv1";
            VarConstName.varying_pos = "varying_pos";
            VarConstName.varying_normal = "varying_normal";
            VarConstName.varying_tangent = "varying_tangent";
            VarConstName.varying_color = "varying_color";
            VarConstName.varying_uv0 = "varying_uv0";
            VarConstName.varying_uv1 = "varying_uv1";
            VarConstName.varying_globalPos = "varying_globalPos";
            VarConstName.varying_lightDir = "varying_lightDir";
            VarConstName.varying_eye = "varying_eye";
            VarConstName.uniform_floatv_0 = "uniform_floatv_0";
            VarConstName.uniform_floatv_1 = "uniform_floatv_1";
            VarConstName.uniform_floatv_2 = "uniform_floatv_2";
            VarConstName.uniform_iv_0 = "uniform_iv_0";
            VarConstName.uniform_iv_1 = "uniform_iv_1";
            VarConstName.uniform_iv_2 = "uniform_iv_2";
            VarConstName.uniform_bv_0 = "uniform_bv_0";
            VarConstName.uniform_bv_1 = "uniform_bv_1";
            VarConstName.uniform_bv_2 = "uniform_bv_2";
            VarConstName.uniform_vec2fv_0 = "uniform_vec2fv_0";
            VarConstName.uniform_vec2fv_1 = "uniform_vec2fv_1";
            VarConstName.uniform_vec2fv_2 = "uniform_vec2fv_2";
            VarConstName.uniform_vec3fv_0 = "uniform_vec3fv_0";
            VarConstName.uniform_vec3fv_1 = "uniform_vec3fv_1";
            VarConstName.uniform_vec3fv_2 = "uniform_vec3fv_2";
            VarConstName.uniform_vec4fv_0 = "uniform_vec4fv_0";
            VarConstName.uniform_vec4fv_1 = "uniform_vec4fv_1";
            VarConstName.uniform_vec4fv_2 = "uniform_vec4fv_2";
            VarConstName.uniform_vec2iv_0 = "uniform_vec2iv_0";
            VarConstName.uniform_vec2iv_1 = "uniform_vec2iv_1";
            VarConstName.uniform_vec2iv_2 = "uniform_vec2iv_2";
            VarConstName.uniform_vec3iv_0 = "uniform_vec3iv_0";
            VarConstName.uniform_vec3iv_1 = "uniform_vec3iv_1";
            VarConstName.uniform_vec3iv_2 = "uniform_vec3iv_2";
            VarConstName.uniform_vec4iv_0 = "uniform_vec4iv_0";
            VarConstName.uniform_vec4iv_1 = "uniform_vec4iv_1";
            VarConstName.uniform_vec4iv_2 = "uniform_vec4iv_2";
            VarConstName.uniform_vec2bv_0 = "uniform_vec2bv_0";
            VarConstName.uniform_vec2bv_1 = "uniform_vec2bv_1";
            VarConstName.uniform_vec2bv_2 = "uniform_vec2bv_2";
            VarConstName.uniform_vec3bv_0 = "uniform_vec3bv_0";
            VarConstName.uniform_vec3bv_1 = "uniform_vec3bv_1";
            VarConstName.uniform_vec3bv_2 = "uniform_vec3bv_2";
            VarConstName.uniform_vec4bv_0 = "uniform_vec4bv_0";
            VarConstName.uniform_vec4bv_1 = "uniform_vec4bv_1";
            VarConstName.uniform_vec4bv_2 = "uniform_vec4bv_2";
            VarConstName.uniform_modelMatrix = "uniform_modelMatrix";
            VarConstName.uniform_projectionMatrix = "uniform_projectionMatrix";
            VarConstName.uniform_normalMatrix = "uniform_normalMatrix";
            VarConstName.uniform_eye = "uniform_eye";
            VarConstName.uniform_lightDir = "uniform_lightDir";
            VarConstName.texture2D_0 = "texture2D_0";
            VarConstName.texture2D_1 = "texture2D_1";
            VarConstName.texture2D_2 = "texture2D_2";
            VarConstName.texture2D_3 = "texture2D_3";
            VarConstName.texture2D_4 = "texture2D_4";
            return VarConstName;
        })();
        GLSL.VarConstName = VarConstName;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.AttributeType
        * @classdesc
        *
        * shader中的变量属性类型
        * @version Egret 3.0
        * @platform Web,Native
        */
        var AttributeType = (function () {
            function AttributeType() {
            }
            /**
            * shader int类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.int = "int";
            /**
            * shader float类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.float = "float";
            /**
            * shader vec2类型 两个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.vec2 = "vec2";
            /**
            * shader vec3类型 三个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.vec3 = "vec3";
            /**
            * shader vec4类型 四个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.vec4 = "vec4";
            /**
            * shader 2x2 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.mat2 = "mat2";
            /**
            * shader 3x3 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.mat3 = "mat3";
            /**
            * shader 4x4 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            AttributeType.mat4 = "mat4";
            return AttributeType;
        })();
        GLSL.AttributeType = AttributeType;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.UniformType
        * @classdesc
        * shader Uniform 变量的类型
        */
        var UniformType = (function () {
            function UniformType() {
            }
            /**
            * shader bool类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.bool = "bool";
            /**
            * shader int类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.int = "int";
            /**
            * shader float类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.float = "float";
            /**
            * shader vec2类型 两个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.vec2 = "vec2";
            /**
            * shader vec3类型 三个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.vec3 = "vec3";
            /**
            * shader vec4类型 四个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.vec4 = "vec4";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.bvec2 = "bvec2";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.bvec3 = "bvec3";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.bvec4 = "bvec4";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.ivec2 = "ivec2";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.ivec3 = "ivec3";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.ivec4 = "ivec4";
            /**
            * shader 2x2 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.mat2 = "mat2";
            /**
            * shader 3x3 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.mat3 = "mat3";
            /**
            * shader 4x4 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.mat4 = "mat4";
            /**
            * shader 贴图对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.sampler2D = "sampler2D";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            UniformType.sampleCube = "sampleCube";
            return UniformType;
        })();
        GLSL.UniformType = UniformType;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.VaryingType
        * @classdesc
        * shader中varying 变量 类型
        * @version Egret 3.0
        * @platform Web,Native
        */
        var VaryingType = (function () {
            function VaryingType() {
            }
            /**
            * shader bool类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.bool = "bool";
            /**
            * shader int类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.int = "int";
            /**
            * shader float类型
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.float = "float";
            /**
            * shader vec2类型 两个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.vec2 = "vec2";
            /**
            * shader vec3类型 三个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.vec3 = "vec3";
            /**
            * shader vec4类型 四个 float 组成
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.vec4 = "vec4";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.bvec2 = "bvec2";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.bvec3 = "bvec3";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.bvec4 = "bvec4";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.ivec2 = "ivec2";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.ivec3 = "ivec3";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.ivec4 = "ivec4";
            /**
            * shader 2x2 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.mat2 = "mat2";
            /**
            * shader 3x3 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.mat3 = "mat3";
            /**
            * shader 4x4 矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.mat4 = "mat4";
            /**
            * shader 贴图对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.sampler2D = "sampler2D";
            /**
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            VaryingType.sampleCube = "sampleCube";
            return VaryingType;
        })();
        GLSL.VaryingType = VaryingType;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.VarRegister
        * @classdesc
        * shader 变量 基类
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var VarRegister = (function () {
            function VarRegister() {
                /**
                * @language zh_CN
                * 变量类型
                */
                this.valueType = ""; /// float vec2 vec3 vec4 int int2 int3 int4
                /**
                * @language zh_CN
                * 变量值
                */
                this.value = ""; /// var value
                /**
                * @language zh_CN
                * active Texture Index
                */
                this.activeTextureIndex = -1;
                /**
                * @language zh_CN
                * index
                */
                this.index = -1;
            }
            /**
            * @language zh_CN
            * 得到组合后的字符串
            * @param compoments
            */
            VarRegister.prototype.var = function (compoments) {
                return this.level + " " + this.valueType + " " + name + "." + compoments;
            };
            /**
            * @language zh_CN
            *
            * @param compoments
            */
            VarRegister.prototype.use = function (compoments) {
                if (compoments === void 0) { compoments = ""; }
                if (compoments != "")
                    return this.name + "." + compoments;
                return this.name;
            };
            /**
            * @language zh_CN
            *
            * @returns VarRegister
            */
            VarRegister.prototype.clone = function () {
                var temp = new VarRegister();
                temp.name = this.name;
                temp.valueType = this.valueType;
                temp.level = this.level;
                temp.varName = this.varName;
                temp.value = this.value;
                return temp;
            };
            VarRegister.prototype.computeVarName = function () {
                var index = this.name.indexOf("[");
                if (index >= 0) {
                    this.varName = this.name.substr(0, index);
                }
                else {
                    this.varName = this.name;
                }
            };
            return VarRegister;
        })();
        GLSL.VarRegister = VarRegister;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.TmpVar
        * @classdesc
        *
        * shader中临时变量类型的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.core.shaderSystem.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var TmpVar = (function (_super) {
            __extends(TmpVar, _super);
            /**
            * @language zh_CN
            * 构造
            * @param name 变量名
            * @param valueType 变量类型
            */
            function TmpVar(name, valueType) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "";
                this.valueType = valueType;
            }
            return TmpVar;
        })(GLSL.VarRegister);
        GLSL.TmpVar = TmpVar;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.Attribute
        * @classdesc
        * 变量属性
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Attribute = (function (_super) {
            __extends(Attribute, _super);
            /**
            * @language zh_CN
            * constructor
            * @param name
            * @param valueType
            */
            function Attribute(name, valueType) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "attribute";
                this.valueType = valueType;
            }
            return Attribute;
        })(GLSL.VarRegister);
        GLSL.Attribute = Attribute;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.Varying
        * @classdesc
        *
        * shader中varying类型的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.core.shaderSystem.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Varying = (function (_super) {
            __extends(Varying, _super);
            /**
            * @language zh_CN
            * 构造函数
            * @param name 变量名
            * @param valueType 变量类型
            */
            function Varying(name, valueType) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "varying";
                this.valueType = valueType;
            }
            return Varying;
        })(GLSL.VarRegister);
        GLSL.Varying = Varying;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.Uniform
        * @classdesc
        *
        * shader中uniform类型的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.core.shaderSystem.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Uniform = (function (_super) {
            __extends(Uniform, _super);
            /**
            * @language zh_CN
            * 创建一个Uniform对象
            * @param name 变量名
            * @param valueType 变量类型
            */
            function Uniform(name, valueType) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "uniform";
                this.valueType = valueType;
            }
            return Uniform;
        })(GLSL.VarRegister);
        GLSL.Uniform = Uniform;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.ConstVar
        * @classdesc
        * shader中常量类型变量的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.core.shaderSystem.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var ConstVar = (function (_super) {
            __extends(ConstVar, _super);
            /**
            * @language zh_CN
            * 构造
            * @param name 常量名
            * @param valueType 常量类型
            * @param value 常量的值
            */
            function ConstVar(name, valueType, value) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "const";
                this.valueType = valueType;
                this.value = value;
            }
            return ConstVar;
        })(GLSL.VarRegister);
        GLSL.ConstVar = ConstVar;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.Sampler2D
        * @classdesc
        *
        * shader中sampler2D类型变量的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.core.shaderSystem.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Sampler2D = (function (_super) {
            __extends(Sampler2D, _super);
            /**
            * @language zh_CN
            * 构造
            * @param name 变量名
            */
            function Sampler2D(name) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "sampler2D";
                ///this.valueType = valueType;
            }
            return Sampler2D;
        })(GLSL.VarRegister);
        GLSL.Sampler2D = Sampler2D;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @private
        * @class egret3d.Sampler3D
        * @classdesc
        *
        * shader中samplerCube类型变量的所有数据
        * 包含变量类型，变量名，变量的值
        *
        * @see egret3d.core.shaderSystem.AttributeType
        *
        * @version Egret 3.0
        * @platform Web,Native
        */
        var Sampler3D = (function (_super) {
            __extends(Sampler3D, _super);
            /**
            * @language zh_CN
            * 构造
            * @param name 变量名
            */
            function Sampler3D(name) {
                _super.call(this);
                this.name = name;
                this.computeVarName();
                this.key = "samplerCube";
            }
            return Sampler3D;
        })(GLSL.VarRegister);
        GLSL.Sampler3D = Sampler3D;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @private
        * @class egret3d.ShaderBase
        * @classdesc
        * shader 基类
        */
        var ShaderBase = (function () {
            /**
            * @language zh_CN
            * constructor
            * @param materialData
            * @param usage
            */
            function ShaderBase(materialData, usage) {
                this.index = 0;
                this.source = "precision highp float;            \t\n";
                this.shadersName = new Array();
                this.endShadername = "";
                this.stateChange = false;
                /**
                * @language zh_CN
                *
                */
                this.maxBone = 0;
                this.useage = usage;
                this.materialData = materialData;
            }
            /**
            * @language zh_CN
            *
            * @param shaderName xxx
            */
            ShaderBase.prototype.addShader = function (shaderName) {
                this.shadersName.push(shaderName);
            };
            /**
            * @language zh_CN
            *
            * @param shaderName xxx
            */
            ShaderBase.prototype.addEnd = function (shaderName) {
                this.endShadername = shaderName;
            };
            /**
            * @language zh_CN
            *
            * @param context3D
            * @param program3D
            * @param modeltransform
            * @param camera3D
            */
            ShaderBase.prototype.activate = function (context3D, program3D, modeltransform, camera3D) {
            };
            /**
            * @language zh_CN
            *
            * @param context3D
            * @param program3D
            * @param modeltransform
            * @param camera3D
            */
            ShaderBase.prototype.updata = function (context3D, program3D, modeltransform, camera3D) {
            };
            /**
            * @language zh_CN
            *
            * @returns string
            */
            ShaderBase.prototype.getShaderSource = function () {
                if (this.endShadername != "") {
                    var index = this.shadersName.indexOf(this.endShadername);
                    if (index == -1) {
                        this.shadersName.push(this.endShadername);
                    }
                }
                var shaderContent = egret3d.ShaderSystemTool.instance.getShader(this.shadersName, this.useage);
                var i;
                ///var attribute
                for (var key in shaderContent.attributeList) {
                    this.connectAtt(shaderContent.attributeList[key]);
                }
                ///var struct
                for (var key in shaderContent.structDict) {
                    this.connectStruct(shaderContent.structDict[key]);
                }
                ///var varying
                for (i = 0; i < shaderContent.varyingList.length; i++) {
                    this.connectVarying(shaderContent.varyingList[i]);
                }
                ///temp
                for (i = 0; i < shaderContent.tempList.length; i++) {
                    this.connectTemp(shaderContent.tempList[i]);
                }
                ///const
                for (i = 0; i < shaderContent.constList.length; i++) {
                    if (shaderContent.constList[i].varName == "max_directLight") {
                        shaderContent.constList[i].value = this.materialData.directLightList.length.toString();
                    }
                    if (shaderContent.constList[i].varName == "bonesNumber") {
                        shaderContent.constList[i].value = this.maxBone; ///(<AnimationStateSet>this.geometey.animation).getJointNumber() * 2;
                    }
                    if (shaderContent.constList[i].varName == "max_sportLight") {
                        shaderContent.constList[i].value = this.materialData.sportLightList.length.toString();
                    }
                    if (shaderContent.constList[i].varName == "max_pointLight") {
                        shaderContent.constList[i].value = this.materialData.pointLightList.length.toString();
                    }
                    this.connectConst(shaderContent.constList[i]);
                }
                ///uniform
                for (i = 0; i < shaderContent.uniformList.length; i++) {
                    this.connectUniform(shaderContent.uniformList[i]);
                }
                ///sampler
                for (i = 0; i < shaderContent.sampler2DList.length; i++) {
                    var sampler2D = shaderContent.sampler2DList[i];
                    sampler2D = sampler2D.clone();
                    this.connectSampler(sampler2D);
                    sampler2D.activeTextureIndex = this.getTexture2DIndex(i);
                    sampler2D.index = i;
                    this.useage.sampler2DList.push(sampler2D);
                }
                ///sampler
                for (i = 0; i < shaderContent.sampler3DList.length; i++) {
                    var sampler3D = shaderContent.sampler3DList[i];
                    sampler3D = sampler3D.clone();
                    this.connectSampler3D(sampler3D);
                    sampler3D.activeTextureIndex = this.getTexture2DIndex(shaderContent.sampler2DList.length + i);
                    sampler3D.index = shaderContent.sampler2DList.length + i;
                    this.useage.sampler3DList.push(sampler3D);
                }
                ///---------------------------------------------------------------------------------
                ///---------------------------------------------------------------------------------
                for (i = 0; i < shaderContent.funcList.length; i++) {
                    this.source += shaderContent.funcList[i].func;
                }
                return this.source;
            };
            /**
            * @language zh_CN
            *
            * @param att
            */
            ShaderBase.prototype.connectAtt = function (att) {
                this.source += "attribute " + att.valueType + " " + att.name + "; \r\n";
            };
            /**
            * @language zh_CN
            *
            * @param tempVar
            */
            ShaderBase.prototype.connectTemp = function (tempVar) {
                this.source += tempVar.valueType + " " + tempVar.name + "; \r\n";
            };
            /**
            * @language zh_CN
            *
            * @param struct
            */
            ShaderBase.prototype.connectStruct = function (struct) {
                this.source += struct + " \r\n";
            };
            /**
            * @language zh_CN
            *
            * @param constVar
            */
            ShaderBase.prototype.connectConst = function (constVar) {
                this.source += "const " + constVar.valueType + " " + constVar.name + " = " + constVar.value + "; \r\n";
            };
            /**
            * @language zh_CN
            *
            * @param varying
            */
            ShaderBase.prototype.connectVarying = function (varying) {
                this.source += "varying " + varying.valueType + " " + varying.name + "; \r\n";
            };
            /**
            * @language zh_CN
            *
            * @param unifrom
            */
            ShaderBase.prototype.connectUniform = function (unifrom) {
                this.source += "uniform " + unifrom.valueType + " " + unifrom.name + "; \r\n";
            };
            /**
            * @language zh_CN
            *
            * @param sampler
            */
            ShaderBase.prototype.connectSampler = function (sampler) {
                this.source += "uniform sampler2D " + sampler.name + "; \r\n";
            };
            /**
            * @language zh_CN
            *
            * @param sampler
            */
            ShaderBase.prototype.connectSampler3D = function (sampler) {
                this.source += "uniform samplerCube " + sampler.name + "; \r\n";
            };
            ShaderBase.prototype.getTexture2DIndex = function (i) {
                switch (i) {
                    case 0:
                        return egret3d.ContextSamplerType.TEXTURE_0;
                        break;
                    case 1:
                        return egret3d.ContextSamplerType.TEXTURE_1;
                        break;
                    case 2:
                        return egret3d.ContextSamplerType.TEXTURE_2;
                        break;
                    case 3:
                        return egret3d.ContextSamplerType.TEXTURE_3;
                        break;
                    case 4:
                        return egret3d.ContextSamplerType.TEXTURE_4;
                        break;
                    case 5:
                        return egret3d.ContextSamplerType.TEXTURE_5;
                        break;
                    case 6:
                        return egret3d.ContextSamplerType.TEXTURE_6;
                        break;
                    case 7:
                        return egret3d.ContextSamplerType.TEXTURE_7;
                        break;
                    case 8:
                        return egret3d.ContextSamplerType.TEXTURE_8;
                        break;
                }
                throw new Error("texture not big then 8");
                return -1;
            };
            /**
            * @language zh_CN
            * dispose
            */
            ShaderBase.prototype.dispose = function () {
                this.materialData = null;
                this.useage = null;
                this.source = "";
                this.source = null;
                this.shadersName.length = 0;
                this.shadersName = null;
            };
            return ShaderBase;
        })();
        GLSL.ShaderBase = ShaderBase;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var GLSL;
    (function (GLSL) {
        /**
        * @private
        * @class egret3d.FuncData
        * @classdesc
        * shader函数内容的数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        var FuncData = (function () {
            function FuncData() {
                /**
                * @private
                * 函数名
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.name = "";
                /**
                * @private
                * 函数内容
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.func = "";
            }
            return FuncData;
        })();
        GLSL.FuncData = FuncData;
        /**
        * @private
        * @class egret3d.ShaderContent
        * @classdesc
        * shader文件解析后的数据内容
        * 每种变量类型都进行了规类
        * 用相应的列表进行存储，这样可以便于shader文件进行合并
        * @version Egret 3.0
        * @platform Web,Native
        */
        var ShaderContent = (function () {
            function ShaderContent() {
                /**
                * @private
                * shader文件名
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.name = "";
                this.funcDict = {};
                /**
                * @private
                * 结构体列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.structDict = {};
                /**
                * @private
                * attribute列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.attributeList = new Array();
                /**
                * @private
                * varying列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.varyingList = new Array();
                /**
                * @private
                * uniform列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.uniformList = new Array();
                /**
                * @private
                * const列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.constList = new Array();
                /**
                * @private
                * 临时变量列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.tempList = new Array();
                /**
                * @private
                * sampler2D列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.sampler2DList = new Array();
                /**
                * @private
                * sampler3D列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.sampler3DList = new Array();
                /**
                * @private
                * 函数列表
                * @version Egret 3.0
                * @platform Web,Native
                */
                this.funcList = new Array();
            }
            /**
            * @private
            * 增加一个变量对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            ShaderContent.prototype.addVar = function (sVar) {
                if (sVar.key == "attribute") {
                    this.attributeList.push(sVar);
                }
                else if (sVar.key == "varying") {
                    this.varyingList.push(sVar);
                }
                else if (sVar.key == "uniform") {
                    this.uniformList.push(sVar);
                }
                else if (sVar.key == "const") {
                    this.constList.push(sVar);
                }
                else if (sVar.key == "sampler2D") {
                    this.sampler2DList.push(sVar);
                }
                else if (sVar.key == "samplerCube") {
                    this.sampler3DList.push(sVar);
                }
                else {
                    this.tempList.push(sVar);
                }
            };
            /**
            * @private
            * 增加一个函数
            * @version Egret 3.0
            * @platform Web,Native
            */
            ShaderContent.prototype.addFunc = function (name, func) {
                if (this.funcDict[name] == undefined) {
                    this.funcDict[name] = func;
                    var funcData = new FuncData();
                    funcData.name = name;
                    funcData.func = func;
                    if (name == "main") {
                        this.funcList.push(funcData);
                    }
                    else {
                        this.funcList.unshift(funcData);
                    }
                }
                else {
                    if (name == "main") {
                        var newfunc = this.mergeMainFunc(this.funcDict[name], func);
                        this.funcDict[name] = newfunc;
                        var funcData = this.findFunc(name);
                        if (funcData) {
                            funcData.func = newfunc;
                        }
                    }
                    else {
                        console.log("<" + name + ">" + "函数重复");
                    }
                }
            };
            /**
            * @private
            * 增加一个结构体
            * @version Egret 3.0
            * @platform Web,Native
            */
            ShaderContent.prototype.addStruct = function (name, structStr) {
                if (this.structDict[name] == undefined) {
                    this.structDict[name] = structStr;
                }
                else {
                    console.log("<" + name + ">" + "struct重复");
                }
            };
            /**
            * @private
            * 合并一个shader内容
            * @version Egret 3.0
            * @platform Web,Native
            */
            ShaderContent.prototype.addContent = function (otherContent) {
                for (var key in otherContent.structDict) {
                    this.structDict[key] = otherContent.structDict[key];
                }
                for (var key in otherContent.funcDict) {
                    this.addFunc(key, otherContent.funcDict[key]);
                }
                for (var i = 0; i < otherContent.attributeList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.attributeList.length; ++j) {
                        if (otherContent.attributeList[i].name == this.attributeList[j].name) {
                            if (otherContent.attributeList[i].valueType != this.attributeList[j].valueType ||
                                otherContent.attributeList[i].key != this.attributeList[j].key) {
                                console.log("Error :addContent");
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.attributeList.push(otherContent.attributeList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.varyingList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.varyingList.length; ++j) {
                        if (otherContent.varyingList[i].name == this.varyingList[j].name) {
                            if (otherContent.varyingList[i].valueType != this.varyingList[j].valueType ||
                                otherContent.varyingList[i].key != this.varyingList[j].key) {
                                console.log("Error :addContent");
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.varyingList.push(otherContent.varyingList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.uniformList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.uniformList.length; ++j) {
                        if (otherContent.uniformList[i].name == this.uniformList[j].name) {
                            if (otherContent.uniformList[i].valueType != this.uniformList[j].valueType ||
                                otherContent.uniformList[i].key != this.uniformList[j].key) {
                                console.log("Error :addContent");
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.uniformList.push(otherContent.uniformList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.constList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.constList.length; ++j) {
                        if (otherContent.constList[i].name == this.constList[j].name) {
                            if (otherContent.constList[i].valueType != this.constList[j].valueType ||
                                otherContent.constList[i].key != this.constList[j].key) {
                                console.log("Error :addContent");
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.constList.push(otherContent.constList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.tempList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.tempList.length; ++j) {
                        if (otherContent.tempList[i].name == this.tempList[j].name) {
                            if (otherContent.tempList[i].valueType != this.tempList[j].valueType ||
                                otherContent.tempList[i].key != this.tempList[j].key) {
                                console.log("Error :addContent");
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.tempList.push(otherContent.tempList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.sampler2DList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.sampler2DList.length; ++j) {
                        if (otherContent.sampler2DList[i].name == this.sampler2DList[j].name) {
                            if (otherContent.sampler2DList[i].valueType != this.sampler2DList[j].valueType ||
                                otherContent.sampler2DList[i].key != this.sampler2DList[j].key) {
                                console.log("Error :addContent");
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.sampler2DList.push(otherContent.sampler2DList[i].clone());
                    }
                }
                for (var i = 0; i < otherContent.sampler3DList.length; ++i) {
                    var isAdd = true;
                    for (var j = 0; j < this.sampler3DList.length; ++j) {
                        if (otherContent.sampler3DList[i].name == this.sampler3DList[j].name) {
                            if (otherContent.sampler2DList[i].valueType != this.sampler3DList[j].valueType ||
                                otherContent.sampler3DList[i].key != this.sampler3DList[j].key) {
                                console.log("Error :addContent");
                            }
                            isAdd = false;
                            break;
                        }
                    }
                    if (isAdd) {
                        this.sampler3DList.push(otherContent.sampler3DList[i].clone());
                    }
                }
            };
            ShaderContent.prototype.mergeMainFunc = function (func1, func2) {
                var ret = func1;
                var func = "";
                var s_pos = func2.indexOf("{");
                var e_pos = func2.lastIndexOf("}");
                s_pos++;
                func = func2.slice(s_pos, e_pos);
                s_pos = ret.lastIndexOf("}");
                var f_func = ret.substr(0, s_pos);
                var s_func = ret.substr(s_pos, ret.length - s_pos);
                ret = f_func;
                ret += func;
                var temp = "";
                var line = "";
                var old = ret;
                ///while (true) {
                ///    s_pos = ret.indexOf("gl_FragColor");
                ///    if (s_pos >= 0) {
                ///        e_pos = ret.indexOf(";", s_pos);
                ///        temp = ret.substring(s_pos, e_pos + 1);
                ///        ret = ret.replace(temp, "");
                ///        line += temp;
                ///    }
                ///    s_pos = ret.indexOf("gl_Position");
                ///    if (s_pos >= 0) {
                ///        e_pos = ret.indexOf(";", s_pos);
                ///        temp = ret.substring(s_pos, e_pos + 1);
                ///        ret = ret.replace(temp, "");
                ///        line += temp;
                ///    }
                ///    if (old == ret) {
                ///        break;
                ///    }
                ///    old = ret;
                ///}
                ret += line;
                ret += s_func;
                return ret;
            };
            ShaderContent.prototype.findFunc = function (name) {
                var funcData = null;
                for (var i = 0; i < this.funcList.length; ++i) {
                    if (this.funcList[i].name == name) {
                        funcData = this.funcList[i];
                        break;
                    }
                }
                return funcData;
            };
            return ShaderContent;
        })();
        GLSL.ShaderContent = ShaderContent;
    })(GLSL = egret3d.GLSL || (egret3d.GLSL = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.FuncData
    * @classdesc
    * shader系统工具类，管理所有要用到的shader文件
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ShaderSystemTool = (function () {
        function ShaderSystemTool() {
            this.libs = [
                ///---ok------------------
                "default_vertex",
                "diffuseMap_fragment",
                "diffuse_fragmentEnd",
                "normalMap_fragment",
                "specularMap_fragment",
                "diffuseMethod_fragment",
                "Color_fragment",
                "directLight_fragment",
                "spotLight_fragment",
                "pointLight_fragment",
                "skeleton_vertex",
                "particle_vertex",
                "particle_vertexEnd",
                ///---ok------------------
                ///"LightDiffuse_fragment", 
                "Shadow_vertex_static",
                "Shadow_vertex_sksleton",
                "Shadow_fragment",
                "ShadowMapping_vertex",
                "shadowmapping_fragment",
                "depthMethod_fragment",
                "normalMethod_fragment",
                "postCanvas_vertex",
                "postCanvas_fragment",
                "sky_fragment",
                "sky_vertex",
                "spheresky_vertex",
                "spheresky_fragment",
                "terrainRGBA_fragment",
                "warpedImage_fragment",
                "lightMap_fragment",
                "EnvironmentMapping_fragment",
                "SpecularEnvironmentMappingMethod",
                "distanceFog_fragment",
                "AOMap_fragment",
                "wireframe_vertex",
                "wireframe_fragment",
                ///ok
                ///--particle--
                "particle_time",
                "particle_position",
                "particle_offset",
                "particle_speed",
                "particle_billboard",
                "particle_acceleration",
                "particle_lifeRotate",
                "particle_acceleRotate",
                "particle_scale",
                "particle_acceleScale",
                ///--particle--
                //post----
                "BrightPassFilter",
                "GaussianBlurHorizontal",
                "GaussianBlurVertical",
                "Composition",
                "Tonemaping",
            ];
            this._shaderLibs = {};
            this._methodLibs = {};
            this._loaderDict = {};
            this._loadList = new Array();
            this._shaderContentDict = {};
        }
        Object.defineProperty(ShaderSystemTool, "instance", {
            /**
            * @language zh_CN
            *
            * 单例
            */
            get: function () {
                if (!this._instance) {
                    this._instance = new ShaderSystemTool();
                }
                return this._instance;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 注册加载shader文件回调
        * @event func 加载完成响应
        */
        ShaderSystemTool.regist = function (func) {
            this.instance._loadFunc = func;
            this.instance.load("");
        };
        ShaderSystemTool.prototype.load = function (prefixUrl) {
            var _this = this;
            for (var i = 0; i < this.libs.length; i++) {
                this._loadList.push(this.libs[i]);
            }
            for (var i = 0; i < this.libs.length; i++) {
                var glslUrl = prefixUrl + "shader/" + this.libs[i] + ".glsl";
                this._loaderDict[glslUrl] = this.libs[i];
                var glslData = egret3d["glsldata"];
                if (glslData) {
                    this.setupShader(glslUrl, glslData[this.libs[i]]);
                }
                else {
                    var urlloader = new egret3d.URLLoader(glslUrl);
                    urlloader.onLoadComplete = function (loader) { return _this.onCompleteShader(loader); };
                }
            }
            if (glslData) {
                setTimeout(function () { return _this._loadFunc(_this); }, 0);
            }
        };
        ShaderSystemTool.prototype.onCompleteShader = function (loader) {
            this.setupShader(loader.url, loader.data);
        };
        ShaderSystemTool.prototype.setupShader = function (url, data) {
            var content = this.readShader(data);
            content.name = this._loaderDict[url];
            this._shaderLibs[content.name] = data;
            this._methodLibs[content.name] = content;
            this._shaderContentDict[content.name] = content;
            var index = -1;
            for (var i = 0; i < this._loadList.length; ++i) {
                if (this._loadList[i] == content.name) {
                    index = i;
                    break;
                }
            }
            if (index >= 0) {
                this._loadList.splice(index, 1);
            }
            if (this._loadList.length <= 0) {
                this._loadFunc(this);
            }
        };
        /**
        * @language zh_CN
        * 得到shader内容
        * @param name shader 名字
        * @returns shader内容
        */
        ShaderSystemTool.prototype.getShaderSource = function (name) {
            return this._shaderLibs[name] = this._shaderLibs[name] || "";
        };
        /**
        * @language zh_CN
        * 返回组合shader后的内容
        * @param shaderNameList 要组合的shader名字列表
        * @param usage
        * @returns shader 内容
        */
        ShaderSystemTool.prototype.getShader = function (shaderNameList, usage) {
            var i = 0;
            var varName = "";
            var shaderContent = null;
            for (i = 0; i < shaderNameList.length; ++i) {
                if (varName != "") {
                    varName += "/";
                }
                varName += shaderNameList[i];
            }
            if (this._shaderContentDict[varName] == undefined) {
                shaderContent = new egret3d.GLSL.ShaderContent();
                for (i = 0; i < shaderNameList.length; ++i) {
                    var tempContent = this._shaderContentDict[shaderNameList[i]];
                    shaderContent.addContent(tempContent);
                }
                this._shaderContentDict[varName] = shaderContent;
            }
            else {
                shaderContent = this._shaderContentDict[varName];
            }
            if (shaderContent == null) {
                return null;
            }
            for (i = 0; i < shaderContent.attributeList.length; i++) {
                varName = shaderContent.attributeList[i].varName;
                usage[varName] = shaderContent.attributeList[i].clone();
            }
            for (i = 0; i < shaderContent.varyingList.length; i++) {
                varName = shaderContent.varyingList[i].varName;
                if (!usage[varName]) {
                    usage[varName] = shaderContent.varyingList[i].clone();
                }
            }
            for (i = 0; i < shaderContent.tempList.length; i++) {
                varName = shaderContent.tempList[i].varName;
                usage[varName] = shaderContent.tempList[i].clone();
            }
            for (i = 0; i < shaderContent.uniformList.length; i++) {
                varName = shaderContent.uniformList[i].varName;
                usage[varName] = shaderContent.uniformList[i].clone();
            }
            for (i = 0; i < shaderContent.constList.length; i++) {
                varName = shaderContent.constList[i].varName;
                usage[varName] = shaderContent.constList[i].clone();
            }
            for (i = 0; i < shaderContent.sampler2DList.length; i++) {
                varName = shaderContent.sampler2DList[i].varName;
                usage[varName] = shaderContent.sampler2DList[i].clone();
            }
            for (i = 0; i < shaderContent.sampler3DList.length; i++) {
                varName = shaderContent.sampler3DList[i].varName;
                usage[varName] = shaderContent.sampler3DList[i].clone();
            }
            ///usage.sampler3DList.length = 0; 
            ///for (i = 0; i < shaderContent.sampler3DList.length; i++) {
            ///    var sampler3D: GLSL.Sampler3D = shaderContent.sampler3DList[i].clone();
            ///    sampler3D.activeTextureIndex = this.getTextureIndex(i);
            ///    sampler3D.index = i;
            ///    usage.sampler3DList.push(sampler3D);
            ///}
            return shaderContent;
        };
        ///************************************************************************
        ///-shader helper----------------------------------------------------------
        ///------------------------------------------------------------------------
        ShaderSystemTool.prototype.readShader = function (str) {
            var content = new egret3d.GLSL.ShaderContent();
            var shaderStr = egret3d.StringUtil.processShaderFile(str);
            var source = egret3d.StringUtil.parseContent(shaderStr);
            var shaderLine = source.concat();
            while (shaderLine.length > 0) {
                var line = shaderLine[0];
                shaderLine.shift();
                var ret = this.getLineType(line);
                var index = -1;
                index = ret.indexOf("struct");
                if (index != -1) {
                    var tempArray = ret.split(" ");
                    var structStr = line;
                    content.addStruct(tempArray[1], structStr);
                    this.processStruct(tempArray[1], structStr, content);
                    continue;
                }
                index = ret.indexOf("function");
                if (index != -1) {
                    var tempArray = ret.split(" ");
                    var func = line;
                    content.addFunc(tempArray[1], func);
                    continue;
                }
                index = ret.indexOf("unknown");
                if (index != -1) {
                    var tempArray = egret3d.StringUtil.parseLines(line);
                    var key = egret3d.StringUtil.getVarKey(tempArray);
                    var valueType = egret3d.StringUtil.getVarType(tempArray);
                    if (valueType == "sampler2D") {
                        var sampler2D = this.getSampler2D(line);
                        if (sampler2D)
                            content.addVar(sampler2D);
                    }
                    else if (valueType == "samplerCube") {
                        var sampler3D = this.getSampler3D(line);
                        if (sampler3D)
                            content.addVar(sampler3D);
                    }
                    else {
                        if (key == "attribute") {
                            var att = this.getAttribute(line);
                            if (att)
                                content.addVar(att);
                        }
                        else if (key == "varying") {
                            var varying = this.getVarying(line);
                            if (varying)
                                content.addVar(varying);
                        }
                        else if (key == "uniform") {
                            var uniform = this.getUniform(line);
                            if (uniform)
                                content.addVar(uniform);
                        }
                        else if (key == "const") {
                            var ConstVar = this.getConst(line);
                            if (ConstVar)
                                content.addVar(ConstVar);
                        }
                        else {
                            content.addVar(this.getTemper(line));
                        }
                    }
                    continue;
                }
            }
            return content;
        };
        ShaderSystemTool.prototype.getLineType = function (line) {
            var index = line.indexOf("{");
            if (index > 0) {
                var firstStr = line.substr(0, index);
                if (firstStr.indexOf("struct") >= 0) {
                    var s_pos = firstStr.lastIndexOf(" ");
                    s_pos++;
                    var structName = firstStr.substr(s_pos, firstStr.length - s_pos);
                    return ("struct " + structName);
                }
                if (firstStr.indexOf("=") < 0) {
                    var pos = line.indexOf("(");
                    var s_pos = line.lastIndexOf(" ", pos);
                    s_pos++;
                    var func = line.substr(s_pos, pos - s_pos);
                    return ("function " + func);
                }
            }
            return "unknown";
        };
        ShaderSystemTool.prototype.getAttribute = function (shaderLine) {
            var tempStr = shaderLine;
            var tmpName;
            var valueType;
            var attribute;
            var tempArray = egret3d.StringUtil.parseLines(tempStr);
            tmpName = egret3d.StringUtil.getVarName(tempArray);
            valueType = egret3d.StringUtil.getVarType(tempArray);
            attribute = new egret3d.GLSL.Attribute(tmpName, valueType);
            return attribute;
        };
        ShaderSystemTool.prototype.getTemper = function (shaderLine) {
            var tempStr = shaderLine;
            var tmpName;
            var valueType;
            var tmpVar;
            var tempArray = egret3d.StringUtil.parseLines(tempStr);
            tmpName = egret3d.StringUtil.getVarName(tempArray);
            valueType = egret3d.StringUtil.getVarType(tempArray);
            tmpVar = new egret3d.GLSL.TmpVar(tmpName, valueType);
            return tmpVar;
        };
        ShaderSystemTool.prototype.getVarying = function (shaderLine) {
            var tempStr = shaderLine;
            var varyingName;
            var valueType;
            var varying;
            var tempArray = egret3d.StringUtil.parseLines(tempStr);
            varyingName = egret3d.StringUtil.getVarName(tempArray);
            valueType = egret3d.StringUtil.getVarType(tempArray);
            varying = new egret3d.GLSL.Varying(varyingName, valueType);
            return varying;
        };
        ShaderSystemTool.prototype.getUniform = function (shaderLine) {
            var tempStr = shaderLine;
            var uniformName;
            var valueType;
            var uniform;
            var tempArray = egret3d.StringUtil.parseLines(tempStr);
            uniformName = egret3d.StringUtil.getVarName(tempArray);
            valueType = egret3d.StringUtil.getVarType(tempArray);
            uniform = new egret3d.GLSL.Uniform(uniformName, valueType);
            return uniform;
        };
        ShaderSystemTool.prototype.getConst = function (shaderLine) {
            var tempStr = shaderLine;
            var constVarName;
            var valueType;
            var varValue;
            var constVar;
            var tempArray = egret3d.StringUtil.parseLines(tempStr);
            constVarName = egret3d.StringUtil.getVarName(tempArray);
            valueType = egret3d.StringUtil.getVarType(tempArray);
            varValue = egret3d.StringUtil.getVarValue(tempArray);
            constVar = new egret3d.GLSL.ConstVar(constVarName, valueType, varValue);
            return constVar;
        };
        ShaderSystemTool.prototype.getSampler2D = function (shaderLine) {
            var tempStr = shaderLine;
            var sampler2DName;
            var valueType;
            var sampler2D;
            var tempArray = egret3d.StringUtil.parseLines(tempStr);
            sampler2DName = egret3d.StringUtil.getVarName(tempArray);
            sampler2D = new egret3d.GLSL.Sampler2D(sampler2DName);
            return sampler2D;
        };
        ShaderSystemTool.prototype.getSampler3D = function (shaderLine) {
            var tempStr = shaderLine;
            var sampler3DName;
            var valueType;
            var sampler3D;
            var tempArray = egret3d.StringUtil.parseLines(tempStr);
            sampler3DName = egret3d.StringUtil.getVarName(tempArray);
            sampler3D = new egret3d.GLSL.Sampler3D(sampler3DName);
            return sampler3D;
        };
        ShaderSystemTool.prototype.filterCharacter = function (name) {
            var src = name;
            var dest = src;
            for (var i = 0; i < ShaderSystemTool._filterChar.length; ++i) {
                while (true) {
                    dest = src.replace(ShaderSystemTool._filterChar[i], "");
                    if (src == dest) {
                        break;
                    }
                    src = dest;
                }
            }
            return dest;
        };
        ShaderSystemTool.prototype.processStruct = function (name, structStr, content) {
            var pos = structStr.lastIndexOf("}");
            pos++;
            var end = structStr.lastIndexOf(";");
            var varName = structStr.substr(pos, end - pos);
            var varList = egret3d.StringUtil.parseLines(varName);
            for (var i = 0; i < varList.length; ++i) {
                var varTmp = this.getTemper(name + " " + varList[i] + ";");
                if (varTmp)
                    content.addVar(varTmp);
            }
        };
        ShaderSystemTool._filterChar = [" ", "  ", ";", "\n", "\r", "\t", "\n", "\r", "\t"];
        return ShaderSystemTool;
    })();
    egret3d.ShaderSystemTool = ShaderSystemTool;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.MethodUsageData
    * @classdesc
    * 方法中需要用到的数据。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MethodUsageData = (function () {
        function MethodUsageData() {
            /**
             * @language zh_CN
             */
            this.passNeedReset = false;
            //public diffuseTex: GLSL.Sampler2D;
            //public normalTex: GLSL.Sampler2D;
            //public specularTex: GLSL.Sampler2D;
            //public texture2D_1: GLSL.Sampler2D;
            //public texture2D_4: GLSL.Sampler2D;
            //public texture2D_5: GLSL.Sampler2D;
            //public sky_texture: GLSL.Sampler2D;
            //public shadowMapTex: GLSL.Sampler2D;
            //public lightMapTex: GLSL.Sampler2D;
            //public maskTex: GLSL.Sampler2D;
            //public splat_0Tex: GLSL.Sampler2D;
            //public splat_1Tex: GLSL.Sampler2D;
            //public splat_2Tex: GLSL.Sampler2D;
            //public splat_3Tex: GLSL.Sampler2D;
            /**
             * @language zh_CN
             */
            this.sampler2DList = new Array();
            /**
             * @language zh_CN
             */
            this.sampler3DList = new Array();
            //----------------------------------------------
            /**
             * @language zh_CN
             */
            this.vsMethodList = new Array();
            /**
             * @language zh_CN
             */
            this.fsMethodList = new Array();
            /**
             * @language zh_CN
             */
            this.effectMethodList = new Array();
        }
        /**
         * @language zh_CN
         */
        MethodUsageData.prototype.dispose = function () {
        };
        return MethodUsageData;
    })();
    egret3d.MethodUsageData = MethodUsageData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.MaterialData
    * @classdesc
    * 材质数据。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MaterialData = (function () {
        function MaterialData() {
            /**
            * @language zh_CN
            * 材质类型。
            * @default MaterialType.DIFFUSE
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.matType = egret3d.MaterialType.DIFFUSE;
            /**
            * @language zh_CN
            * diffuse pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.diffusePassUsageData = new egret3d.MethodUsageData();
            /**
            * @language zh_CN
            * 深度 pass usage data。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.depthPassUsageData = new egret3d.MethodUsageData();
            /**
            * @language zh_CN
            * 法线 pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.normalPassUsageData = new egret3d.MethodUsageData();
            /**
            * @language zh_CN
            * position pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.positionPassUsageData = new egret3d.MethodUsageData();
            /**
            * @language zh_CN
            * post pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.postPassUsageData = new egret3d.MethodUsageData();
            /**
            * @language zh_CN
            * 灯光 pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lightPassUsageData = new egret3d.MethodUsageData();
            /**
            * @language zh_CN
            * 阴影 pass usage 数据。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.shadowPassUsageData = new egret3d.MethodUsageData();
            /**
            * @language zh_CN
            * 渲染模式。
            * @default DrawMode.TRIANGLES
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.drawMode = egret3d.DrawMode.TRIANGLES;
            /**
            * @language zh_CN
            * 法线贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.normalTex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * 特效贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.specularTex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * 灯光贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lightMapTex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * ao 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.aoMapTex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * 环境贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.environmentMapTex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * mask 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.maskTex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * splat_0 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.splat_0Tex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * splat_1 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.splat_1Tex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * splat_2 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.splat_2Tex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * splat_3 贴图。
            * @default CheckerboardTexture.texture
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.splat_3Tex = egret3d.CheckerboardTexture.texture;
            /**
            * @language zh_CN
            * 方向光列表。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.directLightList = new Array();
            /**
            * @language zh_CN
            * 聚光灯列表。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.sportLightList = new Array();
            /**
            * @language zh_CN
            * 点光源列表。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.pointLightList = new Array();
            /**
            * @language zh_CN
            * layer。
            * @default 0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.layer = 0;
            /**
            * @language zh_CN
            * 投射阴影 。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.castShadow = false;
            /**
            * @language zh_CN
            * 接受阴影。
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.acceptShadow = true;
            /**
            * @language zh_CN
            * 深度测试 。
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.depthTest = true;
            /**
            * @language zh_CN
            * 是否平滑 。
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.smooth = true;
            /**
            * @language zh_CN
            * 混合模式 。
            * @default BlendMode.NORMAL
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.blendMode = egret3d.BlendMode.NORMAL;
            /**
            * @language zh_CN
            * alphaBlending。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.alphaBlending = false;
            /**
            * @language zh_CN
            * ambientColor 值。
            * @default 0x0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.ambientColor = 0xffffff;
            //public ambientColor: number = 0x00235c;
            /**
            * @language zh_CN
            * diffuseColor 值。
            * @default 0xffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.diffuseColor = 0xffffff;
            /**
            * @language zh_CN
            * specularColor 值。
            * @default 0xffffff
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.specularColor = 0xffffff;
            /**
            * @language zh_CN
            * shininess 值。
            * @default 8.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.shininess = 8.0;
            /**
            * @language zh_CN
            * cutAlpha 值。
            * @default 0.7
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cutAlpha = 0.7;
            /**
            * @language zh_CN
            * 是否重复。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.repeat = false;
            /**
            * @language zh_CN
            * bothside 值。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.bothside = false;
            /**
            * @language zh_CN
            * alpha 值。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.alpha = 1.0;
            /**
            * @language zh_CN
            * specularPower 值。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.specularPower = 1.0;
            /**
            * @language zh_CN
            * ambientPower 值。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.ambientPower = 1.0;
            /**
            * @language zh_CN
            * diffusePower。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.diffusePower = 1.0;
            /**
            * @language zh_CN
            * normalPower 值。
            * @default 1.0
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.normalPower = 1.0;
            /**
            * @language zh_CN
            * 材质数据需要变化。
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.materialDataNeedChange = true;
            /**
            * @language zh_CN
            * 纹理变化。
            * @default false
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.textureChange = false;
            /**
            * @language zh_CN
            * passChange
            * @default true
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.passChange = true;
            /**
            * @language zh_CN
            * cullFrontOrBack。
            * @default Egret3DDrive.BACK
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cullFrontOrBack = egret3d.Egret3DDrive.BACK;
        }
        /**
        * @language zh_CN
        * 克隆方法。
        * @returns {MaterialData}
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialData.prototype.clone = function () {
            var data = new MaterialData();
            data.diffusePassUsageData = this.diffusePassUsageData;
            data.depthPassUsageData = this.depthPassUsageData;
            data.normalPassUsageData = this.normalPassUsageData;
            data.positionPassUsageData = this.positionPassUsageData;
            data.postPassUsageData = this.positionPassUsageData;
            data.lightPassUsageData = this.positionPassUsageData;
            data.shadowPassUsageData = this.positionPassUsageData;
            data.diffuseTex = egret3d.CheckerboardTexture.texture;
            data.textureChange = true;
            data.matType = egret3d.MaterialType.DIFFUSE;
            data.drawMode = this.drawMode;
            data.context3D = this.context3D;
            data.diffuseTex = this.diffuseTex;
            data.specularTex = this.specularTex;
            data.lightMapTex = this.lightMapTex;
            data.environmentMapTex = this.environmentMapTex;
            data.shadowMapTex = this.shadowMapTex;
            data.splat_0Tex = this.splat_0Tex;
            data.splat_1Tex = this.splat_1Tex;
            data.splat_2Tex = this.splat_2Tex;
            data.splat_3Tex = this.splat_3Tex;
            data.layer = this.layer;
            data.castShadow = this.castShadow;
            data.acceptShadow = this.acceptShadow;
            data.depthTest = this.depthTest;
            data.smooth = this.smooth;
            data.blendMode = this.blendMode;
            data.blend_src = this.blend_src;
            data.blend_dest = this.blend_dest;
            data.ambientColor = this.ambientColor;
            data.diffuseColor = this.diffuseColor;
            data.specularColor = this.specularColor;
            data.shininess = this.shininess;
            data.shininess = this.shininess;
            data.cutAlpha = this.cutAlpha;
            data.alpha = this.alpha;
            data.specularPower = this.specularPower;
            data.ambientPower = this.ambientPower;
            data.diffusePower = this.diffusePower;
            data.normalPower = this.normalPower;
            data.passChange = this.passChange;
            data.materialDataNeedChange = this.materialDataNeedChange;
            data.textureChange = true;
            data.cullFrontOrBack = this.cullFrontOrBack;
            //material state
            return data;
        };
        /**
        * @language zh_CN
        * 销毁。
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialData.prototype.dispose = function () {
            if (this.diffusePassUsageData)
                this.diffusePassUsageData.dispose();
            if (this.depthPassUsageData)
                this.depthPassUsageData.dispose();
            if (this.normalPassUsageData)
                this.normalPassUsageData.dispose();
            if (this.normalPassUsageData)
                this.normalPassUsageData.dispose();
            if (this.positionPassUsageData)
                this.positionPassUsageData.dispose();
            if (this.postPassUsageData)
                this.postPassUsageData.dispose();
            if (this.lightPassUsageData)
                this.lightPassUsageData.dispose();
            if (this.shadowPassUsageData)
                this.shadowPassUsageData.dispose();
            if (this.directLightList.length > 0) {
                this.directLightList.length = 0;
                this.directLightList = null;
            }
            if (this.sportLightList.length > 0) {
                this.sportLightList.length = 0;
                this.sportLightList = null;
            }
            if (this.pointLightList.length > 0) {
                this.pointLightList.length = 0;
                this.pointLightList = null;
            }
        };
        return MaterialData;
    })();
    egret3d.MaterialData = MaterialData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.MethodBase
    * @classdesc
    * ColorMethod，DepthMethod，DiffuseMethod，NormalMethod，ShadowMapingMethod，ShadowMapMethod，TerrainMethod ，ParticleVertexMethod，ShadowVertexMethod，SkinVertexMethod，StaticVertexMethod 方法的基类。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MethodBase = (function () {
        /**
        * @language zh_CN
        * 创建一个新的 MethodBase 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function MethodBase() {
            /**
             * @private
             */
            this.vsMethodName = "";
            /**
             * @private
             */
            this.fsMethodName = "";
            /**
             * @language zh_CN
             * 是否支持Shadow。
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.acceptShadow = false;
        }
        /**
         * @language zh_CN
         * 设置材质信息。
         * @param materialData {MaterialData}
         * @param usage {MethodUsageData}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MethodBase.prototype.setMaterialData = function (materialData, usage) {
            this.usage = usage;
            this.materialData = materialData;
        };
        Object.defineProperty(MethodBase.prototype, "vertexMethodName", {
            /**
            * @language zh_CN
            * 获取顶点方法名。
            * @returns {String}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.vsMethodName;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MethodBase.prototype, "fragMethodName", {
            /**
            * @language zh_CN
            * 获取frag方法名。
            * @returns {String}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.fsMethodName;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         * 激活。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
        * @version Egret 3.0
        * @platform Web,Native
         */
        MethodBase.prototype.activate = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
            //change constData
            this.context3D = context3D;
        };
        /**
         * @language zh_CN
         * 更新。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
        * @version Egret 3.0
        * @platform Web,Native
         */
        MethodBase.prototype.updata = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
        };
        /**
         * @language zh_CN
         * 销毁。
         * @version Egret 3.0
         * @platform Web,Native
         */
        MethodBase.prototype.dispose = function () {
        };
        return MethodBase;
    })();
    egret3d.MethodBase = MethodBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.VertexShader
    * @classdesc
    * 顶点着色器。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var VertexShader = (function (_super) {
        __extends(VertexShader, _super);
        /**
        * @language zh_CN
        * 创建一个新的 VertexShader 对象。
        * @param materialData {MaterialData}
        * @param usage {MethodUsageData}
        * @version Egret 3.0
        * @platform Web,Native
        */
        function VertexShader(materialData, usage) {
            _super.call(this, materialData, usage);
        }
        /**
        * @language zh_CN
        * 设置顶点着色器。
        * @param geometry {GeometryBase}
        * @version Egret 3.0
        * @platform Web,Native
        */
        VertexShader.prototype.setVertexShader = function (geometry) {
            var baseMethod;
            //根据 geomtry 类型 确定用什么 基本的 顶点着色器
            //拿到 顶点method list
            switch (geometry.geomtryType) {
                case egret3d.GeometryType.Static:
                    baseMethod = new egret3d.StaticVertexMethod();
                    this.useage.vsMethodList.push(baseMethod);
                    this.addShader(baseMethod.vertexMethodName);
                    break;
                case egret3d.GeometryType.Skin:
                    baseMethod = new egret3d.SkinVertexMethod();
                    this.useage.vsMethodList.push(baseMethod);
                    this.addShader(baseMethod.vertexMethodName);
                    baseMethod.acceptShadow = this.materialData.acceptShadow;
                    break;
                case egret3d.GeometryType.Particle:
                    baseMethod = new egret3d.ParticleVertexMethod();
                    this.useage.vsMethodList.push(baseMethod);
                    this.addShader(baseMethod.vertexMethodName);
                    this.addEnd("particle_vertexEnd");
                    break;
                default: break;
            }
            baseMethod.acceptShadow = this.materialData.acceptShadow;
            if (this.materialData.acceptShadow) {
                this.addShader("Shadow_vertex_static");
            }
        };
        /**
        * @language zh_CN
        * 返回 Shader 源。
        * @returns {String}
        * @version Egret 3.0
        * @platform Web,Native
        */
        VertexShader.prototype.getShaderSource = function () {
            var shaderSource = _super.prototype.getShaderSource.call(this);
            var index = shaderSource.lastIndexOf("}");
            var endS = shaderSource.substr(index, shaderSource.length - index);
            shaderSource = shaderSource.substr(0, index);
            shaderSource += "   gl_Position = temp_p; \r\n";
            shaderSource += endS;
            return shaderSource;
        };
        /**
        * @language zh_CN
        * 构建 VertexShader。
        * @version Egret 3.0
        * @platform Web,Native
        */
        VertexShader.prototype.build = function () {
            for (this.index = 0; this.index < this.useage.vsMethodList.length; this.index++) {
                this.useage.vsMethodList[this.index].setMaterialData(this.materialData, this.useage);
            }
        };
        /**
        * @language zh_CN
        * 添加 Method。
        * @version Egret 3.0
        * @platform Web,Native
        * @param method {MethodBase}
        */
        VertexShader.prototype.addMethod = function (method) {
            this.stateChange = true;
            this.useage.vsMethodList.push(method);
        };
        return VertexShader;
    })(egret3d.GLSL.ShaderBase);
    egret3d.VertexShader = VertexShader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.PixelShader
    * @classdesc
    * 像素着色器。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PixelShader = (function (_super) {
        __extends(PixelShader, _super);
        /**
        * @language zh_CN
        * 创建一个新的 PixelShader 对象。
        * @param materialData {MaterialData}
        * @param usage {MethodUsageData}
        * @version Egret 3.0
        * @platform Web,Native
        */
        function PixelShader(materialData, usage) {
            _super.call(this, materialData, usage);
            this.useage = usage;
            this.materialData = materialData;
        }
        /**
        * @language zh_CN
        * 添加 Method。
        * @param method {MethodBase}
        * @version Egret 3.0
        * @platform Web,Native
        */
        PixelShader.prototype.addMethod = function (method) {
            this.stateChange = true;
            this.useage.fsMethodList.push(method);
        };
        /**
        * @language zh_CN
        * 添加 EffectMethod。
        * @param method {EffectMethod}
        * @version Egret 3.0
        * @platform Web,Native
        */
        PixelShader.prototype.addEffectMethod = function (method) {
            this.stateChange = true;
            this.useage.effectMethodList.push(method);
        };
        /**
        * @language zh_CN
        * 返回 Shader 源。
        * @returns {String}
        * @version Egret 3.0
        * @platform Web,Native
        */
        PixelShader.prototype.getShaderSource = function () {
            var shaderSource = _super.prototype.getShaderSource.call(this);
            var index = shaderSource.lastIndexOf("}");
            var endS = shaderSource.substr(index, shaderSource.length - index);
            shaderSource = shaderSource.substr(0, index);
            shaderSource += "   gl_FragColor = diffuse;\r\n";
            shaderSource += endS;
            return shaderSource;
        };
        /**
        /**
        * @language zh_CN
        * 构建 PixelShader。
        * @version Egret 3.0
        * @platform Web,Native
        */
        PixelShader.prototype.build = function () {
            this.stateChange = false;
            for (this.index = 0; this.index < this.useage.fsMethodList.length; this.index++) {
                this.useage.fsMethodList[this.index].setMaterialData(this.materialData, this.useage);
            }
            this.stateChange = false;
            for (this.index = 0; this.index < this.useage.effectMethodList.length; this.index++) {
                this.useage.effectMethodList[this.index].setMaterialData(this.materialData, this.useage);
            }
        };
        return PixelShader;
    })(egret3d.GLSL.ShaderBase);
    egret3d.PixelShader = PixelShader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.StaticVertexMethod
    * @classdesc
    * 静态顶点方法。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var StaticVertexMethod = (function (_super) {
        __extends(StaticVertexMethod, _super);
        /**
        * @language zh_CN
        * 创建一个新的 StaticVertexMethod 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function StaticVertexMethod() {
            _super.call(this);
            this.normalMatrix = new egret3d.Matrix4_4();
            this.vsMethodName = "default_vertex";
        }
        /**
         * @language zh_CN
         * 激活 静态顶点方法。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * -pos     3 12 0
         * -normal  3 12 12
         * -tangent 3 12 24
         * -color   4 16 36
         * -uv0     2 8 52
         * -uv      1 8 60
         * @version Egret 3.0
         * @platform Web,Native
         */
        StaticVertexMethod.prototype.activate = function (context3D, program3D, modeltransform, camera3D, geometry) {
            // 绑定同时包含顶点位置和颜色信息的缓冲
            geometry.sharedVertexBuffer = context3D.creatVertexBuffer(geometry.verticesData);
            geometry.numberOfVertices = geometry.verticesData.length / geometry.vertexAttLength;
            geometry.vertexSizeInBytes = geometry.positionSize * Float32Array.BYTES_PER_ELEMENT +
                3 * Float32Array.BYTES_PER_ELEMENT +
                3 * Float32Array.BYTES_PER_ELEMENT +
                4 * Float32Array.BYTES_PER_ELEMENT +
                2 * Float32Array.BYTES_PER_ELEMENT +
                2 * Float32Array.BYTES_PER_ELEMENT; //uv2 60
            geometry.sharedIndexBuffer = context3D.creatIndexBuffer(geometry.indexData);
            context3D.bindVertexBuffer(geometry.sharedVertexBuffer);
            this.usage.attribute_position.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_position.name);
            this.usage.attribute_normal.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_normal.name);
            this.usage.attribute_tangent.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_tangent.name);
            this.usage.attribute_color.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_color.name);
            this.usage.attribute_uv0.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_uv0.name);
            this.usage.attribute_uv1.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_uv1.name);
            this.usage.uniform_ModelMatrix.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_ModelMatrix.name);
            this.usage.uniform_ProjectionMatrix.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_ProjectionMatrix.name);
            this.usage.uniform_normalMatrix.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_normalMatrix.name);
            this.usage.uniform_eyepos.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_eyepos.name);
            if (this.acceptShadow && this.usage.uniform_shadowMatrix)
                this.usage.uniform_shadowMatrix.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_shadowMatrix.name);
        };
        /**
         * @language zh_CN
         * 更新 静态顶点方法。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        StaticVertexMethod.prototype.updata = function (context3D, program3D, modeltransform, camera3D, geometry) {
            // 绑定同时包含顶点位置和颜色信息的缓冲
            context3D.bindVertexBuffer(geometry.sharedVertexBuffer);
            context3D.vertexAttribPointer(program3D, this.usage.attribute_position.uniformIndex, 3, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 0);
            context3D.vertexAttribPointer(program3D, this.usage.attribute_normal.uniformIndex, 3, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 12);
            context3D.vertexAttribPointer(program3D, this.usage.attribute_tangent.uniformIndex, 3, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 24);
            context3D.vertexAttribPointer(program3D, this.usage.attribute_color.uniformIndex, 4, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 36);
            context3D.vertexAttribPointer(program3D, this.usage.attribute_uv0.uniformIndex, 2, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 52);
            context3D.vertexAttribPointer(program3D, this.usage.attribute_uv1.uniformIndex, 2, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 60);
            this.normalMatrix.copyFrom(modeltransform);
            this.normalMatrix.invert();
            this.normalMatrix.transpose();
            //this.normalMatrix.appendScale(1,1,1);
            context3D.uniformMatrix4fv(this.usage.uniform_ModelMatrix.uniformIndex, false, modeltransform.rawData);
            context3D.uniformMatrix4fv(this.usage.uniform_ProjectionMatrix.uniformIndex, false, camera3D.viewProjectionMatrix.rawData);
            context3D.uniformMatrix4fv(this.usage.uniform_normalMatrix.uniformIndex, false, this.normalMatrix.rawData);
            context3D.uniform3f(this.usage.uniform_eyepos.uniformIndex, camera3D.x, camera3D.y, camera3D.z);
            if (this.acceptShadow && this.usage.uniform_shadowMatrix)
                context3D.uniformMatrix4fv(this.usage.uniform_shadowMatrix.uniformIndex, false, egret3d.ShadowRender.shadowCamera3D.viewProjectionMatrix.rawData);
        };
        return StaticVertexMethod;
    })(egret3d.MethodBase);
    egret3d.StaticVertexMethod = StaticVertexMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.ShadowVertexMethod
    * @classdesc
    * 阴影顶点方法。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ShadowVertexMethod = (function (_super) {
        __extends(ShadowVertexMethod, _super);
        /**
        * @language zh_CN
        * 创建一个新的 ShadowVertexMethod 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ShadowVertexMethod() {
            _super.call(this);
            this.vsMethodName = "Shadow_vertex_static";
        }
        /**
         * @language zh_CN
         * 激活 阴影顶点方法。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         *-pos     3 12 0
         *-normal  3 12 12
         *-tangent 3 12 24
         *-color   4 16 36
         *-uv0     2 8  52
         *-uv      1 8  60
         * @version Egret 3.0
         * @platform Web,Native
         */
        ShadowVertexMethod.prototype.activate = function (context3D, program3D, modeltransform, camera3D, geometry) {
            // 绑定同时包含顶点位置和颜色信息的缓冲
            geometry.sharedVertexBuffer = context3D.creatVertexBuffer(geometry.verticesData);
            geometry.numberOfVertices = geometry.verticesData.length / geometry.vertexAttLength;
            geometry.vertexSizeInBytes = geometry.positionSize * Float32Array.BYTES_PER_ELEMENT +
                3 * Float32Array.BYTES_PER_ELEMENT +
                3 * Float32Array.BYTES_PER_ELEMENT +
                4 * Float32Array.BYTES_PER_ELEMENT +
                2 * Float32Array.BYTES_PER_ELEMENT +
                2 * Float32Array.BYTES_PER_ELEMENT; //uv2 60
            geometry.sharedIndexBuffer = context3D.creatIndexBuffer(geometry.indexData);
            context3D.bindVertexBuffer(geometry.sharedVertexBuffer);
            this.usage.attribute_position.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_position.name);
            this.usage.uniform_ModelMatrix.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_ModelMatrix.name);
            this.usage.uniform_ProjectionMatrix.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_ProjectionMatrix.name);
        };
        /**
         * @language zh_CN
         * 更新 阴影顶点方法。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        ShadowVertexMethod.prototype.updata = function (context3D, program3D, modeltransform, camera3D, geometry) {
            // 绑定同时包含顶点位置和颜色信息的缓冲
            context3D.bindVertexBuffer(geometry.sharedVertexBuffer);
            context3D.vertexAttribPointer(program3D, this.usage.attribute_position.uniformIndex, 3, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 0);
            context3D.uniformMatrix4fv(this.usage.uniform_ModelMatrix.uniformIndex, false, modeltransform.rawData);
            context3D.uniformMatrix4fv(this.usage.uniform_ProjectionMatrix.uniformIndex, false, camera3D.viewProjectionMatrix.rawData);
        };
        return ShadowVertexMethod;
    })(egret3d.MethodBase);
    egret3d.ShadowVertexMethod = ShadowVertexMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.SkinVertexMethod
    * @classdesc
    * 蒙皮顶点方法。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var SkinVertexMethod = (function (_super) {
        __extends(SkinVertexMethod, _super);
        /**
        * @language zh_CN
        * 创建一个新的 SkinVertexMethod 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function SkinVertexMethod() {
            _super.call(this);
            this.normalMatrix = new egret3d.Matrix4_4();
            this.vsMethodName = "skeleton_vertex";
        }
        /**
         * @language zh_CN
         * 激活 蒙皮顶点方法。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * -pos        3 12 0
         * -normal     3 12 12
         * -tangent    3 12 24
         * -color      4 16 36
         * -uv0        2 8 52
         * -uv         1 8 60
         * -boneIndex  4 16 68
         * -boneWeight 4 16 84
         * @version Egret 3.0
         * @platform Web,Native
         */
        SkinVertexMethod.prototype.activate = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
            // 绑定同时包含顶点位置和颜色信息的缓冲
            geometry.sharedVertexBuffer = context3D.creatVertexBuffer(geometry.verticesData);
            geometry.numberOfVertices = geometry.verticesData.length / geometry.vertexAttLength;
            geometry.vertexSizeInBytes = geometry.positionSize * Float32Array.BYTES_PER_ELEMENT +
                3 * Float32Array.BYTES_PER_ELEMENT +
                3 * Float32Array.BYTES_PER_ELEMENT +
                4 * Float32Array.BYTES_PER_ELEMENT +
                2 * Float32Array.BYTES_PER_ELEMENT +
                2 * Float32Array.BYTES_PER_ELEMENT +
                4 * Float32Array.BYTES_PER_ELEMENT +
                4 * Float32Array.BYTES_PER_ELEMENT; //boneWeight 84
            geometry.sharedIndexBuffer = context3D.creatIndexBuffer(geometry.indexData);
            context3D.bindVertexBuffer(geometry.sharedVertexBuffer);
            this.usage.attribute_position.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_position.varName);
            this.usage.attribute_normal.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_normal.varName);
            this.usage.attribute_tangent.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_tangent.varName);
            this.usage.attribute_color.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_color.varName);
            this.usage.attribute_uv0.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_uv0.varName);
            this.usage.attribute_uv1.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_uv1.varName);
            this.usage.attribute_boneIndex.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_boneIndex.varName);
            this.usage.attribute_boneWeight.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_boneWeight.varName);
            this.usage.uniform_ModelMatrix.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_ModelMatrix.varName);
            this.usage.uniform_ProjectionMatrix.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_ProjectionMatrix.varName);
            this.usage.uniform_normalMatrix.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_normalMatrix.varName);
            this.usage.uniform_eyepos.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_eyepos.varName);
            this.usage.uniform_PoseMatrix.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_PoseMatrix.varName);
        };
        /**
         * @language zh_CN
         * 更新 蒙皮顶点方法。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        SkinVertexMethod.prototype.updata = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
            // 绑定同时包含顶点位置和颜色信息的缓冲
            context3D.bindVertexBuffer(geometry.sharedVertexBuffer);
            //if (!program3D.vertextAttribActive){
            //  context3D.vertexAttribPointer(program3D, this.usage.attribute_position.index, 3, egret3d.FLOAT, false, this.materialData.geomtryBase.vertexSizeInBytes, 0);
            //  context3D.vertexAttribPointer(program3D, this.usage.attribute_normal.index, 3, egret3d.FLOAT, false, this.materialData.geomtryBase.vertexSizeInBytes, 12);
            //  context3D.vertexAttribPointer(program3D, this.usage.attribute_tangent.index, 3, egret3d.FLOAT, false, this.materialData.geomtryBase.vertexSizeInBytes, 24);
            //  context3D.vertexAttribPointer(program3D, this.usage.attribute_uv0.index, 2, egret3d.FLOAT, false, this.materialData.geomtryBase.vertexSizeInBytes, 52);
            //  context3D.vertexAttribPointer(program3D, this.usage.attribute_boneIndex.index, 4, egret3d.FLOAT, false, this.materialData.geomtryBase.vertexSizeInBytes, 68);
            //  context3D.vertexAttribPointer(program3D, this.usage.attribute_boneWeight.index, 4, egret3d.FLOAT, false, this.materialData.geomtryBase.vertexSizeInBytes, 84);
            // }
            context3D.gl.vertexAttribPointer(this.usage.attribute_position.uniformIndex, 3, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 0);
            context3D.gl.enableVertexAttribArray(this.usage.attribute_position.uniformIndex);
            context3D.gl.vertexAttribPointer(this.usage.attribute_normal.uniformIndex, 3, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 12);
            context3D.gl.enableVertexAttribArray(this.usage.attribute_normal.uniformIndex);
            context3D.gl.vertexAttribPointer(this.usage.attribute_tangent.uniformIndex, 3, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 24);
            context3D.gl.enableVertexAttribArray(this.usage.attribute_tangent.uniformIndex);
            context3D.gl.vertexAttribPointer(this.usage.attribute_uv0.uniformIndex, 2, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 52);
            context3D.gl.enableVertexAttribArray(this.usage.attribute_uv0.uniformIndex);
            context3D.gl.vertexAttribPointer(this.usage.attribute_boneIndex.uniformIndex, 4, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 68);
            context3D.gl.enableVertexAttribArray(this.usage.attribute_boneIndex.uniformIndex);
            context3D.gl.vertexAttribPointer(this.usage.attribute_boneWeight.uniformIndex, 4, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 84);
            context3D.gl.enableVertexAttribArray(this.usage.attribute_boneWeight.uniformIndex);
            this.normalMatrix.copyFrom(modeltransform);
            this.normalMatrix.invert();
            this.normalMatrix.transpose();
            context3D.uniformMatrix4fv(this.usage.uniform_ModelMatrix.uniformIndex, false, modeltransform.rawData);
            context3D.uniformMatrix4fv(this.usage.uniform_ProjectionMatrix.uniformIndex, false, camera3D.viewProjectionMatrix.rawData);
            context3D.uniformMatrix4fv(this.usage.uniform_normalMatrix.uniformIndex, false, this.normalMatrix.rawData);
            context3D.uniform3f(this.usage.uniform_eyepos.uniformIndex, camera3D.x, camera3D.y, camera3D.z);
            context3D.uniform4fv(this.usage.uniform_PoseMatrix.uniformIndex, animation.currentSkeletonMatrixData);
        };
        return SkinVertexMethod;
    })(egret3d.MethodBase);
    egret3d.SkinVertexMethod = SkinVertexMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.ParticleVertexMethod
    * @classdesc
    * 粒子顶点方法。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ParticleVertexMethod = (function (_super) {
        __extends(ParticleVertexMethod, _super);
        /**
        * @language zh_CN
        * 创建一个新的 ParticleVertexMethod 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ParticleVertexMethod() {
            _super.call(this);
            this.index = 0;
            this.time = 0;
            this.normalMatrix = new egret3d.Matrix4_4();
            this.vsMethodName = "particle_vertex";
        }
        /**
         * @language zh_CN
         * 激活 粒子顶点方法。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * -pos            3       12      0
         * -uv0            2        8      12
         * -speed          3       12      20
         * -lifecycle      1       4       32
         * @version Egret 3.0
         * @platform Web,Native
         */
        ParticleVertexMethod.prototype.activate = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
            // 绑定同时包含顶点位置和颜色信息的缓冲
            geometry.sharedVertexBuffer = context3D.creatVertexBuffer(geometry.verticesData);
            geometry.numberOfVertices = animation.animaNodeCollection.numberOfVertices;
            geometry.vertexSizeInBytes = animation.animaNodeCollection.vertexSizeInBytes;
            geometry.sharedIndexBuffer = context3D.creatIndexBuffer(geometry.indexData);
            context3D.bindVertexBuffer(geometry.sharedVertexBuffer);
            //pos
            //offset
            //uv
            this.usage.attribute_position.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_position.name);
            this.usage.attribute_offset.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_offset.name);
            this.usage.attribute_uv0.uniformIndex = context3D.getShaderAttribLocation(program3D, this.usage.attribute_uv0.name);
            for (this.index = 0; this.index < animation.animaNodeCollection.nodes.length; this.index++) {
                if (animation.animaNodeCollection.nodes[this.index].usageAttributeLen > 0)
                    animation.animaNodeCollection.nodes[this.index].uniformIndex = context3D.getShaderAttribLocation(program3D, animation.animaNodeCollection.nodes[this.index].usageAttribute);
            }
            this.usage.uniform_ModelMatrix.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_ModelMatrix.name);
            this.usage.uniform_ProjectionMatrix.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_ProjectionMatrix.name);
            //this.usage.uniform_normalMatrix.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_normalMatrix.name);
            this.usage.uniform_eyepos.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_eyepos.name);
            this.usage.uniform_time.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_time.name);
            this.usage.uniform_cameraMatrix.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_cameraMatrix.name);
        };
        /**
         * @language zh_CN
         * 更新 粒子顶点方法。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        ParticleVertexMethod.prototype.updata = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
            // 绑定同时包含顶点位置和颜色信息的缓冲
            context3D.bindVertexBuffer(geometry.sharedVertexBuffer);
            context3D.vertexAttribPointer(program3D, this.usage.attribute_position.uniformIndex, 4, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 0);
            context3D.vertexAttribPointer(program3D, this.usage.attribute_offset.uniformIndex, 3, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 16);
            context3D.vertexAttribPointer(program3D, this.usage.attribute_uv0.uniformIndex, 2, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, 28);
            var node;
            for (this.index = 0; this.index < animation.animaNodeCollection.nodes.length; this.index++) {
                if (animation.animaNodeCollection.nodes[this.index].usageAttributeLen > 0) {
                    node = animation.animaNodeCollection.nodes[this.index];
                    context3D.vertexAttribPointer(program3D, node.uniformIndex, node.usageAttributeLen, egret3d.Egret3DDrive.FLOAT, false, geometry.vertexSizeInBytes, node.offsetBytes);
                }
            }
            context3D.uniformMatrix4fv(this.usage.uniform_ModelMatrix.uniformIndex, false, modeltransform.rawData);
            context3D.uniformMatrix4fv(this.usage.uniform_ProjectionMatrix.uniformIndex, false, camera3D.viewProjectionMatrix.rawData);
            context3D.uniformMatrix4fv(this.usage.uniform_cameraMatrix.uniformIndex, false, camera3D.modelMatrix.rawData);
            context3D.uniform3f(this.usage.uniform_eyepos.uniformIndex, camera3D.x, camera3D.y, camera3D.z);
            context3D.uniform1f(this.usage.uniform_time.uniformIndex, animation.time);
        };
        return ParticleVertexMethod;
    })(egret3d.MethodBase);
    egret3d.ParticleVertexMethod = ParticleVertexMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.ShadowMapMethod
    * @classdesc
    * 阴影采样。
    * 材质球接受阴影的着色片段，即使在模型中写入acceptShdow 也需要在材质球中加入这个阴影映射方法
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ShadowMapMethod = (function (_super) {
        __extends(ShadowMapMethod, _super);
        /**
        * @language zh_CN
        * 创建一个新的 ShadowMapMethod 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ShadowMapMethod() {
            _super.call(this);
            this.fsMethodName = "Shadow_fragment";
        }
        /**
         * @language zh_CN
         * 激活 阴影采样。
         * @private
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        ShadowMapMethod.prototype.activate = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
            _super.prototype.activate.call(this, context3D, program3D, modeltransform, camera3D, geometry, animation);
        };
        /**
         * @language zh_CN
         * 更新 阴影采样。
         * @private
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        ShadowMapMethod.prototype.updata = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
        };
        return ShadowMapMethod;
    })(egret3d.MethodBase);
    egret3d.ShadowMapMethod = ShadowMapMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.TerrainMethod
    * @classdesc
    * 地形图方法。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TerrainMethod = (function (_super) {
        __extends(TerrainMethod, _super);
        /**
        * @language zh_CN
        * 创建一个新的 TerrainMethod 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function TerrainMethod() {
            _super.call(this);
            this.uvData = new Float32Array(8);
            this.fsMethodName = "diffuseMethod_fragment";
            this.uvData[0] = 1.0;
            this.uvData[1] = 1.0;
            this.uvData[2] = 1.0;
            this.uvData[3] = 1.0;
            this.uvData[4] = 1.0;
            this.uvData[5] = 1.0;
            this.uvData[6] = 1.0;
            this.uvData[7] = 1.0;
        }
        /**
         * @language zh_CN
         * 设置UVTitling 图层索引
         * @param index
         * @param x
         * @param y
         */
        TerrainMethod.prototype.setUVTitling = function (index, x, y) {
            this.uvData[index * 2] = x;
            this.uvData[index * 2 + 1] = y;
        };
        /**
         * @language zh_CN
         * 激活 地形图方法。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        TerrainMethod.prototype.activate = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
            _super.prototype.activate.call(this, context3D, program3D, modeltransform, camera3D, geometry, animation);
            this.usage.uniform_materialSource.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_materialSource.varName);
            this.uvIndex = context3D.getUniformLocation(program3D, "uvs");
            if (this.materialData.directLightList.length > 0) {
                this.usage.uniform_directLightSource.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_directLightSource.varName);
            }
            if (this.materialData.sportLightList.length > 0) {
                this.usage.uniform_sportLightSource.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_sportLightSource.varName);
            }
            if (this.materialData.pointLightList.length > 0) {
                this.usage.uniform_pointLightSource.uniformIndex = context3D.getUniformLocation(program3D, this.usage.uniform_pointLightSource.varName);
            }
        };
        /**
         * @language zh_CN
         * 更新 地形图方法。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        TerrainMethod.prototype.updata = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
            if (this.materialData.materialDataNeedChange) {
                this.materialData.materialDataNeedChange = false;
                this.materialData.diffusePassUsageData.materialSourceData[0] = this.materialData.diffuseColor >> 24 & 0xff / 255;
                this.materialData.diffusePassUsageData.materialSourceData[1] = this.materialData.diffuseColor >> 16 & 0xff / 255;
                this.materialData.diffusePassUsageData.materialSourceData[2] = this.materialData.diffuseColor >> 8 & 0xff / 255;
                this.materialData.diffusePassUsageData.materialSourceData[3] = this.materialData.ambientColor >> 24 & 0xff / 255;
                this.materialData.diffusePassUsageData.materialSourceData[4] = this.materialData.ambientColor >> 16 & 0xff / 255;
                this.materialData.diffusePassUsageData.materialSourceData[5] = this.materialData.ambientColor >> 8 & 0xff / 255;
                this.materialData.diffusePassUsageData.materialSourceData[6] = this.materialData.specularColor >> 24 & 0xff / 255;
                this.materialData.diffusePassUsageData.materialSourceData[7] = this.materialData.specularColor >> 16 & 0xff / 255;
                this.materialData.diffusePassUsageData.materialSourceData[8] = this.materialData.specularColor >> 8 & 0xff / 255;
                this.materialData.diffusePassUsageData.materialSourceData[9] = this.materialData.alpha;
                this.materialData.diffusePassUsageData.materialSourceData[10] = this.materialData.cutAlpha;
                this.materialData.diffusePassUsageData.materialSourceData[11] = this.materialData.shininess;
            }
            context3D.gl.uniform1fv(this.usage.uniform_materialSource.uniformIndex, this.materialData.diffusePassUsageData.materialSourceData);
            context3D.gl.uniform1fv(this.uvIndex, this.uvData);
            if (this.materialData.directLightList.length > 0) {
                context3D.gl.uniform1fv(this.usage.uniform_directLightSource.uniformIndex, this.usage.directLightData);
            }
            if (this.materialData.sportLightList.length > 0) {
                context3D.gl.uniform1fv(this.usage.uniform_sportLightSource.uniformIndex, this.usage.sportLightData);
            }
            if (this.materialData.pointLightList.length > 0) {
                context3D.gl.uniform1fv(this.usage.uniform_pointLightSource.uniformIndex, this.usage.pointLightData);
            }
        };
        /**
         * @language zh_CN
         * 销毁 地形图方法。
         * @version Egret 3.0
         * @platform Web,Native
         */
        TerrainMethod.prototype.dispose = function () {
        };
        return TerrainMethod;
    })(egret3d.MethodBase);
    egret3d.TerrainMethod = TerrainMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @class egret3d.NormalMethod
    * @classdesc
    * 法线方法。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var NormalMethod = (function (_super) {
        __extends(NormalMethod, _super);
        /**
        * @language zh_CN
        * 创建一个新的 NormalMethod 对象。
        * @version Egret 3.0
        * @platform Web,Nativeo
        */
        function NormalMethod() {
            _super.call(this);
            this.fsMethodName = "normalMethod_fragment";
        }
        /**
         * @language zh_CNO
         * 激活 NormalMethod。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        NormalMethod.prototype.activate = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
            _super.prototype.activate.call(this, context3D, program3D, modeltransform, camera3D, geometry, animation);
        };
        /**
         * @language zh_CN
         * 更新 NormalMethod。
         * @version Egret 3.0
         * @platform Web,Native
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        NormalMethod.prototype.updata = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
        };
        /**
         * @language zh_CN
         * 销毁 NormalMethod。
         * @version Egret 3.0
         * @platform Web,Native
         */
        NormalMethod.prototype.dispose = function () {
        };
        return NormalMethod;
    })(egret3d.MethodBase);
    egret3d.NormalMethod = NormalMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.DepthMethod
    * @classdesc
    * 深度方法。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var DepthMethod = (function (_super) {
        __extends(DepthMethod, _super);
        /**
        * @language zh_CN
        * 创建一个新的 DepthMethod 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function DepthMethod() {
            _super.call(this);
            this.fsMethodName = "";
        }
        /**
         * @language zh_CN
         * 激活 DepthMethod。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        DepthMethod.prototype.activate = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
        };
        /**
         * @language zh_CN
         * 更新 DepthMethod。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        DepthMethod.prototype.updata = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
        };
        /**
         * @language zh_CN
         * 销毁 DepthMethod。
         * @version Egret 3.0
         * @platform Web,Native
         */
        DepthMethod.prototype.dispose = function () {
        };
        return DepthMethod;
    })(egret3d.MethodBase);
    egret3d.DepthMethod = DepthMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.DiffuseMethod
    * @classdesc
    * 漫反射方法。
    * 漫反射使用的着色片段方法，可以设置漫反射的贴图
    * @version Egret 3.0
    * @platform Web,Native
    */
    var DiffuseMethod = (function (_super) {
        __extends(DiffuseMethod, _super);
        /**
        * @language zh_CN
        * 创建一个新的 DiffuseMethod 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function DiffuseMethod() {
            _super.call(this);
            this.fsMethodName = "diffuseMethod_fragment";
        }
        /**
         * @language zh_CN
         * 激活 DiffuseMethod。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        DiffuseMethod.prototype.activate = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
            _super.prototype.activate.call(this, context3D, program3D, modeltransform, camera3D, geometry, animation);
        };
        /**
         * @language zh_CN
         * 更新 DiffuseMethod。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        DiffuseMethod.prototype.updata = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
        };
        /**
         * @language zh_CN
         * 销毁 DiffuseMethod。
         * @version Egret 3.0
         * @platform Web,Native
         */
        DiffuseMethod.prototype.dispose = function () {
        };
        return DiffuseMethod;
    })(egret3d.MethodBase);
    egret3d.DiffuseMethod = DiffuseMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.ShadowMapingMethod
    * @classdesc
    * 阴影映射。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ShadowMapingMethod = (function (_super) {
        __extends(ShadowMapingMethod, _super);
        /**
        * @language zh_CN
        * 创建一个新的 ShadowMapingMethod 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ShadowMapingMethod() {
            _super.call(this);
            /**
             * @language zh_CN
             * 偏移值。
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.bias = 0.002;
            /**
             * @language zh_CN
             * 阴影颜色红色通道值。
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.shdowColorR = 0.3;
            /**
             * @language zh_CN
             * 阴影颜色绿色通道值。
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.shdowColorG = 0.3;
            /**
             * @language zh_CN
             * 阴影颜色蓝色通道值。
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.shdowColorB = 0.5;
            this.vsMethodName = "ShadowMapping_vertex";
            this.fsMethodName = "shadowmapping_fragment";
        }
        /**
         * @language zh_CN
         * 设置材质信息。
         * @param materialData {MaterialData}
         * @param usage {MethodUsageData}
         * @version Egret 3.0
         * @platform Web,Native
         */
        ShadowMapingMethod.prototype.setMaterialData = function (materialData, usage) {
            this.usage = usage;
            this.materialData = materialData;
            this.materialData.shadowMapTex = egret3d.ShadowRender.frameBuffer.texture;
        };
        /**
         * @language zh_CN
         * 激活 阴影映射。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        ShadowMapingMethod.prototype.activate = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
            _super.prototype.activate.call(this, context3D, program3D, modeltransform, camera3D, geometry, animation);
            program3D["shadowParameterUniformIndex"] = context3D.getUniformLocation(program3D, "shadowParameter");
        };
        /**
         * @language zh_CN
         * 更新 阴影映射。
         * @param context3D {Context3D}
         * @param program3D {IProgram3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        ShadowMapingMethod.prototype.updata = function (context3D, program3D, modeltransform, camera3D, geometry, animation) {
            context3D.uniform4f(program3D["shadowParameterUniformIndex"], this.shdowColorR, this.shdowColorG, this.shdowColorB, this.bias);
        };
        return ShadowMapingMethod;
    })(egret3d.MethodBase);
    egret3d.ShadowMapingMethod = ShadowMapingMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.EffectMethod
    * @classdesc
    * AOMapMethod，DistanceFog，EnvironmentMappingMethod，LightMapMethod 的基类。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EffectMethod = (function () {
        /**
        * @language zh_CN
        * 创建一个新的 EffectMethod 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function EffectMethod() {
            this.vsMethodName = "";
            this.fsMethodName = "";
        }
        /**
         * @language zh_CN
         * 设置材质信息。
         * @param materialData {MaterialData}
         * @param usage {MethodUsageData}
         * @version Egret 3.0
         * @platform Web,Native
         */
        EffectMethod.prototype.setMaterialData = function (materialData, usage) {
            this.usage = usage;
            this.materialData = materialData;
        };
        Object.defineProperty(EffectMethod.prototype, "vertexMethodName", {
            /**
            * @language zh_CN
            * 返回顶点方法名。
            * @returns {String}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.vsMethodName;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EffectMethod.prototype, "fragMethodName", {
            /**
            * @language zh_CN
            * 返回frag方法名。
            * @returns {String}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.fsMethodName;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @language zh_CN
         * 激活特效。
         * @param context3D {Context3D}
         * @param usage {MethodUsageData}
         * @param materialData {MaterialData}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        EffectMethod.prototype.activateEffect = function (context3D, usage, materialData, modeltransform, camera3D, geometry, animation) {
            //change constData
            this.context3D = context3D;
        };
        /**
         * @private
         * @language zh_CN
         * 更新特效。
         * @param context3D {Context3D}
         * @param usage {MethodUsageData}
         * @param materialData {MaterialData}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        EffectMethod.prototype.updataEffect = function (context3D, usage, materialData, modeltransform, camera3D, geometry, animation) {
        };
        /**
         * @private
         * @language zh_CN
         * 销毁。
         * @version Egret 3.0
         * @platform Web,Native
         */
        EffectMethod.prototype.dispose = function () {
        };
        return EffectMethod;
    })();
    egret3d.EffectMethod = EffectMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.AOMapMethod
     * @classdesc
     * AO贴图方法。
     *
     * 可通过目前流行的 3d渲染软件 C4D 3Dmax Zbush 等都可以渲染环境吸收贴图，将对于不需要显示的光线屏蔽在外。
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var AOMapMethod = (function (_super) {
        __extends(AOMapMethod, _super);
        /**
         * @language zh_CN
         * 创建一个新的 AOMapMethod 对象。
         * @param texture {TextureBase}
         * @version Egret 3.0
         * @platform Web,Native
         */
        function AOMapMethod(texture) {
            _super.call(this);
            this.fsMethodName = "AOMap_fragment";
            this.aoTexture = texture;
        }
        /**
         * @language zh_CN
         * 设置MaterialData。
         * @private
         * @param materialData {MaterialData}
         * @param usage {MethodUsageData}
         * @version Egret 3.0
         * @platform Web,Native
         */
        AOMapMethod.prototype.setMaterialData = function (materialData, usage) {
            this.usage = usage;
            this.materialData = materialData;
            if (this.texture)
                this.materialData.aoMapTex = this.texture;
            else
                this.materialData.aoMapTex = egret3d.CheckerboardTexture.texture;
        };
        Object.defineProperty(AOMapMethod.prototype, "aoTexture", {
            /**
             * @language zh_CN
             * 设置ao Texture。
             * 这里设置 环境吸收贴图纹理 ， 可通过 load 加载
             * @param texture {TextureBase}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                this.texture = texture;
                if (texture) {
                    if (this.materialData) {
                        this.materialData.aoMapTex = texture;
                        this.materialData.textureChange = true;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @language zh_CN
         * 激活特效
         * @private
         * @param context3D {Context3D}
         * @param usage {MethodUsageData}
         * @param materialData {MaterialData}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        AOMapMethod.prototype.activateEffect = function (context3D, usage, materialData, modeltransform, camera3D, geometry, animation) {
            this.context3D = context3D;
        };
        /**
         * @private
         * @language zh_CN
         * 更新特效
         * @private
         * @param context3D {Context3D}
         * @param usage {MethodUsageData}
         * @param materialData {MaterialData}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        AOMapMethod.prototype.updataEffect = function (context3D, usage, materialData, modeltransform, camera3D, geometry, animation) {
        };
        /**
         * @private
         * @language zh_CN
         * 销毁
         * 进行相关的 贴图纹理资源回收
         * @version Egret 3.0
         * @platform Web,Native
         */
        AOMapMethod.prototype.dispose = function () {
        };
        return AOMapMethod;
    })(egret3d.EffectMethod);
    egret3d.AOMapMethod = AOMapMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.LightMapMethod
    * @classdesc
    * 光照贴图方法。
    * 可通过目前流行的 3d渲染软件 C4D 3Dmax Zbush 等都可以烘焙灯光贴图，再使用模型中的第二uvmaping 映射出来。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var LightMapMethod = (function (_super) {
        __extends(LightMapMethod, _super);
        /**
        * @language zh_CN
        * 创建一个新的 LightMapMethod 对象。
        * 创建一个新的 LightMapMethod 对象。
        * @param texture {TextureBase}
        * @version Egret 3.0
        * @platform Web,Native
        */
        function LightMapMethod(texture) {
            _super.call(this);
            this.fsMethodName = "lightMap_fragment";
            this.lightTexture = texture;
        }
        /**
         * @language zh_CN
         * 设置材质信息。
         * 设置材质信息。
         * @private
         * @param materialData {MaterialData}
         * @param usage {MethodUsageData}
         * @version Egret 3.0
         * @platform Web,Native
         */
        LightMapMethod.prototype.setMaterialData = function (materialData, usage) {
            this.usage = usage;
            this.materialData = materialData;
            if (this.texture)
                this.materialData.lightMapTex = this.texture;
            else
                this.materialData.lightMapTex = egret3d.CheckerboardTexture.texture;
        };
        Object.defineProperty(LightMapMethod.prototype, "lightTexture", {
            /**
             * @language zh_CN
             * 设置灯光贴图。
             * 设置烘焙后的灯光贴图。
             * @param texture {TextureBase}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                this.texture = texture;
                if (texture) {
                    if (this.materialData) {
                        this.materialData.lightMapTex = texture;
                        this.materialData.textureChange = true;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @language zh_CN
         * 激活特效
         * @param context3D {Context3D}
         * @param usage {MethodUsageData}
         * @param materialData {MaterialData}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        LightMapMethod.prototype.activateEffect = function (context3D, usage, materialData, modeltransform, camera3D, geometry, animation) {
            this.context3D = context3D;
            //usage["uniform_globalFog"] = context3D.getUniformLocation(usage.program3D, "uniform_globalFog");
        };
        /**
         * @private
         * @language zh_CN
         * 更新特效
         * @param context3D {Context3D}
         * @param usage {MethodUsageData}
         * @param materialData {MaterialData}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        LightMapMethod.prototype.updataEffect = function (context3D, usage, materialData, modeltransform, camera3D, geometry, animation) {
            // context3D.gl.uniform1fv(usage["uniform_globalFog"], this._data);
        };
        /**
         * @private
         * @language zh_CN
         * 销毁
         * 进行相关的 贴图纹理资源回收
         * @version Egret 3.0
         * @platform Web,Native
         */
        LightMapMethod.prototype.dispose = function () {
        };
        return LightMapMethod;
    })(egret3d.EffectMethod);
    egret3d.LightMapMethod = LightMapMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.EnvironmentMappingMethod
    * @classdesc
    * 环境贴图方法。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EnvironmentMappingMethod = (function (_super) {
        __extends(EnvironmentMappingMethod, _super);
        /**
        * @language zh_CN
        * 创建一个新的 EnvironmentMappingMethod 对象。
        * @param texture {TextureBase}
        * @version Egret 3.0
        * @platform Web,Native
        */
        function EnvironmentMappingMethod(texture) {
            _super.call(this);
            this.reflectValue = 1.0;
            this.fsMethodName = "EnvironmentMapping_fragment";
            this.lightTexture = texture;
        }
        Object.defineProperty(EnvironmentMappingMethod.prototype, "reflect", {
            /**
            * @language zh_CN
            * 获取反射值。
            * @returns {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.reflectValue;
            },
            /**
            * @language zh_CN
            * 设置反射值。
            * @param value{Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.reflectValue = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         * 设置材质信息。
         * @param materialData {MaterialData}
         * @param usage {MethodUsageData}
        * @version Egret 3.0
        * @platform Web,Native
         */
        EnvironmentMappingMethod.prototype.setMaterialData = function (materialData, usage) {
            this.usage = usage;
            this.materialData = materialData;
            if (this.texture)
                this.materialData.environmentMapTex = this.texture;
            else
                this.materialData.environmentMapTex = egret3d.CheckerboardTexture.texture;
        };
        Object.defineProperty(EnvironmentMappingMethod.prototype, "lightTexture", {
            /**
             * @language zh_CN
             * 设置灯光贴图。
             * @param texture {TextureBase}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                this.texture = texture;
                if (texture) {
                    if (this.materialData) {
                        this.materialData.environmentMapTex = texture;
                        this.materialData.textureChange = true;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @language zh_CN
         * 激活特效
         * @param context3D {Context3D}
         * @param usage {MethodUsageData}
         * @param materialData {MaterialData}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        EnvironmentMappingMethod.prototype.activateEffect = function (context3D, usage, materialData, modeltransform, camera3D, geometry, animation) {
            this.context3D = context3D;
            usage["reflectValue"] = context3D.getUniformLocation(usage.program3D, "reflectValue");
        };
        /**
         * @private
         * @language zh_CN
         * 更新特效
         * @param context3D {Context3D}
         * @param usage {MethodUsageData}
         * @param materialData {MaterialData}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        EnvironmentMappingMethod.prototype.updataEffect = function (context3D, usage, materialData, modeltransform, camera3D, geometry, animation) {
            context3D.gl.uniform1f(usage["reflectValue"], this.reflectValue);
        };
        /**
         * @private
         * @language zh_CN
         * 销毁
         * @version Egret 3.0
         * @platform Web,Native
         */
        EnvironmentMappingMethod.prototype.dispose = function () {
        };
        return EnvironmentMappingMethod;
    })(egret3d.EffectMethod);
    egret3d.EnvironmentMappingMethod = EnvironmentMappingMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.EnvironmentMappingMethod
    * @classdesc
    *
    * 环境贴图方法 通过材质球的 Specular 贴图纹理强度作为 反射强度值
    * @version Egret 3.0
    * @platform Web,Native
    */
    var SpecularEnvironmentMappingMethod = (function (_super) {
        __extends(SpecularEnvironmentMappingMethod, _super);
        /**
        * @language zh_CN
        * 创建一个新的 EnvironmentMappingMethod 对象。
        * @param texture {TextureBase}
        * @version Egret 3.0
        * @platform Web,Native
        */
        function SpecularEnvironmentMappingMethod(texture) {
            _super.call(this);
            this.reflectValue = 1.0;
            this.fsMethodName = "SpecularEnvironmentMappingMethod";
            this.lightTexture = texture;
        }
        Object.defineProperty(SpecularEnvironmentMappingMethod.prototype, "reflect", {
            /**
            * @language zh_CN
            * 获取反射值。
            * @private
            * @returns {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.reflectValue;
            },
            /**
            * @language zh_CN
            * 设置反射值。
            * @private
            * @param value{Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.reflectValue = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         * 设置材质信息。
        * @private
         * @param materialData {MaterialData}
         * @param usage {MethodUsageData}
        * @version Egret 3.0
        * @platform Web,Native
         */
        SpecularEnvironmentMappingMethod.prototype.setMaterialData = function (materialData, usage) {
            this.usage = usage;
            this.materialData = materialData;
            if (this.texture)
                this.materialData.environmentMapTex = this.texture;
            else
                this.materialData.environmentMapTex = egret3d.CheckerboardTexture.texture;
        };
        Object.defineProperty(SpecularEnvironmentMappingMethod.prototype, "lightTexture", {
            /**
             * @language zh_CN
             * 设置贴图。
             *  设置环境光照的贴图，必须为cube纹理贴图
             * @param texture {TextureBase}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                this.texture = texture;
                if (texture) {
                    if (this.materialData) {
                        this.materialData.environmentMapTex = texture;
                        this.materialData.textureChange = true;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @language zh_CN
         * 激活特效
         * @param context3D {Context3D}
         * @param usage {MethodUsageData}
         * @param materialData {MaterialData}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        SpecularEnvironmentMappingMethod.prototype.activateEffect = function (context3D, usage, materialData, modeltransform, camera3D, geometry, animation) {
            this.context3D = context3D;
        };
        /**
         * @private
         * @language zh_CN
         * 更新特效
         * @param context3D {Context3D}
         * @param usage {MethodUsageData}
         * @param materialData {MaterialData}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        SpecularEnvironmentMappingMethod.prototype.updataEffect = function (context3D, usage, materialData, modeltransform, camera3D, geometry, animation) {
        };
        /**
         * @private
         * @language zh_CN
         * 销毁
         * 进行相关的 贴图纹理资源回收
         * @version Egret 3.0
         * @platform Web,Native
         */
        SpecularEnvironmentMappingMethod.prototype.dispose = function () {
        };
        return SpecularEnvironmentMappingMethod;
    })(egret3d.EffectMethod);
    egret3d.SpecularEnvironmentMappingMethod = SpecularEnvironmentMappingMethod;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.DistanceFog
    * @classdesc
    * DistanceFog 类 表示远景雾。
    * 创建顶点着色的雾，可设置雾的形成远近范围，雾的浓度
    * 为场景添加景深效果
    * @version Egret 3.0
    * @platform Web,Native
    *
    */
    var DistanceFog = (function (_super) {
        __extends(DistanceFog, _super);
        /**
        * @language zh_CN
        * 创建一个新的 DistanceFog 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function DistanceFog() {
            _super.call(this);
            this._fogColor = 0xffffffff;
            this._globalDensity = 1;
            //private _startDistance: Point = new Point(200, 1000);
            //private _height: Point = new Point(200,3000) ;
            this._startDistance = 500;
            this._distanceScale = 0.1;
            this._height = 500;
            this._heightScale = 0.1;
            this.fsMethodName = "distanceFog_fragment";
            this._data = new Float32Array(8);
            this.fogColor = this._fogColor;
            this.globalDensity = this._globalDensity;
        }
        Object.defineProperty(DistanceFog.prototype, "fogColor", {
            /**
            * @language zh_CN
            * 获取雾颜色。
            * 返回16进制的雾颜色
            * @returns {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._fogColor;
            },
            /**
            * @language zh_CN
            * 设置雾颜色。
            * 设置16进制的雾颜色
            * @param value{Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._fogColor = value;
                this._data[0] = (value >> 16 & 0xff) / 255;
                this._data[1] = (value >> 8 & 0xff) / 255;
                this._data[2] = (value & 0xff) / 255;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DistanceFog.prototype, "globalDensity", {
            /**
            * @language zh_CN
            * 获取雾的全局密度。
            * 获取全局雾的密度，值的区间在 0~1之间
            * @returns {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._globalDensity;
            },
            /**
            * @language zh_CN
            * 设置雾的全局密度。
            * 设置全局雾的密度，值的区间在 0~1之间
            * @param value{Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._globalDensity = value;
                this._data[3] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DistanceFog.prototype, "startDistance", {
            /**
            * @language zh_CN
            * 获取雾的开始距离。
            * 获取全局雾的显示最近的距离
            * @returns {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._startDistance;
            },
            /**
            * @language zh_CN
            * 设置雾的开始距离。
            * 设置全局雾的显示最近的距离
            * @param value{Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._startDistance = value;
                this._data[4] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DistanceFog.prototype, "distanceScale", {
            /**
            * @language zh_CN
            * 获取雾的缩放距离。
            * 获取全局雾的显示浓雾缩放比例
            * @returns {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._distanceScale;
            },
            /**
            * @language zh_CN
            * 设置雾的缩放距离。
            * 设置全局雾的显示浓雾缩放比例
            * @param value{Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._distanceScale = value;
                this._data[5] = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @language zh_CN
         * 激活特效
         * @param context3D {Context3D}
         * @param usage {MethodUsageData}
         * @param materialData {MaterialData}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        DistanceFog.prototype.activateEffect = function (context3D, usage, materialData, modeltransform, camera3D, geometry, animation) {
            this.context3D = context3D;
            usage["uniform_globalFog"] = context3D.getUniformLocation(usage.program3D, "uniform_globalFog");
        };
        /**
         * @private
         * @language zh_CN
         * 更新特效
         * @param context3D {Context3D}
         * @param usage {MethodUsageData}
         * @param materialData {MaterialData}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        DistanceFog.prototype.updataEffect = function (context3D, usage, materialData, modeltransform, camera3D, geometry, animation) {
            context3D.gl.uniform1fv(usage["uniform_globalFog"], this._data);
        };
        /**
         * @private
         * @language zh_CN
         * 销毁
         * @version Egret 3.0
         * @platform Web,Native
         */
        DistanceFog.prototype.dispose = function () {
        };
        return DistanceFog;
    })(egret3d.EffectMethod);
    egret3d.DistanceFog = DistanceFog;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.MaterialPassBase
    * @classdesc
    * 材质通道渲染器。ColorMapPass，DepthMapPass，DiffuseMapPass，NormalMapPass，OutLinePass的基类。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MaterialPassBase = (function () {
        /**
        * @language zh_CN
        * 创建一个新的 MaterialPassBase 对象。
        * @param data {MaterialData} 材质数据
         * @version Egret 3.0
         * @platform Web,Native
        */
        function MaterialPassBase(data) {
            if (data === void 0) { data = null; }
            /**
             * @private
             * @language zh_CN
             */
            this.shaderChange = false;
            /**
             * @private
             * @language zh_CN
             */
            this.context3DChange = false;
            this.materialData = data;
        }
        /**
         * @language zh_CN
         * 添加方法。
         * @param method {MethodBase}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialPassBase.prototype.addMethod = function (method) {
            this.methodList = this.methodList || new Array();
            this.methodList.push(method);
            this.shaderChange = true;
        };
        /**
         * @language zh_CN
         * 移除方法。
         * @param method {MethodBase}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialPassBase.prototype.removeMethod = function (method) {
            var index = this.methodList.indexOf(method);
            this.methodList.splice(index, 1);
            method.dispose();
        };
        /**
         * @language zh_CN
         * 添加EffectMethod。
         * @param method {EffectMethod}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialPassBase.prototype.addEffectMethod = function (method) {
            this.effectMethodList = this.effectMethodList || new Array();
            this.effectMethodList.push(method);
            this.shaderChange = true;
        };
        /**
         * @language zh_CN
         * 移除 EffectMethod。
         * @param method {EffectMethod}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialPassBase.prototype.removeEffectMethod = function (method) {
            var index = this.effectMethodList.indexOf(method);
            this.effectMethodList.splice(index, 1);
            method.dispose();
        };
        ///**
        // * @language zh_CN
        // * 设置 cull 模式。
        // * @param value {Number}
        // * @version Egret 3.0
        // * @platform Web,Native
        // */
        //public set cullMode(value: number) {
        //    this.materialData.cullFrontOrBack = value;
        //}
        ///**
        // * @language zh_CN
        // * 返回 cull 模式。
        // * @returns {Number}
        // * @version Egret 3.0
        // * @platform Web,Native
        // */
        //public get cullMode( ): number {
        //    return this.materialData.cullFrontOrBack ;
        //}
        ///**
        // * @language zh_CN
        // * 设置 bothSides。
        // * @param flag {boolean}
        // * @version Egret 3.0
        // * @platform Web,Native
        // */
        //public set bothSides(flag: boolean) {
        //    this.materialData.cullFrontOrBack = -1; 
        //}
        ///**
        // * @language zh_CN
        // * 返回bothSides。
        // * @returns {boolean}
        // * @version Egret 3.0
        // * @platform Web,Native
        // */
        //public get bothSides( ): boolean {
        //    if (this.materialData.cullFrontOrBack == -1)
        //        return true
        //    return false ;
        //}
        ///**
        // * @language zh_CN
        // * 设置 lightGroup。
        // * @param lights {Array<LightBase>}
        // * @version Egret 3.0
        // * @platform Web,Native
        // */
        //public set lightGroup(lights: Array<LightBase> ) {
        //}
        /**
         * @language zh_CN
         * 初始化 shader 。
         * @param context3D {Context3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialPassBase.prototype.initShader = function (context3D, geomtry, animation) {
            this.animation = animation;
        };
        /**
         * @private
         * @language zh_CN
         * @returns {}
         */
        MaterialPassBase.prototype.resetTexture = function () {
        };
        MaterialPassBase.prototype.buildShader = function (context3D) {
        };
        /**
         * @language zh_CNa
         * 激活 材质通道渲染器。
         * @param context3D {Context3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialPassBase.prototype.activate = function (context3D, modeltransform, camera3D, geometry, animation) {
        };
        /**
         * @language zh_CNa
         * 绘制。
         * @param context3D {Context3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialPassBase.prototype.draw = function (context3D, modeltransform, camera3D, geometry, animation) {
            var i = 0;
            if (this.materialData.depthTest) {
                context3D.gl.enable(context3D.gl.DEPTH_TEST);
                context3D.gl.depthFunc(context3D.gl.LEQUAL);
            }
            else {
                context3D.gl.disable(context3D.gl.DEPTH_TEST);
                context3D.gl.depthFunc(context3D.gl.LEQUAL);
            }
            context3D.gl.cullFace(this.materialData.cullFrontOrBack);
            if (this.materialData.bothside) {
                context3D.gl.disable(context3D.gl.CULL_FACE);
            }
            else
                context3D.gl.enable(context3D.gl.CULL_FACE);
            context3D.gl.enable(context3D.gl.BLEND);
            context3D.setBlendFactors(this.materialData.blend_src, this.materialData.blend_dest);
            if (this.materialData.alphaBlending)
                context3D.gl.depthMask(false);
        };
        /**
         * @language zh_CNa
         * 设置为非活动。
         * @param context3D {Context3D}
         * @param camera3D {Camera3D}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialPassBase.prototype.unActive = function (context3D, camera3D) {
        };
        return MaterialPassBase;
    })();
    egret3d.MaterialPassBase = MaterialPassBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.DiffuseMapPass
    * @classdesc
    * 漫反射贴图通道渲染器，TerrainMapPass 的基类
    * @version Egret 3.0
    * @platform Web,Native
    */
    var DiffuseMapPass = (function (_super) {
        __extends(DiffuseMapPass, _super);
        /**
        * @language zh_CN
        * 创建一个新的 DiffuseMapPass 对象。
        * @param data {MaterialData} 材质数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        function DiffuseMapPass(data) {
            _super.call(this, data);
            /**
             * @language zh_CNa
             * 索引。
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.index = 0;
        }
        /**
         * @language zh_CN
         * 初始化 UseMethod。
         * @version Egret 3.0
         * @platform Web,Native
         */
        DiffuseMapPass.prototype.initUseMethod = function () {
            var i = 0;
            this.materialData.diffusePassUsageData.directLightData = new Float32Array(this.materialData.directLightList.length * egret3d.DirectLight.stride);
            this.materialData.diffusePassUsageData.sportLightData = new Float32Array(this.materialData.sportLightList.length * egret3d.SpotLight.stride);
            this.materialData.diffusePassUsageData.pointLightData = new Float32Array(this.materialData.pointLightList.length * egret3d.PointLight.stride);
            this.diffuseMethod = new egret3d.DiffuseMethod();
            this.pixelShader.addMethod(this.diffuseMethod);
            this.pixelShader.addShader(this.diffuseMethod.fragMethodName);
            if (this.materialData.matType == egret3d.MaterialType.DIFFUSE) {
                this.pixelShader.addShader("diffuseMap_fragment");
            }
            else if (this.materialData.matType == egret3d.MaterialType.DIFFUSE_BUMP) {
                this.pixelShader.addShader("diffuseMap_fragment");
                this.pixelShader.addShader("normalMap_fragment");
            }
            else if (this.materialData.matType == egret3d.MaterialType.DIFFUSE_BUMP_SPECULAR) {
                this.pixelShader.addShader("diffuseMap_fragment");
                this.pixelShader.addShader("normalMap_fragment");
                this.pixelShader.addShader("specularMap_fragment");
            }
            for (i = 0; i < this.materialData.directLightList.length; i++) {
                this.pixelShader.addShader("directLight_fragment");
            }
            for (i = 0; i < this.materialData.sportLightList.length; i++) {
                this.pixelShader.addShader("spotLight_fragment");
            }
            for (i = 0; i < this.materialData.pointLightList.length; i++) {
                this.pixelShader.addShader("pointLight_fragment");
            }
            if (this.animation) {
                if (this.animation.animaNodeCollection) {
                    var vsShaderNames = this.animation.animaNodeCollection.getNodesVertexShaders();
                    var fsShaderNames = this.animation.animaNodeCollection.getNodesFragmentShaders();
                    for (i = 0; i < vsShaderNames.length; i++) {
                        this.vertexShader.addShader(vsShaderNames[i]);
                    }
                    for (i = 0; i < fsShaderNames.length; i++) {
                        this.pixelShader.addShader(fsShaderNames[i]);
                    }
                }
            }
            if (this.materialData.acceptShadow && this.shadowMaping) {
                this.pixelShader.addMethod(this.shadowMaping);
                this.vertexShader.addShader(this.shadowMaping.vertexMethodName);
                this.pixelShader.addShader(this.shadowMaping.fragMethodName);
            }
            this.pixelShader.addShader("diffuse_fragmentEnd");
            if (this.effectMethodList) {
                for (var i = 0; i < this.effectMethodList.length; i++) {
                    this.pixelShader.addEffectMethod(this.effectMethodList[i]);
                    this.pixelShader.addShader(this.effectMethodList[i].fragMethodName);
                }
            }
        };
        /**
         * @language zh_CN
         * 初始化 shader 。
         * @param context3D {Context3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
        * @version Egret 3.0
        * @platform Web,Native
         */
        DiffuseMapPass.prototype.initShader = function (context3D, geometry, animation) {
            _super.prototype.initShader.call(this, context3D, geometry, animation);
            this.vertexShader = new egret3d.VertexShader(this.materialData, this.materialData.diffusePassUsageData);
            this.pixelShader = new egret3d.PixelShader(this.materialData, this.materialData.diffusePassUsageData);
            this.materialData.context3D = context3D;
            this.vertexShader.setVertexShader(geometry);
            this.initUseMethod();
            if (animation) {
                animation.initShader(this.vertexShader, this.pixelShader);
            }
            this.vertexShader.build();
            this.pixelShader.build();
            var vs = this.vertexShader.getShaderSource();
            var fs = this.pixelShader.getShaderSource();
            var vs_shader = context3D.creatVertexShader(vs);
            var fs_shader = context3D.creatFragmentShader(fs);
            this.materialData.diffusePassUsageData.program3D = context3D.creatProgram(vs_shader, fs_shader);
            this.context3DChange = true;
        };
        /**
         * @language zh_CN
         * 重置纹理。
         * @version Egret 3.0
         * @platform Web,Native
         */
        DiffuseMapPass.prototype.resetTexture = function () {
            //--------texture----------------
            var sampler2D;
            for (var index in this.materialData.diffusePassUsageData.sampler2DList) {
                sampler2D = this.materialData.diffusePassUsageData.sampler2DList[index];
                if (this.materialData[sampler2D.varName]) {
                    sampler2D.texture = this.materialData[sampler2D.varName];
                }
            }
            var sampler3D;
            for (var index in this.materialData.diffusePassUsageData.sampler3DList) {
                sampler3D = this.materialData.diffusePassUsageData.sampler3DList[index];
                if (this.materialData[sampler3D.varName]) {
                    sampler3D.texture = this.materialData[sampler3D.varName];
                }
            }
            this.materialData.textureChange = false;
        };
        /**
         * @language zh_CNa
         * 激活 漫反射贴图通道渲染器。
         * @param context3D {Context3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        DiffuseMapPass.prototype.activate = function (context3D, modeltransform, camera3D, geometry, animation) {
            this.materialData.diffusePassUsageData.uniform_materialSource.uniformIndex = context3D.getUniformLocation(this.materialData.diffusePassUsageData.program3D, this.materialData.diffusePassUsageData.uniform_materialSource.varName);
            if (this.materialData.directLightList.length > 0) {
                this.materialData.diffusePassUsageData.uniform_directLightSource.uniformIndex = context3D.getUniformLocation(this.materialData.diffusePassUsageData.program3D, this.materialData.diffusePassUsageData.uniform_directLightSource.varName);
            }
            if (this.materialData.sportLightList.length > 0) {
                this.materialData.diffusePassUsageData.uniform_sportLightSource.uniformIndex = context3D.getUniformLocation(this.materialData.diffusePassUsageData.program3D, this.materialData.diffusePassUsageData.uniform_sportLightSource.varName);
            }
            if (this.materialData.pointLightList.length > 0) {
                this.materialData.diffusePassUsageData.uniform_pointLightSource.uniformIndex = context3D.getUniformLocation(this.materialData.diffusePassUsageData.program3D, this.materialData.diffusePassUsageData.uniform_pointLightSource.varName);
            }
            for (this.index = 0; this.index < this.materialData.diffusePassUsageData.vsMethodList.length; this.index++) {
                this.materialData.diffusePassUsageData.vsMethodList[this.index].activate(context3D, this.materialData.diffusePassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            for (this.index = 0; this.index < this.materialData.diffusePassUsageData.fsMethodList.length; this.index++) {
                this.materialData.diffusePassUsageData.fsMethodList[this.index].activate(context3D, this.materialData.diffusePassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            for (this.index = 0; this.index < this.materialData.diffusePassUsageData.effectMethodList.length; this.index++) {
                this.materialData.diffusePassUsageData.effectMethodList[this.index].activateEffect(context3D, this.materialData.diffusePassUsageData, this.materialData, modeltransform, camera3D, geometry, animation);
            }
            this.resetTexture();
            //--------texture----------------
            var sampler2D;
            for (var index in this.materialData.diffusePassUsageData.sampler2DList) {
                sampler2D = this.materialData.diffusePassUsageData.sampler2DList[index];
                sampler2D.uniformIndex = context3D.getUniformLocation(this.materialData.diffusePassUsageData.program3D, sampler2D.varName);
            }
            //--------texture----------------
            var sampler3D;
            for (var index in this.materialData.diffusePassUsageData.sampler3DList) {
                sampler3D = this.materialData.diffusePassUsageData.sampler3DList[index];
                sampler3D.uniformIndex = context3D.getUniformLocation(this.materialData.diffusePassUsageData.program3D, sampler3D.varName);
            }
        };
        /**
         * @language zh_CNa
         * 绘制。
         * @param context3D {Context3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        DiffuseMapPass.prototype.draw = function (context3D, modeltransform, camera3D, geometry, animation) {
            context3D.gl.useProgram(this.materialData.diffusePassUsageData.program3D.program);
            _super.prototype.draw.call(this, context3D, modeltransform, camera3D, geometry, animation);
            var i = 0;
            if (this.materialData.materialDataNeedChange) {
                this.materialData.diffusePassUsageData.materialSourceData[0] = (this.materialData.diffuseColor >> 16 & 0xff) / 255.0;
                this.materialData.diffusePassUsageData.materialSourceData[1] = (this.materialData.diffuseColor >> 8 & 0xff) / 255.0;
                this.materialData.diffusePassUsageData.materialSourceData[2] = (this.materialData.diffuseColor & 0xff) / 255.0;
                this.materialData.diffusePassUsageData.materialSourceData[3] = (this.materialData.ambientColor >> 16 & 0xff) / 255.0;
                this.materialData.diffusePassUsageData.materialSourceData[4] = (this.materialData.ambientColor >> 8 & 0xff) / 255.0;
                this.materialData.diffusePassUsageData.materialSourceData[5] = (this.materialData.ambientColor & 0xff) / 255.0;
                this.materialData.diffusePassUsageData.materialSourceData[6] = (this.materialData.specularColor >> 16 & 0xff) / 255.0;
                this.materialData.diffusePassUsageData.materialSourceData[7] = (this.materialData.specularColor >> 8 & 0xff) / 255.0;
                this.materialData.diffusePassUsageData.materialSourceData[8] = (this.materialData.specularColor & 0xff) / 255.0;
                this.materialData.diffusePassUsageData.materialSourceData[9] = this.materialData.alpha;
                this.materialData.diffusePassUsageData.materialSourceData[10] = this.materialData.cutAlpha;
                this.materialData.diffusePassUsageData.materialSourceData[11] = this.materialData.shininess;
                this.materialData.diffusePassUsageData.materialSourceData[12] = this.materialData.diffusePower;
                this.materialData.diffusePassUsageData.materialSourceData[13] = this.materialData.specularPower;
                this.materialData.diffusePassUsageData.materialSourceData[14] = this.materialData.ambientPower;
                this.materialData.diffusePassUsageData.materialSourceData[15] = this.materialData.normalPower; //保留
            }
            context3D.gl.uniform1fv(this.materialData.diffusePassUsageData.uniform_materialSource.uniformIndex, this.materialData.diffusePassUsageData.materialSourceData);
            //texture 2D
            var sampler2D;
            for (var index in this.materialData.diffusePassUsageData.sampler2DList) {
                sampler2D = this.materialData.diffusePassUsageData.sampler2DList[index];
                sampler2D.texture.upload(context3D);
                context3D.setTexture2DAt(sampler2D.activeTextureIndex, sampler2D.uniformIndex, sampler2D.index, sampler2D.texture.texture);
                if (this.materialData.materialDataNeedChange) {
                    var min_filter = this.materialData.smooth ? context3D.gl.LINEAR_MIPMAP_LINEAR : context3D.gl.LINEAR;
                    var mag_filter = this.materialData.smooth ? context3D.gl.LINEAR : context3D.gl.LINEAR;
                    var wrap_u_filter = this.materialData.repeat ? context3D.gl.REPEAT : context3D.gl.CLAMP_TO_EDGE;
                    var wrap_v_filter = this.materialData.repeat ? context3D.gl.REPEAT : context3D.gl.CLAMP_TO_EDGE;
                    context3D.setTexture2DSamplerState(min_filter, mag_filter, wrap_u_filter, wrap_v_filter);
                    this.materialData.materialDataNeedChange = false;
                }
            }
            var sampler3D;
            for (var index in this.materialData.diffusePassUsageData.sampler3DList) {
                sampler3D = this.materialData.diffusePassUsageData.sampler3DList[index];
                sampler3D.texture.upload(context3D);
                context3D.setCubeTextureAt(sampler3D.activeTextureIndex, sampler3D.uniformIndex, sampler3D.index, sampler3D.texture.cubeTexture);
            }
            for (this.index = 0; this.index < this.materialData.diffusePassUsageData.vsMethodList.length; this.index++) {
                this.materialData.diffusePassUsageData.vsMethodList[this.index].updata(context3D, this.materialData.diffusePassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            if (this.materialData.diffusePassUsageData.uniform_directLightSource) {
                for (i = 0; i < this.materialData.directLightList.length; i++) {
                    this.materialData.directLightList[i].updateLightData(i, this.materialData.diffusePassUsageData.directLightData);
                }
                context3D.gl.uniform1fv(this.materialData.diffusePassUsageData.uniform_directLightSource.uniformIndex, this.materialData.diffusePassUsageData.directLightData);
            }
            if (this.materialData.diffusePassUsageData.uniform_sportLightSource) {
                for (i = 0; i < this.materialData.sportLightList.length; i++) {
                    this.materialData.sportLightList[i].updateLightData(i, this.materialData.diffusePassUsageData.sportLightData);
                }
                context3D.gl.uniform1fv(this.materialData.diffusePassUsageData.uniform_sportLightSource.uniformIndex, this.materialData.diffusePassUsageData.sportLightData);
            }
            if (this.materialData.diffusePassUsageData.uniform_pointLightSource) {
                for (i = 0; i < this.materialData.pointLightList.length; i++) {
                    this.materialData.pointLightList[i].updateLightData(i, this.materialData.diffusePassUsageData.pointLightData);
                }
                context3D.gl.uniform1fv(this.materialData.diffusePassUsageData.uniform_pointLightSource.uniformIndex, this.materialData.diffusePassUsageData.pointLightData);
            }
            if (this.context3DChange) {
                this.activate(context3D, modeltransform, camera3D, geometry, animation);
                this.context3DChange = false;
            }
            for (this.index = 0; this.index < this.materialData.diffusePassUsageData.vsMethodList.length; this.index++) {
                this.materialData.diffusePassUsageData.vsMethodList[this.index].updata(context3D, this.materialData.diffusePassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            for (this.index = 0; this.index < this.materialData.diffusePassUsageData.fsMethodList.length; this.index++) {
                this.materialData.diffusePassUsageData.fsMethodList[this.index].updata(context3D, this.materialData.diffusePassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            for (this.index = 0; this.index < this.materialData.diffusePassUsageData.effectMethodList.length; this.index++) {
                this.materialData.diffusePassUsageData.effectMethodList[this.index].updataEffect(context3D, this.materialData.diffusePassUsageData, this.materialData, modeltransform, camera3D, geometry, animation);
            }
            context3D.gl.bindBuffer(egret3d.Egret3DDrive.ELEMENT_ARRAY_BUFFER, geometry.sharedIndexBuffer.buffer);
            context3D.gl.drawElements(this.materialData.drawMode, geometry.numItems, egret3d.Egret3DDrive.UNSIGNED_SHORT, 0);
            if (this.materialData.alphaBlending)
                context3D.gl.depthMask(true);
            for (var index in this.materialData.diffusePassUsageData.sampler2DList) {
                //sampler2D = this.materialData.defaultPassUsageData.sampler2DList[index];
                //sampler2D.texture = this.materialData[sampler2D.varName]
                //sampler2D.texture.upload(context3D);
                //context3D.setTexture2DAt(sampler2D.activeTextureIndex, sampler2D.uniformIndex, sampler2D.index, sampler2D.texture.texture);
                //context3D.gl.bindTexture();
                context3D.gl.bindTexture(context3D.gl.TEXTURE_2D, null);
            }
        };
        return DiffuseMapPass;
    })(egret3d.MaterialPassBase);
    egret3d.DiffuseMapPass = DiffuseMapPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.TerrainMapPass
    * @classdesc
    * 地形贴图通道渲染器。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TerrainMapPass = (function (_super) {
        __extends(TerrainMapPass, _super);
        /**
        * @language zh_CN
        * 创建一个新的 TerrainMapPass 对象。
        * @param data {MaterialData} 材质数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        function TerrainMapPass(data) {
            _super.call(this, data);
            this.diffuseMethod = new egret3d.TerrainMethod();
        }
        /**
         * @language zh_CN
         * 初始化 UseMethod。
         * @version Egret 3.0
         * @platform Web,Native
         */
        TerrainMapPass.prototype.initUseMethod = function () {
            var i = 0;
            this.materialData.diffusePassUsageData.directLightData = new Float32Array(this.materialData.directLightList.length * egret3d.DirectLight.stride);
            this.materialData.diffusePassUsageData.sportLightData = new Float32Array(this.materialData.sportLightList.length * egret3d.SpotLight.stride);
            this.materialData.diffusePassUsageData.pointLightData = new Float32Array(this.materialData.pointLightList.length * egret3d.PointLight.stride);
            this.pixelShader.addMethod(this.diffuseMethod);
            this.pixelShader.addShader(this.diffuseMethod.fragMethodName);
            if (this.materialData.matType == egret3d.MaterialType.DIFFUSE) {
                this.pixelShader.addShader("diffuseMap_fragment");
            }
            else if (this.materialData.matType == egret3d.MaterialType.DIFFUSE_BUMP) {
                this.pixelShader.addShader("diffuseMap_fragment");
                this.pixelShader.addShader("normalMap_fragment");
            }
            else if (this.materialData.matType == egret3d.MaterialType.DIFFUSE_BUMP_SPECULAR) {
                this.pixelShader.addShader("diffuseMap_fragment");
                this.pixelShader.addShader("normalMap_fragment");
                this.pixelShader.addShader("specularMap_fragment");
            }
            this.pixelShader.addShader("terrainRGBA_fragment");
            for (i = 0; i < this.materialData.directLightList.length; i++) {
                this.pixelShader.addShader("directLight_fragment");
            }
            for (i = 0; i < this.materialData.sportLightList.length; i++) {
                this.pixelShader.addShader("spotLight_fragment");
            }
            for (i = 0; i < this.materialData.pointLightList.length; i++) {
                this.pixelShader.addShader("pointLight_fragment");
            }
            if (this.animation) {
                if (this.animation.animaNodeCollection) {
                    var vsShaderNames = this.animation.animaNodeCollection.getNodesVertexShaders();
                    var fsShaderNames = this.animation.animaNodeCollection.getNodesFragmentShaders();
                    for (i = 0; i < vsShaderNames.length; i++) {
                        this.vertexShader.addShader(vsShaderNames[i]);
                    }
                    for (i = 0; i < fsShaderNames.length; i++) {
                        this.pixelShader.addShader(fsShaderNames[i]);
                    }
                }
            }
            this.pixelShader.addShader("diffuse_fragmentEnd");
            if (this.effectMethodList) {
                for (var i = 0; i < this.effectMethodList.length; i++) {
                    this.pixelShader.addEffectMethod(this.effectMethodList[i]);
                    this.pixelShader.addShader(this.effectMethodList[i].fragMethodName);
                }
            }
            if (this.materialData.acceptShadow) {
                var shadowMapingMethod = new egret3d.ShadowMapingMethod();
                this.pixelShader.addMethod(shadowMapingMethod);
                this.vertexShader.addShader(shadowMapingMethod.vertexMethodName);
                this.pixelShader.addShader(shadowMapingMethod.fragMethodName);
            }
        };
        return TerrainMapPass;
    })(egret3d.DiffuseMapPass);
    egret3d.TerrainMapPass = TerrainMapPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.DepthMapPass
    * @classdesc
    * 深度贴图通道渲染器。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var DepthMapPass = (function (_super) {
        __extends(DepthMapPass, _super);
        /**
        * @language zh_CN
        * 创建一个新的 DepthMapPass 对象。
        * @param data {MaterialData} 材质数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        function DepthMapPass(data) {
            _super.call(this, data);
            /**
             * @language zh_CN
             * 索引。
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.index = 0;
        }
        /**
         * @language zh_CN
         * 初始化 UseMethod。
         * @version Egret 3.0
         * @platform Web,Native
         */
        DepthMapPass.prototype.initUseMethod = function () {
            this.pixelShader.addShader("depthMethod_fragment");
        };
        /**
         * @language zh_CN
         * 初始化 shader 。
         * @param context3D {Context3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        DepthMapPass.prototype.initShader = function (context3D, geometry, animation) {
            this.vertexShader = new egret3d.VertexShader(this.materialData, this.materialData.depthPassUsageData);
            this.pixelShader = new egret3d.PixelShader(this.materialData, this.materialData.depthPassUsageData);
            this.materialData.context3D = context3D;
            this.vertexShader.setVertexShader(geometry);
            this.initUseMethod();
            this.vertexShader.build();
            this.pixelShader.build();
            if (animation) {
                this.vertexShader.maxBone = animation.jointNumber * 2;
            }
            var vs = this.vertexShader.getShaderSource();
            var fs = this.pixelShader.getShaderSource();
            var vs_shader = context3D.creatVertexShader(vs);
            var fs_shader = context3D.creatFragmentShader(fs);
            this.materialData.depthPassUsageData.program3D = context3D.creatProgram(vs_shader, fs_shader);
            this.context3DChange = true;
        };
        /**
         * @language zh_CNa
         * 激活 深度贴图通道渲染器。
         * @param context3D {Context3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        DepthMapPass.prototype.activate = function (context3D, modeltransform, camera3D, geometry, animation) {
            for (this.index = 0; this.index < this.materialData.depthPassUsageData.vsMethodList.length; this.index++) {
                this.materialData.depthPassUsageData.vsMethodList[this.index].activate(context3D, this.materialData.depthPassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            for (this.index = 0; this.index < this.materialData.depthPassUsageData.fsMethodList.length; this.index++) {
                this.materialData.depthPassUsageData.fsMethodList[this.index].activate(context3D, this.materialData.depthPassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
        };
        /**
         * @language zh_CNa
         * 绘制。
         * @param context3D {Context3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        DepthMapPass.prototype.draw = function (context3D, modeltransform, camera3D, geometry, animation) {
            _super.prototype.draw.call(this, context3D, modeltransform, camera3D, geometry, animation);
            var i = 0;
            if (this.context3DChange) {
                this.activate(context3D, modeltransform, camera3D, geometry, animation);
                this.context3DChange = false;
            }
            for (this.index = 0; this.index < this.materialData.depthPassUsageData.vsMethodList.length; this.index++) {
                this.materialData.depthPassUsageData.vsMethodList[this.index].updata(context3D, this.materialData.depthPassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            for (this.index = 0; this.index < this.materialData.depthPassUsageData.fsMethodList.length; this.index++) {
                this.materialData.depthPassUsageData.fsMethodList[this.index].updata(context3D, this.materialData.depthPassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            context3D.gl.bindBuffer(egret3d.Egret3DDrive.ELEMENT_ARRAY_BUFFER, geometry.sharedIndexBuffer.buffer);
            context3D.gl.drawElements(this.materialData.drawMode, geometry.numItems, egret3d.Egret3DDrive.UNSIGNED_SHORT, 0);
        };
        return DepthMapPass;
    })(egret3d.MaterialPassBase);
    egret3d.DepthMapPass = DepthMapPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.NormalMapPass
    * @classdesc
    * 发现贴图通道渲染器。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var NormalMapPass = (function (_super) {
        __extends(NormalMapPass, _super);
        /**
        * @language zh_CN
        * 创建一个新的 NormalMapPass 对象。
        * @param data {MaterialData} 材质数据
         * @version Egret 3.0
         * @platform Web,Native
        */
        function NormalMapPass(data) {
            _super.call(this, data);
            /**
             * @language zh_CN
             * 索引。
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.index = 0;
        }
        /**
         * @language zh_CN
         * 初始化 UseMethod。
         * @version Egret 3.0
         * @platform Web,Native
         */
        NormalMapPass.prototype.initUseMethod = function () {
            var i = 0;
            this.normalMethod = new egret3d.NormalMethod();
            this.pixelShader.addMethod(this.normalMethod);
            this.pixelShader.addShader(this.normalMethod.fragMethodName);
            if (this.animation) {
                var vsShaderNames = this.animation.animaNodeCollection.getNodesVertexShaders();
                var fsShaderNames = this.animation.animaNodeCollection.getNodesFragmentShaders();
                for (i = 0; i < vsShaderNames.length; i++) {
                    this.vertexShader.addShader(vsShaderNames[i]);
                }
                for (i = 0; i < vsShaderNames.length; i++) {
                    this.pixelShader.addShader(fsShaderNames[i]);
                }
            }
            //if (this.materialData.useNormalMap) {
            //    this.pixelShader.addShader("normalMap_fragment");
            //}
        };
        /**
         * @language zh_CN
         * 初始化 shader 。
         * @param context3D {Context3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        NormalMapPass.prototype.initShader = function (context3D, geometry, animation) {
            this.vertexShader = new egret3d.VertexShader(this.materialData, this.materialData.normalPassUsageData);
            this.pixelShader = new egret3d.PixelShader(this.materialData, this.materialData.normalPassUsageData);
            this.materialData.context3D = context3D;
            this.vertexShader.setVertexShader(geometry);
            this.initUseMethod();
            this.vertexShader.build();
            this.pixelShader.build();
            if (animation) {
                this.vertexShader.maxBone = animation.jointNumber * 2;
            }
            var vs = this.vertexShader.getShaderSource();
            var fs = this.pixelShader.getShaderSource();
            var vs_shader = context3D.creatVertexShader(vs);
            var fs_shader = context3D.creatFragmentShader(fs);
            this.materialData.normalPassUsageData.program3D = context3D.creatProgram(vs_shader, fs_shader);
            this.context3DChange = true;
        };
        /**
         * @language zh_CNa
         * 激活 发现贴图通道渲染器。
         * @param context3D {Context3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        NormalMapPass.prototype.activate = function (context3D, modeltransform, camera3D, geometry, animation) {
            for (this.index = 0; this.index < this.materialData.normalPassUsageData.vsMethodList.length; this.index++) {
                this.materialData.normalPassUsageData.vsMethodList[this.index].activate(context3D, this.materialData.normalPassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            for (this.index = 0; this.index < this.materialData.normalPassUsageData.fsMethodList.length; this.index++) {
                this.materialData.normalPassUsageData.fsMethodList[this.index].activate(context3D, this.materialData.normalPassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
        };
        /**
         * @language zh_CNa
         * 绘制。
         * @param context3D {Context3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        NormalMapPass.prototype.draw = function (context3D, modeltransform, camera3D, geometry, animation) {
            context3D.setProgram(this.materialData.normalPassUsageData.program3D);
            _super.prototype.draw.call(this, context3D, modeltransform, camera3D, geometry, animation);
            var i = 0;
            if (this.context3DChange) {
                this.activate(context3D, modeltransform, camera3D, geometry, animation);
                this.context3DChange = false;
            }
            for (this.index = 0; this.index < this.materialData.normalPassUsageData.vsMethodList.length; this.index++) {
                this.materialData.normalPassUsageData.vsMethodList[this.index].updata(context3D, this.materialData.normalPassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            for (this.index = 0; this.index < this.materialData.normalPassUsageData.fsMethodList.length; this.index++) {
                this.materialData.normalPassUsageData.fsMethodList[this.index].updata(context3D, this.materialData.normalPassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            context3D.gl.bindBuffer(egret3d.Egret3DDrive.ELEMENT_ARRAY_BUFFER, geometry.sharedIndexBuffer.buffer);
            context3D.gl.drawElements(this.materialData.drawMode, geometry.numItems, egret3d.Egret3DDrive.UNSIGNED_SHORT, 0);
        };
        return NormalMapPass;
    })(egret3d.MaterialPassBase);
    egret3d.NormalMapPass = NormalMapPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.ColorMapPass
    * @classdesc
    * 颜色贴图通道渲染器。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ColorMapPass = (function (_super) {
        __extends(ColorMapPass, _super);
        /**
        * @language zh_CN
        * 创建一个新的 ColorMapPass 对象。
        * @version Egret 3.0
        * @platform Web,Native
        * @param data {MaterialData} 材质数据
        */
        function ColorMapPass(data) {
            _super.call(this, data);
            /**
             * @language zh_CN
             * 索引
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.index = 0;
        }
        /**
         * @language zh_CN
         * 初始化 UseMethod。
         * @version Egret 3.0
         * @platform Web,Native
         */
        ColorMapPass.prototype.initUseMethod = function () {
            this.materialData.diffusePassUsageData.directLightData = new Float32Array(this.materialData.directLightList.length * egret3d.DirectLight.stride);
            this.materialData.diffusePassUsageData.sportLightData = new Float32Array(this.materialData.sportLightList.length * egret3d.SpotLight.stride);
            this.materialData.diffusePassUsageData.pointLightData = new Float32Array(this.materialData.pointLightList.length * egret3d.PointLight.stride);
            this.diffuseMethod = new egret3d.DiffuseMethod();
            this.pixelShader.addMethod(this.diffuseMethod);
            this.pixelShader.addShader(this.diffuseMethod.fragMethodName);
        };
        /**
         * @language zh_CN
         * 初始化 shader 。
         * @param context3D {Context3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        ColorMapPass.prototype.initShader = function (context3D, geometry, animation) {
            this.vertexShader = new egret3d.VertexShader(this.materialData, this.materialData.diffusePassUsageData);
            this.pixelShader = new egret3d.PixelShader(this.materialData, this.materialData.diffusePassUsageData);
            this.materialData.context3D = context3D;
            this.vertexShader.setVertexShader(geometry);
            this.initUseMethod();
            this.vertexShader.build();
            this.pixelShader.build();
            if (animation) {
                this.vertexShader.maxBone = animation.jointNumber * 2;
            }
            var vs = this.vertexShader.getShaderSource();
            var fs = this.pixelShader.getShaderSource();
            var vs_shader = context3D.creatVertexShader(vs);
            var fs_shader = context3D.creatFragmentShader(fs);
            this.materialData.diffusePassUsageData.program3D = context3D.creatProgram(vs_shader, fs_shader);
            this.context3DChange = true;
        };
        /**
         * @language zh_CNa
         * 激活 ColorMapPass。
         * @param context3D {Context3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        ColorMapPass.prototype.activate = function (context3D, modeltransform, camera3D, geometry, animation) {
            for (this.index = 0; this.index < this.materialData.diffusePassUsageData.vsMethodList.length; this.index++) {
                this.materialData.diffusePassUsageData.vsMethodList[this.index].activate(context3D, this.materialData.diffusePassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            for (this.index = 0; this.index < this.materialData.diffusePassUsageData.fsMethodList.length; this.index++) {
                this.materialData.diffusePassUsageData.fsMethodList[this.index].activate(context3D, this.materialData.diffusePassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
        };
        /**
         * @language zh_CNa
         * 更新 ColorMapPass。
         * @param context3D {Context3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        ColorMapPass.prototype.updata = function (context3D, modeltransform, camera3D, geometry, animation) {
            _super.prototype.draw.call(this, context3D, modeltransform, camera3D, geometry, animation);
            var i;
            for (i = 0; i < this.materialData.directLightList.length; i++) {
                this.materialData.directLightList[i].updateLightData(i, this.materialData.diffusePassUsageData.directLightData);
            }
            for (i = 0; i < this.materialData.sportLightList.length; i++) {
                this.materialData.sportLightList[i].updateLightData(i, this.materialData.diffusePassUsageData.sportLightData);
            }
            for (i = 0; i < this.materialData.pointLightList.length; i++) {
                this.materialData.pointLightList[i].updateLightData(i, this.materialData.diffusePassUsageData.pointLightData);
            }
            if (this.context3DChange) {
                this.activate(context3D, modeltransform, camera3D, geometry, animation);
                this.context3DChange = false;
            }
            for (this.index = 0; this.index < this.materialData.diffusePassUsageData.vsMethodList.length; this.index++) {
                this.materialData.diffusePassUsageData.vsMethodList[this.index].updata(context3D, this.materialData.diffusePassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            for (this.index = 0; this.index < this.materialData.diffusePassUsageData.fsMethodList.length; this.index++) {
                this.materialData.diffusePassUsageData.fsMethodList[this.index].updata(context3D, this.materialData.diffusePassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            context3D.gl.bindBuffer(egret3d.Egret3DDrive.ELEMENT_ARRAY_BUFFER, geometry.sharedIndexBuffer.buffer);
            context3D.drawElement(this.materialData.drawMode, geometry.sharedIndexBuffer, 0, geometry.numItems);
        };
        return ColorMapPass;
    })(egret3d.MaterialPassBase);
    egret3d.ColorMapPass = ColorMapPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @private
    * @language zh_CN
    * @class egret3d.ShadowMapPass
    * @classdesc
    * 阴影贴图通道渲染器。
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ShadowMapPass = (function (_super) {
        __extends(ShadowMapPass, _super);
        /**
        * @language zh_CN
        * 创建一个新的 ShadowMapPass 对象。
        * @param data {MaterialData} 材质数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        function ShadowMapPass(data) {
            _super.call(this, data);
        }
        /**
         * @language zh_CN
         * 初始化 UseMethod。
         * @version Egret 3.0
         * @platform Web,Native
         */
        ShadowMapPass.prototype.initUseMethod = function () {
            var i = 0;
            if (this.animation) {
                if (this.animation.animaNodeCollection) {
                    var vsShaderNames = this.animation.animaNodeCollection.getNodesVertexShaders();
                    var fsShaderNames = this.animation.animaNodeCollection.getNodesFragmentShaders();
                    for (i = 0; i < vsShaderNames.length; i++) {
                        this.vertexShader.addShader(vsShaderNames[i]);
                    }
                    for (i = 0; i < fsShaderNames.length; i++) {
                        this.pixelShader.addShader(fsShaderNames[i]);
                    }
                }
            }
            this.pixelShader.addShader("Shadow_fragment");
        };
        /**
         * @language zh_CN
         * 初始化 shader 。
         * @param context3D {Context3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        ShadowMapPass.prototype.initShader = function (context3D, geometry, animation) {
            _super.prototype.initShader.call(this, context3D, geometry, animation);
            this.vertexShader = new egret3d.VertexShader(this.materialData, this.materialData.shadowPassUsageData);
            this.pixelShader = new egret3d.PixelShader(this.materialData, this.materialData.shadowPassUsageData);
            this.materialData.context3D = context3D;
            this.vertexShader.setVertexShader(geometry);
            this.initUseMethod();
            if (animation) {
                animation.initShader(this.vertexShader, this.pixelShader);
            }
            this.vertexShader.build();
            this.pixelShader.build();
            var vs = this.vertexShader.getShaderSource();
            var fs = this.pixelShader.getShaderSource();
            var vs_shader = context3D.creatVertexShader(vs);
            var fs_shader = context3D.creatFragmentShader(fs);
            this.materialData.shadowPassUsageData.program3D = context3D.creatProgram(vs_shader, fs_shader);
            this.context3DChange = true;
        };
        /**
         * @language zh_CNa
         * 激活 阴影贴图通道渲染器。
         * @version Egret 3.0
         * @platform Web,Native
         * @param context3D {Context3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        ShadowMapPass.prototype.activate = function (context3D, modeltransform, camera3D, geometry, animation) {
            for (this.index = 0; this.index < this.materialData.shadowPassUsageData.vsMethodList.length; this.index++) {
                this.materialData.shadowPassUsageData.vsMethodList[this.index].activate(context3D, this.materialData.shadowPassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            for (this.index = 0; this.index < this.materialData.shadowPassUsageData.fsMethodList.length; this.index++) {
                this.materialData.shadowPassUsageData.fsMethodList[this.index].activate(context3D, this.materialData.shadowPassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            //--------texture----------------
            var sampler2D;
            for (var index in this.materialData.shadowPassUsageData.sampler2DList) {
                sampler2D = this.materialData.shadowPassUsageData.sampler2DList[index];
                sampler2D.uniformIndex = context3D.getUniformLocation(this.materialData.shadowPassUsageData.program3D, sampler2D.varName);
            }
            //--------texture----------------
            var sampler3D;
            for (var index in this.materialData.shadowPassUsageData.sampler3DList) {
                sampler3D = this.materialData.shadowPassUsageData.sampler3DList[index];
                sampler3D.uniformIndex = context3D.getUniformLocation(this.materialData.shadowPassUsageData.program3D, sampler3D.varName);
            }
        };
        /**
         * @language zh_CNa
         * 绘制。
         * @version Egret 3.0
         * @platform Web,Native
         * @param context3D {Context3D}
         * @param modeltransform {Matrix4_4}
         * @param camera3D {Camera3D}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        ShadowMapPass.prototype.draw = function (context3D, modeltransform, camera3D, geometry, animation) {
            if (this.context3DChange) {
                this.activate(context3D, modeltransform, camera3D, geometry, animation);
                this.context3DChange = false;
            }
            context3D.gl.useProgram(this.materialData.shadowPassUsageData.program3D.program);
            _super.prototype.draw.call(this, context3D, modeltransform, camera3D, geometry, animation);
            var i = 0;
            //texture 2D
            var sampler2D;
            for (var index in this.materialData.shadowPassUsageData.sampler2DList) {
                sampler2D = this.materialData.shadowPassUsageData.sampler2DList[index];
                sampler2D.texture = this.materialData[sampler2D.varName];
                sampler2D.texture.upload(context3D);
                context3D.setTexture2DAt(sampler2D.activeTextureIndex, sampler2D.uniformIndex, sampler2D.index, sampler2D.texture.texture);
            }
            var sampler3D;
            for (var index in this.materialData.shadowPassUsageData.sampler3DList) {
                sampler3D = this.materialData.shadowPassUsageData.sampler3DList[index];
                sampler3D.texture = this.materialData[sampler3D.varName];
                sampler3D.texture.upload(context3D);
                context3D.setCubeTextureAt(sampler3D.activeTextureIndex, sampler3D.uniformIndex, sampler3D.index, sampler3D.texture.cubeTexture);
            }
            for (this.index = 0; this.index < this.materialData.shadowPassUsageData.vsMethodList.length; this.index++) {
                this.materialData.shadowPassUsageData.vsMethodList[this.index].updata(context3D, this.materialData.shadowPassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            for (this.index = 0; this.index < this.materialData.shadowPassUsageData.fsMethodList.length; this.index++) {
                this.materialData.shadowPassUsageData.fsMethodList[this.index].updata(context3D, this.materialData.shadowPassUsageData.program3D, modeltransform, camera3D, geometry, animation);
            }
            context3D.gl.bindBuffer(egret3d.Egret3DDrive.ELEMENT_ARRAY_BUFFER, geometry.sharedIndexBuffer.buffer);
            context3D.gl.drawElements(this.materialData.drawMode, geometry.numItems, egret3d.Egret3DDrive.UNSIGNED_SHORT, 0);
            //if (this.materialData.alphaBlending)
            //context3D.gl.depthMask(this.materialData.alphaBlending);
            for (var index in this.materialData.shadowPassUsageData.sampler2DList) {
                context3D.gl.bindTexture(context3D.gl.TEXTURE_2D, null);
            }
        };
        return ShadowMapPass;
    })(egret3d.MaterialPassBase);
    egret3d.ShadowMapPass = ShadowMapPass;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    (function (MaterialType) {
        MaterialType[MaterialType["DIFFUSE"] = 0] = "DIFFUSE";
        MaterialType[MaterialType["DIFFUSE_BUMP"] = 1] = "DIFFUSE_BUMP";
        MaterialType[MaterialType["DIFFUSE_BUMP_SPECULAR"] = 2] = "DIFFUSE_BUMP_SPECULAR";
        MaterialType[MaterialType["RGBATERRAIN"] = 3] = "RGBATERRAIN";
    })(egret3d.MaterialType || (egret3d.MaterialType = {}));
    var MaterialType = egret3d.MaterialType;
    /**
    * @language zh_CN
    * @class egret3d.MaterialBase
    * @classdesc
    * TerrainMaterial,TextureMaterial 的基类。
    * 材质球共有的基础类型，封装了材质球共有的基础数据设置方法
    * 不同的渲染通道pass
    * @version Egret 3.0
    * @platform Web,Native
    */
    var MaterialBase = (function () {
        /**
         * @private
        * @language zh_CN
        * 创建一个新的 MethodBase 对象。
        * @param materialData {MaterialData}
        * @version Egret 3.0
        * @platform Web,Native
        */
        function MaterialBase(materialData) {
            if (materialData === void 0) { materialData = null; }
            if (materialData == null) {
                this.materialData = new egret3d.MaterialData();
                this.materialData.diffusePassUsageData.materialSourceData = new Float32Array(16);
            }
            else {
                this.materialData = materialData;
            }
            this.setData(this.materialData);
        }
        /**
         * @private
        * @language zh_CN
        * 初始化 MatPass。
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialBase.prototype.initMatPass = function () {
            switch (this.materialData.matType) {
                case MaterialType.DIFFUSE:
                    this.diffusePass = new egret3d.DiffuseMapPass(this.materialData);
                    break;
                case MaterialType.DIFFUSE_BUMP:
                    this.diffusePass = new egret3d.DiffuseMapPass(this.materialData);
                    break;
                case MaterialType.DIFFUSE_BUMP_SPECULAR:
                    this.diffusePass = new egret3d.DiffuseMapPass(this.materialData);
                    break;
                case MaterialType.RGBATERRAIN:
                    this.diffusePass = new egret3d.TerrainMapPass(this.materialData);
                    break;
            }
        };
        /**
        * @language zh_CN
        * 设置材质球数据。
        * 设置材质球的数据data，今后的工具编辑器会直接使用
        * @param materialData {MaterialData}
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialBase.prototype.setData = function (matData) {
            if (this.materialData) {
                this.materialData.dispose();
            }
            this.materialData = matData;
            this.ambientColor = this.materialData.ambientColor;
            this.ambientPower = this.materialData.ambientPower;
            this.normalPower = this.materialData.normalPower;
            this.specularColor = this.materialData.specularColor;
            this.specularPower = this.materialData.specularPower;
            this.blendMode = this.materialData.blendMode;
        };
        /**
         * @language zh_CN
         * 返回材质球数据。
         * 返回材质球数据。
         * @returns {MaterialData}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.getData = function () {
            return this.materialData;
        };
        /**
        * @language zh_CN
        * 添加材质 DiffusePass 方法。
        * 添加自定义的 材质球渲染通道，渲染不同的pass
        * @param method {MethodBase}
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialBase.prototype.addDiffusePassMothod = function (method) {
            this.diffusePass.addMethod(method);
        };
        /**
        * @language zh_CN
        * 添加材质 DiffusePassEffect 方法。
        * 添加材质球的特效找色片段，其着色shader会加入到最后一行
        * @param method {EffectMethod}
        * @version Egret 3.0
        * @platform Web,Native
        */
        MaterialBase.prototype.addDiffusePassEffectMothod = function (method) {
            this.diffusePass.addEffectMethod(method);
        };
        Object.defineProperty(MaterialBase.prototype, "shadowMapingMethod", {
            /**
            * @language zh_CN
            * 返回 shadowMaping 方法。
            * 返回 阴影的maping 方式。
            * @returns {ShadowMapingMethod}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.diffusePass.shadowMaping;
            },
            /**
            * @language zh_CN
            * 设置材质 shadowMaping 方法。
            * 设置材质 接受阴影的方法，如果要 接受阴影必须设置 acceptShadow 和maping方式
            * @param method {ShadowMapingMethod}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (method) {
                this.diffusePass.shadowMaping = method;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "diffuseColor", {
            /**
            * @language zh_CN
            * 设置材质 diffuseColor。
            * 设置 16 进制的漫反射颜色
            * @param color {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this.materialData.materialDataNeedChange = true;
                this.materialData.diffuseColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "ambientColor", {
            /**
            * @language zh_CN
            * 设置材质 ambientColor。
            * 设置 16 进制的环境光颜色
            * @param color {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this.materialData.materialDataNeedChange = true;
                this.materialData.ambientColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "specularColor", {
            /**
            * @language zh_CN
            * 设置材质 specularColor。
            * 设置 16 进制的镜面光反射颜色
            * @param color {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (color) {
                this.materialData.materialDataNeedChange = true;
                this.materialData.specularColor = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "alpha", {
            /**
             * @language zh_CN
             * 返回材质 alpha 值。
             * 返回 alpha 颜色
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.alpha;
            },
            /**
             * @language zh_CN
             * 设置材质 alpha 值。
             * 设置 材质球的透明度，如果透明度小于1会自动启用 alphablending
             * @param value {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                if (this.materialData.alpha != value) {
                    this.materialData.alpha = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "shininess", {
            /**
             * @language zh_CN
             * 返回材质 shininess 值。
             * 返回材质 光滑程度 值越大，越不光滑
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.shininess;
            },
            /**
             * @language zh_CN
             * 设置材质 shininess 值。
             * 设置材质球的 光滑程度 值越大，越不光滑
             * @param value {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                if (this.materialData.shininess != value) {
                    this.materialData.shininess = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "specularPower", {
            /**
             * @language zh_CN
             * 返回材质 specularPower 值。
             * 返回材质 高光颜色的强度 值。
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.specularPower;
            },
            /**
             * @language zh_CN
             * 设置材质 specularPower 值。
             * 设置材质 高光颜色的强度 值。
             * @param value {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                if (this.materialData.specularPower != value) {
                    this.materialData.specularPower = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "ambientPower", {
            /**
             * @language zh_CN
             * 返回材质 ambientPower 值。
             * 返回材质 环境光颜色的强度 值。
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.ambientPower;
            },
            /**
             * @language zh_CN
             * 设置材质 ambientPower 值。
             * 设置材质 环境光颜色的强度 值。
             * @param value {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                if (this.materialData.ambientPower != value) {
                    this.materialData.ambientPower = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "diffusePower", {
            /**
             * @language zh_CN
             * 返回材质 diffusePower 值。
             * 返回材质 漫反射颜色的强度 值。
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.diffusePower;
            },
            /**
             * @language zh_CN
             * 设置材质 diffusePower 值。
             * 设置材质 漫反射颜色的强度 值。
             * @param value {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                if (this.materialData.diffusePower != value) {
                    this.materialData.diffusePower = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "normalPower", {
            /**
             * @language zh_CN
             * 返回材质 normalPower 值。
             * 返回材质 法线的强度 值。
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.normalPower;
            },
            /**
             * @language zh_CN
             * 设置材质 normalPower 值。
             * 设置材质 法线的强度 值。
             * @param value {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                if (this.materialData.normalPower != value) {
                    this.materialData.normalPower = value;
                    this.materialData.materialDataNeedChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "castShadow", {
            /**
             * @language zh_CN
             * 返回材质 castShadow 值。
             * 返回材质 是否产生阴影 值。
             * @returns {boolean}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.castShadow;
            },
            /**
             * @language zh_CN
             * 设置材质 castShadow 值。
             * 设置材质是否接受阴影，设置了之后必须要给 shadowmaping 的方法。
             * @param value {boolean}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this.materialData.castShadow = value;
                if (value) {
                    if (!egret3d.ShadowRender.frameBuffer) {
                        alert("要使用shadow view3D.useShadow = true ");
                    }
                    else {
                        if (!this.shadowPass)
                            this.shadowPass = new egret3d.ShadowMapPass(this.materialData);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "acceptShadow", {
            /**
            * @language zh_CN
            * 返回材质 acceptShadow 值。
            * 返回材质是否接受阴影，设置了之后必须要给 shadowmaping 的方法。
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.acceptShadow;
            },
            /**
             * @language zh_CN
             * 设置材质 acceptShadow 值。
             * 设置材质是否是否产生阴影，设置了之后必须要给 shadowmaping 的方法。
             * @param value {boolean}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this.materialData.acceptShadow = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "smooth", {
            /**
            * @language zh_CN
            * 返回材质 smooth 值。
            * 返回 材质纹理的采样方式，是否抗锯齿，是否精细显示。的开关
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.smooth;
            },
            /**
             * @language zh_CN
             * 设置材质 smooth 值。
             * 材质纹理的采样方式，是否抗锯齿，是否精细显示。
             * @param value {boolean}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (val) {
                this.materialData.smooth = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "repeat", {
            /**
            * @language zh_CN
            * 返回材质 repeat 值。
            * 返回材质 是否进行纹理重复采样的方式开关。
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.repeat;
            },
            /**
             * @language zh_CN
             * 设置材质 repeat 值。
             * 设置材质 是否进行纹理重复采样的方式开关。
             * @param value {boolean}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (val) {
                this.materialData.repeat = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "bothside", {
            /**
            * @language zh_CN
            * 返回材质 bothside 值。
           * 返回是否显示双面的开关，一般情况不需要。
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.bothside;
            },
            /**
             * @language zh_CN
             * 设置材质 bothside 值。
            * 设置材质是否显示双面的开关，一般情况不需要。
             * @param value {boolean}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (val) {
                this.materialData.bothside = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "cullMode", {
            /**
             * @language zh_CN
             * 返回 cull 模式。
             * @returns {Number}
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this.materialData.cullFrontOrBack;
            },
            /**
           * @language zh_CN
           * 设置 cull 模式。
           * @param value {Number}
           * @version Egret 3.0
           * @platform Web,Native
           */
            set: function (value) {
                this.materialData.cullFrontOrBack = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "blendMode", {
            /**
            * @language zh_CN
            * 返回材质 blendMode 值。
            * 返回材质 blendMode 值。
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.blendMode;
            },
            /**
             * @language zh_CN
             * 设置材质 blendMode 值。
             * 设置材质球的 混合模式可以参照 blendmode 中的值
             * @param value {BlendMode}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this.materialData.blendMode = value;
                switch (value) {
                    case egret3d.BlendMode.NORMAL:
                        this.materialData.blend_src = egret3d.Egret3DDrive.ONE;
                        this.materialData.blend_dest = egret3d.Egret3DDrive.ZERO;
                        break;
                    case egret3d.BlendMode.LAYER:
                        this.materialData.blend_src = egret3d.Egret3DDrive.SRC_ALPHA;
                        this.materialData.blend_dest = egret3d.Egret3DDrive.ZERO;
                        this.materialData.alphaBlending = true;
                        break;
                    case egret3d.BlendMode.MULTIPLY:
                        this.materialData.blend_src = egret3d.Egret3DDrive.ZERO;
                        this.materialData.blend_dest = egret3d.Egret3DDrive.SRC_COLOR;
                        this.materialData.alphaBlending = true;
                        break;
                    case egret3d.BlendMode.ADD:
                        this.materialData.blend_src = egret3d.Egret3DDrive.SRC_ALPHA;
                        this.materialData.blend_dest = egret3d.Egret3DDrive.ONE;
                        this.materialData.alphaBlending = true;
                        break;
                    case egret3d.BlendMode.ALPHA:
                        this.materialData.blend_src = egret3d.Egret3DDrive.SRC_ALPHA;
                        this.materialData.blend_dest = egret3d.Egret3DDrive.ONE_MINUS_SRC_ALPHA;
                        this.materialData.alphaBlending = true;
                        break;
                    case egret3d.BlendMode.SCREEN:
                        this.materialData.blend_src = egret3d.Egret3DDrive.ONE;
                        this.materialData.blend_dest = egret3d.Egret3DDrive.ONE_MINUS_SRC_COLOR;
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @language zh_CN
         * 设置材质 Outline 样式。
         * @param color {Number}
         * @param thickness {Number}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.setOutlineStyler = function (color, thickness) {
            if (!this.outLinePass) {
            }
        };
        Object.defineProperty(MaterialBase.prototype, "depthTest", {
            /**
            * @language zh_CN
            * 返回材质 depthTest 值。
            * 返回物件渲染，是否需要进行深度排序的开关。
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.depthTest;
            },
            /**
             * @language zh_CN
             * 设置材质 depthTest。
             * 设置物件渲染，是否需要进行深度排序的开关。
             * @param value {boolean}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this.materialData.depthTest = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "lightGroup", {
            /**
             * @language zh_CN
             * 设置材质 lightGroup 。
             * 设置材质球接受的灯光组。
             * @param lightGroup {LightGroup}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (lightGroup) {
                this.materialData.directLightList = lightGroup.directLightList;
                this.materialData.sportLightList = lightGroup.spotLightList;
                this.materialData.pointLightList = lightGroup.pointLightList;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "diffuseTexture", {
            /**
            * @language zh_CN
            * 返回材质 diffuseTexture。
            * 返回材质球的漫反射贴图。
            * @returns {TextureBase}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this.materialData.diffuseTex;
            },
            /**
             * @language zh_CN
             * 设置材质 diffuseTexture 。
             * 设置材质球的漫反射贴图。
             * @param texture {TextureBase}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                if (texture) {
                    this.materialData.diffuseTex = texture;
                    this.materialData.textureChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "normalTexture", {
            /**
             * @language zh_CN
             * 设置材质 normalTexture 。
             * 设置材质球的凹凸法线贴图。
             * @param texture {TextureBase}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                if (texture) {
                    this.materialData.normalTex = texture;
                    this.materialData.textureChange = true;
                    if (this.materialData.matType != MaterialType.DIFFUSE_BUMP) {
                        this.materialData.matType = MaterialType.DIFFUSE_BUMP;
                        this.materialData.passChange = true;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialBase.prototype, "specularTexture", {
            /**
             * @language zh_CN
             * 设置材质 specularTexture 。
             * 设置材质球的高光贴图。
             * @param texture {TextureBase}
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (texture) {
                if (texture) {
                    this.materialData.specularTex = texture;
                    this.materialData.textureChange = true;
                    if (this.materialData.matType != MaterialType.DIFFUSE_BUMP_SPECULAR) {
                        this.materialData.matType = MaterialType.DIFFUSE_BUMP_SPECULAR;
                        this.materialData.passChange = true;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         * 克隆材质。
         * 返回新的材质球，但是共用材质纹理，和着色器。
         * @returns {MaterialBase}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.clone = function () {
            var mat = new MaterialBase(this.materialData.clone());
            return mat;
        };
        /**
         * @private
         * @language zh_CN
         * 激活 DiffusePass
         * @param context3D {Context3D}
         * @param camera3D {Camera3D}
         * @param modelMatrix {Matrix4_4}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.activateDiffusePass = function (context3D, camera3D, modelMatrix, geometry, animation) {
            if (this.outLinePass) {
                this.outLinePass.initShader(context3D, geometry, animation);
                this.outLinePass.activate(context3D, modelMatrix, camera3D, geometry, animation);
            }
            this.diffusePass.initShader(context3D, geometry, animation);
            this.diffusePass.activate(context3D, modelMatrix, camera3D, geometry, animation);
        };
        /**
         * @private
         * @language zh_CN
         * 渲染 DiffusePass
         * @param context3D {Context3D}
         * @param camera3D {Camera3D}
         * @param modelMatrix {Matrix4_4}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.rendenDiffusePass = function (context3D, camera3D, modelMatrix, geometry, animation) {
            if (this.outLinePass) {
                this.outLinePass.draw(context3D, modelMatrix, camera3D, geometry, animation);
            }
            if (!this.materialData.passChange) {
                this.diffusePass.draw(context3D, modelMatrix, camera3D, geometry, animation);
            }
            else {
                this.activateDiffusePass(context3D, camera3D, modelMatrix, geometry, animation);
                this.materialData.passChange = false;
            }
        };
        /**
         * @private
         * @language zh_CN
         * 激活 ShadowPass
         * @param context3D {Context3D}
         * @param camera3D {Camera3D}
         * @param modelMatrix {Matrix4_4}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.activateShadowPass = function (context3D, camera3D, modelMatrix, geometry, animation) {
            this.shadowPass.initShader(context3D, geometry, animation);
            this.shadowPass.activate(context3D, modelMatrix, camera3D, geometry, animation);
        };
        /**
         * @private
         * @language zh_CN
         * 渲染 ShadowPass
         * @language zh_CN
         * @param context3D {Context3D}
         * @param camera3D {Camera3D}
         * @param modelMatrix {Matrix4_4}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.rendenShadowPass = function (context3D, camera3D, modelMatrix, geometry, animation) {
            if (!this.materialData.passChange) {
                this.shadowPass.draw(context3D, modelMatrix, camera3D, geometry, animation);
            }
            else {
                this.activateShadowPass(context3D, camera3D, modelMatrix, geometry, animation);
            }
        };
        /**
         * @private
         * @language zh_CN
         * 激活 NormalPass
         * @language zh_CN
         * @param context3D {Context3D}
         * @param camera3D {Camera3D}
         * @param modelMatrix {Matrix4_4}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.activateNormalPass = function (context3D, camera3D, modelMatrix, geometry, animation) {
            this.normalPass.initShader(context3D, geometry, animation);
            this.normalPass.activate(context3D, modelMatrix, camera3D, geometry, animation);
        };
        /**
         * @private
         * @language zh_CN
         * 渲染 NormalPass
         * @param context3D {Context3D}
         * @param camera3D {Camera3D}
         * @param modelMatrix {Matrix4_4}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.rendenNormalPass = function (context3D, camera3D, modelMatrix, geometry, animation) {
            //if (this.materialData._NormalActiveState) {
            //    this.normalPass.draw(context3D, modelMatrix, camera3D,geometry, animation )
            //} else {
            //    this.materialData._NormalActiveState = true;
            //    this.activateNormalPass(context3D, camera3D,modelMatrix,geometry, animation);
            //}
        };
        /**
         * @private
         * @language zh_CN
         * 激活 DepthPass
         * @param context3D {Context3D}
         * @param camera3D {Camera3D}
         * @param modelMatrix {Matrix4_4}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.activateDepthPass = function (context3D, camera3D, modelMatrix, geometry, animation) {
            this.depthPass.initShader(context3D, geometry, animation);
            this.depthPass.activate(context3D, modelMatrix, camera3D, geometry, animation);
        };
        /**
         * @private
         * @language zh_CN
         * 渲染 DepthPass
         * @param context3D {Context3D}
         * @param camera3D {Camera3D}
         * @param modelMatrix {Matrix4_4}
         * @param geometry {GeometryBase}
         * @param animation {IAnimation}
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.rendenDepthPass = function (context3D, camera3D, modelMatrix, geometry, animation) {
            //if (this.materialData._DepthActiveState) {
            //    this.depthPass.draw(context3D, modelMatrix, camera3D, geometry, animation)
            //} else {
            //    this.materialData._DepthActiveState = true;
            //    this.activateDepthPass(context3D, camera3D, modelMatrix, geometry, animation);
            //}
        };
        /**
         * @language zh_CN
         * 销毁
         * 进行材质球的纹理，着色器回收，相关的克隆对象会受影响
         * @version Egret 3.0
         * @platform Web,Native
         */
        MaterialBase.prototype.dispose = function () {
        };
        return MaterialBase;
    })();
    egret3d.MaterialBase = MaterialBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.TerrainMaterial
    * @classdesc
    * 地形材质。
    * 地形材质球，可以使用 一张control 的rgba 贴图控制融合地表纹理，最大只能融合4张地表纹理，后期可以进行拓展，也可设置单独的纹理重复次数，纹理的uv映射方式，具体可以看官方的示例教程
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TerrainMaterial = (function (_super) {
        __extends(TerrainMaterial, _super);
        /**
         * @language zh_CN
         * 创建一个新的 TerrainMaterial 对象。
         * @param colormap {TextureBase}
         * @param controlTex {TextureBase}
         * @param splat_0 {TextureBase}
         * @param splat_1 {TextureBase}
         * @param splat_2 {TextureBase}
         * @param splat_3 {TextureBase}
         * @param lightMap {TextureBase}
         * @version Egret 3.0
         * @platform Web,Native
         */
        function TerrainMaterial(colormap, controlTex, splat_0, splat_1, splat_2, splat_3, lightMap) {
            if (lightMap === void 0) { lightMap = null; }
            _super.call(this);
            this.materialData.matType = egret3d.MaterialType.RGBATERRAIN;
            this.materialData.diffuseTex = colormap;
            this.materialData.maskTex = controlTex;
            this.materialData.splat_0Tex = splat_0;
            this.materialData.splat_1Tex = splat_1;
            this.materialData.splat_2Tex = splat_2;
            this.materialData.splat_3Tex = splat_3;
            if (!lightMap)
                this.materialData.lightMapTex = egret3d.CheckerboardTexture.texture;
            else
                this.materialData.lightMapTex = lightMap;
            this.initMatPass();
        }
        /**
         * @language zh_CN
         * 设置 UVTitling。
         * @param index {Number} 图层索引
         * @param x {Number}
         * @param y {Number}
         * @version Egret 3.0
         * @platform Web,Native
         */
        TerrainMaterial.prototype.setUVTitling = function (index, x, y) {
            this.diffusePass.diffuseMethod.setUVTitling(index, x, y);
        };
        return TerrainMaterial;
    })(egret3d.MaterialBase);
    egret3d.TerrainMaterial = TerrainMaterial;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.TextureMaterial
    * @classdesc
    * 纹理材质。
    * 标准的贴图材质球，可以设置三种贴图， diffuse ， normal ， speclar 贴图
    * 材质球中默认不设置纹理，显示的黑白棋盘格
    * @version Egret 3.0
    * @platform Web,Native
    */
    var TextureMaterial = (function (_super) {
        __extends(TextureMaterial, _super);
        /**
         * @language zh_CN
         * 创建一个新的 TextureMaterial 对象。
         * @param texture {TextureBase}
         * @param materialData {MaterialData}
         * @version Egret 3.0
         * @platform Web,Native
         */
        function TextureMaterial(texture, materialData) {
            if (texture === void 0) { texture = null; }
            if (materialData === void 0) { materialData = null; }
            _super.call(this, materialData);
            if (!texture) {
                this.diffuseTexture = egret3d.CheckerboardTexture.texture;
            }
            else {
                this.diffuseTexture = texture;
            }
            this.initMatPass();
        }
        /**
         * @language zh_CN
         * 克隆方法。
         * 将材质球克隆一份，公用shader着色器和贴图，不公用参数
         * @returns {TextureMaterial}
         * @version Egret 3.0
         * @platform Web,Native
         */
        TextureMaterial.prototype.clone = function () {
            var mat = new TextureMaterial(this.diffuseTexture, this.materialData.clone());
            return mat;
        };
        return TextureMaterial;
    })(egret3d.MaterialBase);
    egret3d.TextureMaterial = TextureMaterial;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.Frustum
    * @classdesc
    * 摄像机视椎体,计算出摄像机的可视范围.
    *
    * @see egret3d.camera.Camera3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Frustum = (function () {
        /**
        * @language zh_CN
        * 构造
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Frustum() {
            this._vtxNum = 8;
            this._planeNum = 6;
            this._vertex = new Array();
            for (var i = 0; i < this._vtxNum; ++i) {
                this._vertex.push(new egret3d.Vector3D());
            }
            this._pos = new egret3d.Vector3D();
            this._plane = new Array();
            for (var i = 0; i < 6; ++i) {
                this._plane.push(new egret3d.Plane3D());
            }
            this.box = new egret3d.CubeBoxBound(new egret3d.Vector3D(), new egret3d.Vector3D());
            ///this.box = new CubeBoxBound(new Vector3D(99999.0, 99999.0, 99999.0), new Vector3D(-99999.0, -99999.0, -99999.0));
            this.center = new egret3d.Vector3D();
        }
        /**
        * @language zh_CN
        * 生成一个视椎体
        * @param fovY 观察时y 轴方向的角度，就是观察范围夹角。
        * @param aspectRatio 纵横比，在视空间宽度除以高度.
        * @param nearPlane 近裁剪面位置Z值.
        * @param farPlane 远裁剪面位置Z值.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.makeFrustum = function (fovY, aspectRatio, nearPlane, farPlane) {
            ///var tangent: number = Math.tan(fovY / 2.0 * (Math.PI / 180.0));
            var tangent = Math.tan(fovY / 2.0 * (Math.PI / 180.0));
            var nearHeight = nearPlane * tangent;
            var nearWidth = nearHeight * aspectRatio;
            var farHeight = farPlane * tangent;
            var farWidth = farHeight * aspectRatio;
            /// near top right
            this._vertex[0].x = nearWidth;
            this._vertex[0].y = nearHeight;
            this._vertex[0].z = nearPlane;
            /// near top left
            this._vertex[1].x = -nearWidth;
            this._vertex[1].y = nearHeight;
            this._vertex[1].z = nearPlane;
            /// near bottom left
            this._vertex[2].x = -nearWidth;
            this._vertex[2].y = -nearHeight;
            this._vertex[2].z = nearPlane;
            /// near bottom right
            this._vertex[3].x = nearWidth;
            this._vertex[3].y = -nearHeight;
            this._vertex[3].z = nearPlane;
            /// far top right
            this._vertex[4].x = farWidth;
            this._vertex[4].y = farHeight;
            this._vertex[4].z = farPlane;
            /// far top left
            this._vertex[5].x = -farWidth;
            this._vertex[5].y = farHeight;
            this._vertex[5].z = farPlane;
            /// far bottom left
            this._vertex[6].x = -farWidth;
            this._vertex[6].y = -farHeight;
            this._vertex[6].z = farPlane;
            /// far bottom right
            this._vertex[7].x = farWidth;
            this._vertex[7].y = -farHeight;
            this._vertex[7].z = farPlane;
        };
        /**
        * @language zh_CN
        * 数据更新.
        * @param camera 视椎的摄像机.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.update = function (camera) {
            this.makeFrustum(camera.fieldOfView, camera.aspectRatio, camera.near, camera.far);
            /// 摄像机变化之后的顶点也变化;
            var vtx = new Array();
            var mat = new egret3d.Matrix4_4();
            mat.copyFrom(camera.modelMatrix);
            ///mat.invert(); /// 眼睛的世界矩阵;
            this._curVer = vtx;
            for (var i = 0; i < this._vtxNum; ++i) {
                vtx.push(mat.transformVector(this._vertex[i]));
            }
            for (var i = 0; i < vtx.length; ++i) {
                if (this.box.max.x < vtx[i].x) {
                    this.box.max.x = vtx[i].x;
                }
                if (this.box.max.y < vtx[i].y) {
                    this.box.max.y = vtx[i].y;
                }
                if (this.box.max.z < vtx[i].z) {
                    this.box.max.z = vtx[i].z;
                }
                if (this.box.min.x > vtx[i].x) {
                    this.box.min.x = vtx[i].x;
                }
                if (this.box.min.y > vtx[i].y) {
                    this.box.min.y = vtx[i].y;
                }
                if (this.box.min.z > vtx[i].z) {
                    this.box.min.z = vtx[i].z;
                }
            }
            this.box.calculateBox();
            this._plane[0].fromPoints(vtx[4], vtx[5], vtx[6]); /// 远平面(far);
            this._plane[1].fromPoints(vtx[1], vtx[6], vtx[5]); /// 左平面(left);
            this._plane[2].fromPoints(vtx[0], vtx[4], vtx[7]); /// 右平面(right);
            this._plane[3].fromPoints(vtx[1], vtx[0], vtx[3]); /// 近平面(near);
            this._plane[4].fromPoints(vtx[1], vtx[5], vtx[4]); /// 上平面(top);
            this._plane[5].fromPoints(vtx[3], vtx[7], vtx[6]); /// 下平面(bottom);
            for (var i = 0; i < this._planeNum; i++) {
                this._plane[i].normalize();
            }
            var nearCenter = new egret3d.Vector3D();
            nearCenter.copyFrom(vtx[0].subtract(vtx[2]));
            nearCenter.scaleBy(0.5);
            nearCenter.copyFrom(vtx[2].add(nearCenter));
            var farCenter = new egret3d.Vector3D();
            farCenter.copyFrom(vtx[4].subtract(vtx[6]));
            farCenter.scaleBy(0.5);
            farCenter.copyFrom(vtx[6].add(farCenter));
            this.center.copyFrom(farCenter.subtract(nearCenter));
            this.center.scaleBy(0.5);
            this.center.copyFrom(nearCenter.add(this.center));
        };
        /**
        * @language zh_CN
        * 检测一个坐标点是否在视椎体内
        * @param pos 检测的坐标
        * @returns 在视椎内返回ture
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.inPoint = function (pos) {
            var dis = 0;
            for (var i = 0; i < this._plane.length; ++i) {
                dis = this._plane[i].distance(pos);
                if (dis > 0.0) {
                    return false;
                }
            }
            return true;
        };
        /**
        * @language zh_CN
        * 检测一个球是否在视椎体内
        * @param center 球的坐标
        * @param radius 球的半径
        * @returns 在视椎内返回ture
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.inSphere = function (center, radius) {
            var dis = 0;
            for (var i = 0; i < this._plane.length; ++i) {
                dis = this._plane[i].distance(center);
                if (dis > radius) {
                    return false;
                }
            }
            return true;
        };
        /**
        * @language zh_CN
        * 检测一个盒子是否在视椎体内
        * @param box 盒子
        * @returns 在视椎内返回ture
        * @version Egret 3.0
        * @platform Web,Native
        */
        Frustum.prototype.inBox = function (box) {
            var v = new Array();
            var dis = 0;
            var temp = new egret3d.Vector3D();
            for (var i = 0; i < this._plane.length; ++i) {
                var incount = box.vexData.length / 3;
                for (var j = 0; j < box.vexData.length; j += 3) {
                    temp.setTo(box.vexData[j], box.vexData[j + 1], box.vexData[j + 2]);
                    temp.copyFrom(box.Transform.transformVector(temp));
                    dis = this._plane[i].distance(temp);
                    if (dis > 0) {
                        incount--;
                    }
                }
                if (incount <= 0) {
                    return false;
                }
            }
            return true;
        };
        return Frustum;
    })();
    egret3d.Frustum = Frustum;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Object3D
    * @classdesc
    * 拣选类型，拣选时可以分为，包围盒拣选、模型拣选返回模型拣选到的位置、模型拣选返回模型拣选到的UV坐标
    * 这几种拣选方式
    * 设置鼠标拣选的类型，鼠标拣选不同的类型有不同的效果作用，还有性能
    * 需要的拣选精度越高，性能要求就越高，反之亦然
    *
    * @see egret3d.core.traverse.Picker
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (PickType) {
        /**
        * 包围盒拣选
        */
        PickType[PickType["BoundPick"] = 0] = "BoundPick";
        /**
        * 模型拣选返回模型拣选到的位置
        */
        PickType[PickType["PositionPick"] = 1] = "PositionPick";
        /**
        * 模型拣选返回模型拣选到的UV坐标
        */
        PickType[PickType["UVPick"] = 2] = "UVPick";
    })(egret3d.PickType || (egret3d.PickType = {}));
    var PickType = egret3d.PickType;
    ;
    /**
    * @class egret3d.Object3D
    * @classdesc
    * 3d空间中的实体对象。
    * 场景图中的Object3D对象是一个树型结构，对象中包含了变换信息.
    * 这些变换信息应用于所有的子对象,子对象也有自己的变换信息,最终
    * 的变换信息要结合父对象的变换信息
    * 每个Object3D对象在生成时会创建一个包围盒
    *
    * @see egret3d.geom.Vector3D
    * @see egret3d.geom.Matrix4_4
    * @see egret3d.geom.Quaternion
    * @see egret3d.geom.CubeBoxBound
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Object3D = (function (_super) {
        __extends(Object3D, _super);
        /**
        * @language zh_CN
        * 实例化这个类
        * 如果直接实例化这个类，就会生成一个空的3D容器，可以往里添加3D显示对象，作为对象的父级，但是本身没有渲染属性
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Object3D() {
            _super.call(this);
            this._modeMatrix3D = new egret3d.Matrix4_4();
            this._transformChange = true;
            this._pos = new egret3d.Vector3D();
            this._rot = new egret3d.Vector3D();
            this._sca = new egret3d.Vector3D(1, 1, 1);
            this._orientation = new egret3d.Quaternion();
            this._axis = new egret3d.Vector3D();
            this._angle = 0;
            this._globalPos = new egret3d.Vector3D();
            this._globalRot = new egret3d.Vector3D();
            this._globalSca = new egret3d.Vector3D(1, 1, 1);
            this._globalOrientation = new egret3d.Quaternion();
            this._qut = new egret3d.Quaternion();
            this._active = false;
            this._mat = new egret3d.Matrix4_4();
            /**
            * @language zh_CN
            * 渲染层级
            * 渲染时分组进行依次渲染 前16位表示tag,后16位表示layer
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.layer = 0x00000000;
            /**
            * @language zh_CN
            * 是否开启鼠标事件
            * 设定这个物件是否具有 鼠标交互能力的开关
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.mouseEnable = false;
            /**
            * @language zh_CN
            * 是否需要视锥体裁剪
            * 设定这个物件是否具有 视锥体裁剪功能，为否的话，将永远不参加场景渲染剔除树，无论是否在显示范围内都会进行相关的渲染逻辑运算
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.enableCut = true;
            /**
            * @language zh_CN
            * 父亲节点
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.parent = null;
            /**
            * @language zh_CN
            * 子对象列表
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.childs = new Array();
            /**
            * @language zh_CN
            * 动作对象，控制骨骼动画
            * 可拓展的动画功能属性，动画功能的驱动类总接口
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.animation = null;
            /**
            * @language zh_CN
            * 网格信息
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.geometry = null;
            /**
            * @language zh_CN
            * 材质信息
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.material = null;
            /**
            * @language zh_CN
            * 对象模型包围盒
            * 每个场景物件都需要有的 包围盒子，可以自定义包围盒形状大小，也可以根据模型本身生成
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.box = new egret3d.CubeBoxBound();
            /**
            * @language zh_CN
            * 鼠标检测数据
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.pickerData = new egret3d.PickResult();
            /**
            * @language zh_CN
            * 是否控制，当摄像机被绑定摄像机动画时，这个值为false.
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.isController = true;
            /**
            * @language zh_CN
            * 是否可见
            * 设置渲染是否显示的快速通道，在渲染列表中，但是不进行渲染，但是进行逻辑运算
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.isVisible = true;
            /**
            * @language zh_CN
            * 是否关闭
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.isDisable = false;
            /**
            * @language zh_CN
            * 鼠标拣选类型
            * 设置鼠标的拣选类型，可通过 PickType来进行设置
            * 快速拣选默认使用 正方形包围盒子
            * 高精度型需要 PositionPick ， uv pick 等
            * @see egret3d.PickType
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.pickType = PickType.BoundPick;
            this.id = ++Object3D.s_id;
        }
        Object.defineProperty(Object3D.prototype, "position", {
            /**
            * @language zh_CN
            * 返回位移
            * 获取容器的坐标位置，基于父节点的位置坐标
            * @returns 位移
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos;
            },
            /**
            * @language zh_CN
            * 设置位移
            * 设置基于父节点的位置坐标，当父容器发生变化时，子节点也会变化
            * @param vec 位移
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (vec) {
                this.updateTransformChange(true);
                this._pos.copyFrom(vec);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotation", {
            /**
            * @language zh_CN
            * 返回旋转
            * 获取容器的旋转信息，基于父节点的旋转信息 欧拉角信息
            * @returns 旋转 欧拉角信息
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot;
            },
            /**
            * @language zh_CN
            * 设置旋转
            * 设置基于父节点的旋转信息 欧拉角信息，当父容器发生变化时，子节点也会变化
            * @param vec 旋转 欧拉角信息
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._rot.x = value.x;
                this._rot.y = value.y;
                this._rot.z = value.z;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "orientation", {
            /**
            * @language zh_CN
            * 返回旋转
            * 返回 基于四元素的旋转信息
            * @returns 旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._orientation;
            },
            /**
            * @language zh_CN
            * 设置旋转
            * 设置旋转 基于四元素 旋转信息，当父容器发生变化时，子节点也会变化
            * @param value 旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._orientation.copyFrom(value);
                this._orientation.toEulerAngles(this._rot);
                this._angle = this._orientation.toAxisAngle(this._axis);
                this.updateTransformChange(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scale", {
            /**
            * @language zh_CN
            * 返回缩放
            * 返回基于父容器的缩放信息
            * @returns 缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca;
            },
            /**
            * @language zh_CN
            * 设置缩放
            * 设置基于父容器的缩放信息，当父容器发生变化时，子节点也会变化
            * @param vec 缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                this.updateTransformChange(true);
                this._sca = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "x", {
            /**
            * @language zh_CN
            * 返回x坐标
            * 返回基于父容器的位置坐标信息值
            * @returns x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos.x;
            },
            /**
            * @language zh_CN
            * 设置x坐标
            * 设置基于父容器的位置信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value x坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._pos.x == value)
                    return;
                this._pos.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "y", {
            /**
            * @language zh_CN
            * 返回y坐标
            *
            * 返回基于父容器的位置坐标信息值
            * @returns y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos.y;
            },
            /**
            * @language zh_CN
            * 设置y坐标
            *
            * 设置基于父容器的位置信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value y坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._pos.y == value)
                    return;
                this._pos.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "z", {
            /**
            * @language zh_CN
            * 返回z坐标
            *
            * 返回基于父容器的位置坐标信息值
            * @returns z坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._pos.z;
            },
            /**
            * @language zh_CN
            * 设置z坐标
            *
            * 设置基于父容器的位置信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value z坐标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._pos.z == value)
                    return;
                this._pos.z = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotationX", {
            /**
            * @language zh_CN
            * 返回x旋转
            *
            * 返回基于父容器的位置旋转信息值
            * @returns x旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot.x;
            },
            /**
            * @language zh_CN
            * 设置x轴旋转
            *
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value x轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._rot.x == value)
                    return;
                this._rot.x = value;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this._angle = this._orientation.toAxisAngle(this._axis);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotationY", {
            /**
            * @language zh_CN
            * 返回y旋转
            *
            * 返回基于父容器的位置旋转信息值
            * @returns y旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot.y;
            },
            /**
            * @language zh_CN
            * 设置y轴旋转
            *
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value y轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._rot.y == value)
                    return;
                this._rot.y = value;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this._angle = this._orientation.toAxisAngle(this._axis);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotationZ", {
            /**
            * @language zh_CN
            * 返回z旋转
            *
            * 返回基于父容器的位置旋转信息值
            * @returns z旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rot.z;
            },
            /**
            * @language zh_CN
            * 设置z轴旋转
            *
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value z轴旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._rot.z == value)
                    return;
                this._rot.z = value;
                this._orientation.fromEulerAngles(this._rot.x, this._rot.y, this._rot.z);
                this._angle = this._orientation.toAxisAngle(this._axis);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleX", {
            /**
            * @language zh_CN
            * 返回x缩放
            * 返回基于父容器的缩放信息值
            * @returns x缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca.x;
            },
            /**
            * @language zh_CN
            * 设置x轴缩放
            *
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value x轴缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._sca.x == value)
                    return;
                this._sca.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleY", {
            /**
            * @language zh_CN
            * 返回y缩放
            * 返回基于父容器的缩放信息值
            * @returns y缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca.y;
            },
            /**
            * @language zh_CN
            * 设置y轴缩放
            *
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value y轴缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._sca.y == value)
                    return;
                this._sca.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleZ", {
            /**
            * @language zh_CN
            * 返回z缩放
            * 返回基于父容器的缩放信息值
            * @returns z缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sca.z;
            },
            /**
            * @language zh_CN
            * 设置z轴缩放
            *
            * 设置基于父容器的旋转信息，当父容器发生变化时，子节点也会变化，值不变
            * @param value z轴缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this.updateTransformChange(true);
                if (this._sca.z == value)
                    return;
                this._sca.z = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 以axis轴为中心进行旋转
        * 设置基于父容器的旋转信息，数值通过axis的角度进行设置。当父容器发生变化时，子节点也会变化，值不变
        * @param axis 中心轴
        * @param angle 旋转的角度
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.setRotationFromAxisAngle = function (axis, angle) {
            axis.normalize();
            this.updateTransformChange(true);
            this._orientation.fromAxisAngle(axis, angle);
            this._orientation.toEulerAngles(this._rot);
            this._axis.copyFrom(axis);
            this._angle = angle;
        };
        Object.defineProperty(Object3D.prototype, "modelMatrix", {
            /**
            * @language zh_CN
            * 返回 object 世界渲染矩阵
            * 如果有父亲节点对象的话，要乘以父对象的变换.
            * @returns object 世界渲染矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this._transformChange = false;
                    this.updateModleMatrix();
                }
                return this._modeMatrix3D;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 返回 object 世界渲染矩阵
        * 如果有父亲节点对象的话，要乘以父对象的变换.
        * @private
        * @returns object 世界渲染矩阵
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.updateModleMatrix = function () {
            if (this.parent != null) {
                var parentOrientation = this.parent.globalOrientation;
                this._globalOrientation.multiply(parentOrientation, this._orientation);
                this._globalOrientation.toEulerAngles(this._globalRot);
                var parentScale = this.parent.globalScale;
                this._globalSca.copyFrom(parentScale.multiply(this._sca));
                parentOrientation.rotatePoint(parentScale.multiply(this._pos), this._globalPos);
                this._globalPos.copyFrom(this._globalPos.add(this.globalPosition));
            }
            else {
                this._globalOrientation = this._orientation;
                this._globalPos = this._pos;
                this._globalSca = this._sca;
                this._globalRot = this._rot;
            }
            //this._modeMatrix3D.recompose([this._globalPos, this._globalRot, this._globalSca]);
            this._modeMatrix3D.makeTransform(this._globalPos, this._globalSca, this._globalOrientation);
            this.box.Transform = this._modeMatrix3D;
            this.onUpdateTransform();
        };
        Object3D.prototype.onUpdateTransform = function () {
        };
        Object.defineProperty(Object3D.prototype, "globalPosition", {
            /**
            * @language zh_CN
            * 返回 object 世界位置
            * 返回世界坐标系的 全局位置坐标
            * @returns object 世界位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._globalPos;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalRotation", {
            /**
            * @language zh_CN
            * 返回 object 世界旋转
            * 返回世界坐标系的 全局旋转信息
            * @returns object 世界旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._globalRot;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalScale", {
            /**
            * @language zh_CN
            * 返回 object 世界缩放
            * 返回世界坐标系的 全局缩放信息
            * @returns object 世界缩放
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._globalSca;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "globalOrientation", {
            /**
            * @language zh_CN
            * 返回 object 世界旋转
            * 返回世界坐标系的 全局旋转信息，数据类型是 四元素
            * @returns object 世界旋转
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._transformChange) {
                    this.modelMatrix;
                }
                return this._globalOrientation;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 增加一个子对象,并返回当前子对象
        * 在容器中添加子对象，如果有显示接口的，将会放到场景显示树种进行渲染逻辑运算，及渲染
        * @param child 增加的子对象
        * @returns 子对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.addChild = function (child) {
            child.updateTransformChange(true);
            Object3D.renderListChange = true;
            this.childs.push(child);
            child.parent = this;
            return child;
        };
        /**
        * @language zh_CN
        * 增加一个子对象,并返回当前子对象
        * 在容器中添加子对象，如果有显示接口的，将会放到场景显示树种进行渲染逻辑运算，及渲染
        * @param child 增加的子对象
        * @param index 子对象的下标
        * @returns 子对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.addChildAt = function (child, index) {
            child.updateTransformChange(true);
            if (index < 0) {
                this.childs.splice(0, 0, child);
            }
            else if (index >= this.childs.length) {
                this.childs.push(child);
            }
            else {
                this.childs.splice(index, 0, child);
            }
            child.parent = this;
            return child;
        };
        /**
        * @language zh_CN
        * 返回下标为index的子对象
        * @private
        * @param index 子对象下标
        * @returns 如果有就返回子对象,否则就返回null.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.getChildAt = function (index) {
            if (index < 0 || index >= this.childs.length)
                return null;
            return this.childs[index];
        };
        /**
        * @language zh_CN
        * @private
        * 返回子对角child的下标
        * @param child 子对象
        * @returns 如果有就返回子对象的下标,否则就返回-1.
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.getChildIndex = function (child) {
            for (var index = 0; index < this.childs.length; ++index) {
                if (this.childs[index] != child) {
                    continue;
                }
                return index;
            }
            return -1;
        };
        /**
        * @language zh_CN
        * 移除child子对象 并返回
        * 移除显示列表中的指定对象，如果为空将会返回
        * @param child 子对象
        * @returns 如果成功就返回child,否则返回null
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.removeChild = function (child) {
            for (var index = 0; index < this.childs.length; ++index) {
                if (this.childs[index] != child) {
                    continue;
                }
                child.parent = null;
                this.childs.splice(index, 1);
                return child;
            }
            return null;
        };
        /**
        * @language zh_CN
        * 移除下标为index的子对象 并返回
        * @private
        * @param index 子对象的下标
        * @returns 如果成功就返回child,否则返回null
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.removeChildAt = function (index) {
            if (index < 0 || index >= this.childs.length)
                return null;
            var object3D = this.childs[index];
            object3D.parent = null;
            this.childs.splice(index, 1);
            return object3D;
        };
        /**
        * @language zh_CN
        * 设置子对象的下标
        * @private
        * @param child 子对象
        * @param index 子对象的下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.setChildIndex = function (child, index) {
            for (var i = 0; i < this.childs.length; ++i) {
                if (this.childs[i] != child) {
                    continue;
                }
                if (i == index) {
                    return;
                }
                else if (index > i) {
                    for (var m = i; m > index; --m) {
                        this.childs[m] = this.childs[m - 1];
                    }
                }
                else if (index < i) {
                    for (var m = i; m < index; ++m) {
                        this.childs[m] = this.childs[m + 1];
                    }
                }
                this.childs[index] = child;
                return;
            }
        };
        /**
        * @language zh_CN
        * @private
        * 交换子对象的位置
        * @param child1 子对象1
        * @param child2 子对象2
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.swapChildren = function (child1, child2) {
            var index1 = 0, index2 = 0;
            for (; index1 < this.childs.length; ++index1) {
                if (this.childs[index1] != child1) {
                    continue;
                }
                for (; index2 < this.childs.length; ++index2) {
                    if (this.childs[index2] != child2) {
                        continue;
                    }
                    var tmp = this.childs[index1];
                    this.childs[index1] = this.childs[index2];
                    this.childs[index2] = tmp;
                    break;
                }
                return;
            }
        };
        /**
        * @language zh_CN
        * @private
        * 交换子对象的位置
        * @param index1 子对象1下标
        * @param index2 子对象2下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.swapChildrenAt = function (index1, index2) {
            if (index1 < 0 || index1 >= this.childs.length)
                return;
            if (index2 < 0 || index2 >= this.childs.length)
                return;
            var tmp = this.childs[index1];
            this.childs[index1] = this.childs[index2];
            this.childs[index2] = tmp;
        };
        /**
        * @language zh_CN
        * @private
        * @param wireframe 网格对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.bindWireframe = function (wireframe) {
            wireframe.modleMatrix = this._modeMatrix3D;
        };
        /**
        * @language zh_CN
        * 当前对象对视位置
        * @private
        * @param pos 对象的位置
        * @param target 目标的位置
        * @param up 向上的方向
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.lookAt = function (pos, target, up) {
            if (up === void 0) { up = egret3d.Vector3D.Y_AXIS; }
        };
        Object.defineProperty(Object3D.prototype, "lookAtPosition", {
            /**
            * @language zh_CN
            * 返回目标的位置
            *
            * @private
            * @returns 目标的位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return new egret3d.Vector3D();
            },
            enumerable: true,
            configurable: true
        });
        Object3D.prototype.updateTransformChange = function (change) {
            this._transformChange = change;
            ///Octree.getInstance().checkObject3D(obj);
            for (var i = 0; i < this.childs.length; ++i) {
                this.childs[i].updateTransformChange(change);
            }
        };
        /**
        * @language zh_CN
        * 当前对象数据更新
        * @private
        * @param camera 当前渲染的摄相机
        * @param time 当前时间
        * @param delay 每帧时间间隔
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.update = function (camera, time, delay) {
        };
        /**
        * @language zh_CN
        * 返回对象的屏幕坐标
        * 获取当前物体的屏幕坐标值，一般用来指定屏幕相关的ui绑定及其他功能
        * @param camera 对象渲染的摄像机
        * @returns 对象的屏幕坐标
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.getScreenPosition = function (camera) {
            this._mat.copyFrom(camera.viewProjectionMatrix);
            this._mat.append(this.modelMatrix);
            return this._mat.transformVector(this.globalPosition);
        };
        /**
        * @language zh_CN
        * 释放所有数据
        * 是否内存中的相关数据连接引用，移除逻辑运算，从主渲染刘表中挪出
        * @version Egret 3.0
        * @platform Web,Native
        */
        Object3D.prototype.dispose = function () {
            if (this.parent)
                this.parent.removeChild(this);
            if (this.geometry) {
                this.geometry.dispose();
                this.geometry = null;
            }
            if (this.material) {
                this.material.dispose();
                this.material = null;
            }
            for (var i = 0; i < this.childs.length; i++) {
                this.childs[i].dispose();
            }
        };
        /**
         * @private
         * @language zh_CN
         * 当前对象名
         * @version Egret 3.0
         * @platform Web,Native
         */
        Object3D.renderListChange = true;
        Object3D.s_id = 0;
        return Object3D;
    })(egret3d.EventDispatcher);
    egret3d.Object3D = Object3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Billboard
     * @classdesc
     * 公告板渲染对象 始终面朝摄像机的面板
     *
     * 示例:创建一个棋盘格材质的公告板在场景中
     * @includeExample core/node/Billboard.ts
     *
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Billboard = (function (_super) {
        __extends(Billboard, _super);
        /**
         * @language zh_CN
         * 指定材质，和公告板宽、高，构建一个公告板
         * @param material 渲染材质
         * @param width 公告板宽
         * @param height 公告板高
         * @version Egret 3.0
         * @platform Web,Native
         */
        function Billboard(material, width, height) {
            if (width === void 0) { width = 100; }
            if (height === void 0) { height = 100; }
            _super.call(this);
            this.material = material;
            this.geometry = new egret3d.PlaneGeometry(width, height);
            this.box.fillBox(this.geometry.minPos, this.geometry.maxPos);
        }
        /**
        * @language zh_CN
        * 数据更新，不前对象的旋转和摄像机的旋转一致
        * @param camera 当前渲染的摄相机
        * @param time 当前时间
        * @param delay 间隔时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        Billboard.prototype.update = function (camera, time, delay) {
            this._qut.fromEulerAngles(-90, 0, 0);
            this._qut.multiply(camera.orientation, this._qut);
            this.orientation = this._qut;
        };
        return Billboard;
    })(egret3d.Object3D);
    egret3d.Billboard = Billboard;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.SphereSky
    * @classdesc
    * 天空球
    * 球形的天空盒子，需要sphere的360全景照片，可进行全景照片和video的球形显示
    * @version Egret 3.0
    * @platform Web,Native
    */
    var SphereSky = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param tex1 天空球贴图
        * @version Egret 3.0
        * @platform Web,Native
        */
        function SphereSky(tex1) {
            this.normalMatrix = new egret3d.Matrix4_4();
            this.px = 0;
            this.py = 0;
            this.pz = 0;
            this.offest = new egret3d.Vector3D();
            this.skyTexture = tex1;
            this.usage = new egret3d.MethodUsageData();
            this.vsShader = new egret3d.GLSL.ShaderBase(null, this.usage);
            this.fsShader = new egret3d.GLSL.ShaderBase(null, this.usage);
            this.setShader("spheresky_vertex", "spheresky_fragment");
            this.skyMatrix = new egret3d.Matrix4_4();
        }
        /**
        * @language zh_CN
        * 设置渲染用的shader文件名字
        * @param vsName vs文件名
        * @param fsName fs文件名
        * @version Egret 3.0
        * @platform Web,Native
        */
        SphereSky.prototype.setShader = function (vsName, fsName) {
            this.vsShader.addShader(vsName);
            this.fsShader.addShader(fsName);
            this.vsShaderSource = this.vsShader.getShaderSource();
            this.fsShaderSource = this.fsShader.getShaderSource();
        };
        SphereSky.prototype.rebuild = function (context3D) {
            var vertexShader = context3D.creatVertexShader(this.vsShaderSource);
            var fragmentShader = context3D.creatFragmentShader(this.fsShaderSource);
            this.usage.program3D = context3D.creatProgram(vertexShader, fragmentShader);
            if (this.usage.program3D) {
                context3D.setProgram(this.usage.program3D);
            }
            this.sphereGeometry = this.sphereGeometry || new egret3d.SphereGeometry(25);
            if (!this.sphereGeometry.sharedVertexBuffer) {
                this.sphereGeometry.sharedVertexBuffer = context3D.creatVertexBuffer(this.sphereGeometry.verticesData);
                this.sphereGeometry.numberOfVertices = this.sphereGeometry.verticesData.length / this.sphereGeometry.vertexAttLength;
                this.sphereGeometry.vertexSizeInBytes = this.sphereGeometry.positionSize * Float32Array.BYTES_PER_ELEMENT +
                    3 * Float32Array.BYTES_PER_ELEMENT +
                    3 * Float32Array.BYTES_PER_ELEMENT +
                    4 * Float32Array.BYTES_PER_ELEMENT +
                    2 * Float32Array.BYTES_PER_ELEMENT +
                    2 * Float32Array.BYTES_PER_ELEMENT; ///uv2 60
                this.sphereGeometry.sharedIndexBuffer = context3D.creatIndexBuffer(this.sphereGeometry.indexData);
            }
            this.usage.attribute_position.uniformIndex = context3D.getShaderAttribLocation(this.usage.program3D, "attribute_position");
            this.usage.attribute_normal.uniformIndex = context3D.getShaderAttribLocation(this.usage.program3D, "attribute_normal");
            this.usage.attribute_uv0.uniformIndex = context3D.getShaderAttribLocation(this.usage.program3D, "attribute_uv0");
            this.usage.uniform_ProjectionMatrix.uniformIndex = context3D.getUniformLocation(this.usage.program3D, "uniform_ProjectionMatrix");
            this.usage.uniform_ModelMatrix.uniformIndex = context3D.getUniformLocation(this.usage.program3D, "uniform_ModelMatrix");
            this.usage.uniform_normalMatrix.uniformIndex = context3D.getUniformLocation(this.usage.program3D, "uniform_normalMatrix");
            ///--------texture----------------
            var sampler2D;
            for (var index in this.usage.sampler2DList) {
                sampler2D = this.usage.sampler2DList[index];
                if (sampler2D.varName == "sky_texture")
                    sampler2D.texture = this.skyTexture;
                sampler2D.uniformIndex = context3D.getUniformLocation(this.usage.program3D, sampler2D.varName);
            }
        };
        /**
        * @language zh_CN
        * 提交数据给GPU渲染当前天空球
        * @param context3D 设备上下文
        * @param camera 渲染时的相机
        * @version Egret 3.0
        * @platform Web,Native
        */
        SphereSky.prototype.draw = function (context3D, camera) {
            if (!this.usage.program3D)
                this.rebuild(context3D);
            context3D.setProgram(this.usage.program3D);
            context3D.gl.enable(egret3d.Egret3DDrive.CULL_FACE);
            context3D.gl.cullFace(egret3d.Egret3DDrive.FRONT);
            context3D.gl.enable(egret3d.Egret3DDrive.BLEND);
            context3D.gl.blendFunc(egret3d.Egret3DDrive.ONE, egret3d.Egret3DDrive.ZERO);
            context3D.bindVertexBuffer(this.sphereGeometry.sharedVertexBuffer);
            context3D.vertexAttribPointer(this.usage.program3D, this.usage.attribute_position.uniformIndex, 3, egret3d.Egret3DDrive.FLOAT, false, this.sphereGeometry.vertexSizeInBytes, 0);
            context3D.vertexAttribPointer(this.usage.program3D, this.usage.attribute_uv0.uniformIndex, 2, egret3d.Egret3DDrive.FLOAT, false, this.sphereGeometry.vertexSizeInBytes, 52);
            this.skyMatrix.identity();
            this.skyMatrix.appendTranslation(camera.x, camera.y, camera.z);
            context3D.uniformMatrix4fv(this.usage.uniform_ProjectionMatrix.uniformIndex, false, camera.viewProjectionMatrix.rawData);
            context3D.uniformMatrix4fv(this.usage.uniform_ModelMatrix.uniformIndex, false, this.skyMatrix.rawData);
            ///--------texture----------------
            var sampler2D;
            for (var index in this.usage.sampler2DList) {
                sampler2D = this.usage.sampler2DList[index];
                sampler2D.texture.upload(context3D);
                context3D.setTexture2DAt(sampler2D.activeTextureIndex, sampler2D.uniformIndex, sampler2D.index, sampler2D.texture.texture);
            }
            context3D.drawElement(egret3d.DrawMode.TRIANGLES, this.sphereGeometry.sharedIndexBuffer, 0, this.sphereGeometry.numItems);
        };
        return SphereSky;
    })();
    egret3d.SphereSky = SphereSky;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Sky
    * @classdesc
    * 场景中天空盒子，是6面体cube，以6张无缝结合的贴图构成.
    *
    * @see egret3d.texture.Skytexture
    *
    * 示例:
    * @version Egret 3.0
    * @platform Web,Native
    * @includeExample core/node/Sky.ts
    */
    var Sky = (function () {
        /**
        * @language zh_CN
        * 构建一个天空盒子对象
        * @param skyTexture 天空盒子贴图
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Sky(skyTexture) {
            this.px = 0;
            this.py = 0;
            this.pz = 0;
            this.offest = new egret3d.Vector3D();
            this.skyTexture = skyTexture;
            this.usage = new egret3d.MethodUsageData();
            this.vsShader = new egret3d.GLSL.ShaderBase(null, this.usage);
            this.fsShader = new egret3d.GLSL.ShaderBase(null, this.usage);
            this.setShader("sky_vertex", "sky_fragment");
            this.skyMatrix = new egret3d.Matrix4_4();
            this.modelMatrix = new egret3d.Matrix4_4();
        }
        /**
        * @language zh_CN
        * 设置渲染用的shader文件名字
        * @param vsName vs文件名
        * @param fsName fs文件名
        * @version Egret 3.0
        * @platform Web,Native
        */
        Sky.prototype.setShader = function (vsName, fsName) {
            this.vsShader.addShader(vsName);
            this.fsShader.addShader(fsName);
            this.vsShaderSource = this.vsShader.getShaderSource();
            this.fsShaderSource = this.fsShader.getShaderSource();
        };
        Sky.prototype.rebuild = function (context3D) {
            var vertexShader = context3D.creatVertexShader(this.vsShaderSource);
            var fragmentShader = context3D.creatFragmentShader(this.fsShaderSource);
            this.usage.program3D = context3D.creatProgram(vertexShader, fragmentShader);
            if (this.usage.program3D) {
                context3D.setProgram(this.usage.program3D);
            }
            this.cubeGeometry = this.cubeGeometry || new egret3d.CubeGeometry();
            if (!this.cubeGeometry.sharedVertexBuffer) {
                this.cubeGeometry.sharedVertexBuffer = context3D.creatVertexBuffer(this.cubeGeometry.verticesData);
                this.cubeGeometry.numberOfVertices = this.cubeGeometry.verticesData.length / this.cubeGeometry.vertexAttLength;
                this.cubeGeometry.vertexSizeInBytes = this.cubeGeometry.positionSize * Float32Array.BYTES_PER_ELEMENT +
                    3 * Float32Array.BYTES_PER_ELEMENT +
                    3 * Float32Array.BYTES_PER_ELEMENT +
                    4 * Float32Array.BYTES_PER_ELEMENT +
                    2 * Float32Array.BYTES_PER_ELEMENT +
                    2 * Float32Array.BYTES_PER_ELEMENT; ///uv2 60
                this.cubeGeometry.sharedIndexBuffer = context3D.creatIndexBuffer(this.cubeGeometry.indexData);
            }
            this.usage.attribute_position.uniformIndex = context3D.getShaderAttribLocation(this.usage.program3D, "attribute_position");
            this.usage.uniform_ProjectionMatrix.uniformIndex = context3D.getUniformLocation(this.usage.program3D, "uniform_ProjectionMatrix");
            this.usage.uniform_ModelMatrix.uniformIndex = context3D.getUniformLocation(this.usage.program3D, "uniform_ModelMatrix");
            ///--------texture----------------
            var sampler3D;
            for (var index in this.usage.sampler3DList) {
                sampler3D = this.usage.sampler3DList[index];
                sampler3D.uniformIndex = context3D.getUniformLocation(this.usage.program3D, sampler3D.varName);
                if (sampler3D.varName == "sky_texture") {
                    sampler3D.texture = this.skyTexture;
                }
            }
        };
        /**
        * @language zh_CN
        * 提交数据给GPU渲染当前天空盒子
        * @param context3D 设备上下文
        * @param camera 渲染时的相机
        * @version Egret 3.0
        * @platform Web,Native
        */
        Sky.prototype.draw = function (context3D, camera) {
            if (!this.usage.program3D)
                this.rebuild(context3D);
            context3D.setProgram(this.usage.program3D);
            context3D.gl.enable(egret3d.Egret3DDrive.CULL_FACE);
            context3D.gl.cullFace(egret3d.Egret3DDrive.FRONT);
            context3D.bindVertexBuffer(this.cubeGeometry.sharedVertexBuffer);
            context3D.vertexAttribPointer(this.usage.program3D, this.usage.attribute_position.uniformIndex, 3, egret3d.Egret3DDrive.FLOAT, false, this.cubeGeometry.vertexSizeInBytes, 0);
            this.skyMatrix.identity();
            this.skyMatrix.appendTranslation(camera.x, camera.y, camera.z);
            context3D.uniformMatrix4fv(this.usage.uniform_ProjectionMatrix.uniformIndex, false, camera.viewProjectionMatrix.rawData);
            context3D.uniformMatrix4fv(this.usage.uniform_ModelMatrix.uniformIndex, false, this.skyMatrix.rawData);
            ///--------texture----------------
            var sampler3D;
            for (var index in this.usage.sampler3DList) {
                sampler3D = this.usage.sampler3DList[index];
                sampler3D.texture.upload(context3D);
                context3D.setCubeTextureAt(sampler3D.activeTextureIndex, sampler3D.uniformIndex, sampler3D.index, sampler3D.texture.cubeTexture);
            }
            context3D.drawElement(egret3d.DrawMode.TRIANGLES, this.cubeGeometry.sharedIndexBuffer, 0, this.cubeGeometry.numItems);
        };
        return Sky;
    })();
    egret3d.Sky = Sky;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.Entity
    * @classdesc
    * 3d空间中的实体对象 extends Object3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Entity = (function (_super) {
        __extends(Entity, _super);
        /**
        * @language zh_CN
        * constructor
        */
        function Entity() {
            _super.call(this);
        }
        return Entity;
    })(egret3d.Object3D);
    egret3d.Entity = Entity;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * 摄像机类型
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (CameraType) {
        /**
        * 透视投影
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraType[CameraType["perspective"] = 0] = "perspective";
        /**
        * 正交投影
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraType[CameraType["orthogonal"] = 1] = "orthogonal";
        /**
        * VR投影
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraType[CameraType["VR"] = 2] = "VR";
    })(egret3d.CameraType || (egret3d.CameraType = {}));
    var CameraType = egret3d.CameraType;
    ;
    /**
    * VR类型
    * @private
    * @version Egret 3.0
    * @platform Web,Native
    */
    (function (VRType) {
        /**
        * 左眼
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        VRType[VRType["left"] = 0] = "left";
        /**
        * 右眼
        * @private
        * @version Egret 3.0
        * @platform Web,Native
        */
        VRType[VRType["right"] = 1] = "right";
    })(egret3d.VRType || (egret3d.VRType = {}));
    var VRType = egret3d.VRType;
    ;
    /**
    * @class egret3d.Camera3D
    * @classdesc
    * 相机数据处理，生成3D摄相机。
    * 渲染场景从摄像机视点到缓冲区
    * 相机分为透视摄像机、正交摄像机、VR摄像机
    *
    * @see egret3d.core.node.Entity
    * @see egret3d.core.traverse.Frustum
    * @see egret3d.geom.Matrix4_4
    *
    * @includeExample camera/Camera3D.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Camera3D = (function (_super) {
        __extends(Camera3D, _super);
        /**
         * @language zh_CN
         * constructor
         * @param cameraType 相机类型
         * @version Egret 3.0
         * @platform Web,Native
         */
        function Camera3D(cameraType) {
            if (cameraType === void 0) { cameraType = CameraType.perspective; }
            _super.call(this);
            /**
             * @language zh_CN
             * 相机投影矩阵
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.projectMatrix = new egret3d.Matrix4_4();
            /**
             * @language zh_CN
             * 相机的视椎体，用来检测是否在当前相机可视范围内
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.frustum = new egret3d.Frustum();
            this._viewPort = new egret3d.Rectangle();
            this._scissorRect = new egret3d.Rectangle();
            this._aspectRatio = 1.0;
            this._fovY = 45.0;
            this._near = 1;
            this._far = 10000.0;
            this.temp = new egret3d.Matrix4_4();
            this._lookAtPosition = new egret3d.Vector3D();
            this._up = new egret3d.Vector3D(0, 1, 0);
            this._cameraType = 0;
            this._cameraMatrixChange = false;
            this._viewMatrix = new egret3d.Matrix4_4();
            this._tempQuat = new egret3d.Quaternion();
            this.cameraType = cameraType;
        }
        Object.defineProperty(Camera3D.prototype, "cameraType", {
            /**
             * @language zh_CN
             * 设置相机类型
             * @param cameraType 相机类型
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (cameraType) {
                this._cameraType = cameraType;
                switch (cameraType) {
                    case CameraType.orthogonal:
                        this.cameraMatrix = this.modelMatrix;
                        ///this.projectMatrix.ortho(this._viewPort.width, this._viewPort.height, this._near, this._far);
                        this.updataOrth();
                        break;
                    case CameraType.perspective:
                        this.cameraMatrix = this.modelMatrix;
                        this.projectMatrix.perspective(this._fovY, this._aspectRatio, this._near, this._far);
                        break;
                    case CameraType.VR:
                        this.cameraMatrix = this.modelMatrix;
                        this.projectMatrix.perspective(this._fovY, 1.0, this._near, this._far);
                        this.eyeMatrix = this.eyeMatrix || new egret3d.EyesMatrix();
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         * 打开VR相机
         * @param cameraType 相机类型
         * @param vrType VR类型
         * @version Egret 3.0
         * @platform Web,Native
         */
        Camera3D.prototype.tap = function (cameraType, vrType) {
            if (vrType === void 0) { vrType = null; }
            if (cameraType == CameraType.VR) {
                this.eyeMatrix.updte(this.modelMatrix);
                if (vrType == VRType.left) {
                    this.cameraMatrix = this.eyeMatrix.leftEyeMatrix;
                }
                else if (vrType == VRType.right) {
                    this.cameraMatrix = this.eyeMatrix.rightEyeMatrix;
                }
            }
            else {
                this.cameraMatrix = this.modelMatrix;
            }
        };
        Object.defineProperty(Camera3D.prototype, "aspectRatio", {
            /**
            * @language zh_CN
            * 返回相机横纵比
            *
            * @returns 横纵比
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._aspectRatio;
            },
            /**
            * @language zh_CN
            * 设置相机横纵比
            *
            * @param value 横纵比
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._aspectRatio != value) {
                    this._aspectRatio = value;
                    this.cameraType = this._cameraType;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "fieldOfView", {
            /**
            * @language zh_CN
            * 返回相机fovY
            *
            * @returns fovY
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._fovY;
            },
            /**
            * @language zh_CN
            * 设置相机fovY
            *
            * @param value fovY
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._fovY != value) {
                    this._fovY = value;
                    this.cameraType = this._cameraType;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "near", {
            /**
            * @language zh_CN
            * 返回相机近截面
            *
            * @returns 近截面
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._near;
            },
            /**
            * @language zh_CN
            * 设置相机近截面
            *
            * @param value 近截面
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._near != value) {
                    this._near = value;
                    this.cameraType = this._cameraType;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "far", {
            /**
            * @language zh_CN
            * 返回相机远截面
            *
            * @returns 远截面
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._far;
            },
            /**
            * @language zh_CN
            * 设置相机远截面
            *
            * @param value 远截面
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._far != value) {
                    this._far = value;
                    this.cameraType = this._cameraType;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "viewProjectionMatrix", {
            /**
            * @language zh_CN
            * 返回相机视图投影矩阵
            *
            * @returns 视图投影矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                this.cameraMatrix = this.modelMatrix;
                this.temp.copyFrom(this.cameraMatrix);
                this.temp.invert();
                this.temp.append(this.projectMatrix);
                return this.temp;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @language zh_CN
         * @param x number
         * @param y number
         * @param width number
         * @param height number
         * @version Egret 3.0
         * @platform Web,Native
         */
        Camera3D.prototype.updateScissorRect = function (x, y, width, height) {
            this._scissorRect.x = x;
            this._scissorRect.y = y;
            this._scissorRect.width = width;
            this._scissorRect.height = height;
        };
        /**
         * @language zh_CN
         * 更新视口
         * @param x number
         * @param y number
         * @param width number
         * @param height number
         * @version Egret 3.0
         * @platform Web,Native
         */
        Camera3D.prototype.updateViewport = function (x, y, width, height) {
            this._viewPort.x = x;
            this._viewPort.y = y;
            this._viewPort.width = width;
            this._viewPort.height = height;
        };
        /**
         * @language zh_CN
         * 当前对象对视位置
         * @param pos 对象的位置
         * @param target 目标的位置
         * @param up 向上的方向
         * @version Egret 3.0
         * @platform Web,Native
         */
        Camera3D.prototype.lookAt = function (pos, target, up) {
            if (up === void 0) { up = egret3d.Vector3D.Y_AXIS; }
            this.position = pos;
            this._lookAtPosition.copyFrom(target);
            this._up.copyFrom(up);
            this._viewMatrix.lookAt(this._pos, this._lookAtPosition, this._up);
            this._viewMatrix.invert();
            var prs = this._viewMatrix.decompose(egret3d.Orientation3D.QUATERNION);
            this._tempQuat.x = prs[1].x;
            this._tempQuat.y = prs[1].y;
            this._tempQuat.z = prs[1].z;
            this._tempQuat.w = prs[1].w;
            this.orientation = this._tempQuat;
        };
        Camera3D.prototype.onUpdateTransform = function () {
            this._viewMatrix.copyFrom(this._modeMatrix3D);
            this._viewMatrix.invert();
        };
        Object.defineProperty(Camera3D.prototype, "viewMatrix", {
            /**
             * @language zh_CN
             *
             * 相机视图矩阵
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._viewMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera3D.prototype, "lookAtPosition", {
            /**
             * @language zh_CN
             *
             * 相机目标点
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._lookAtPosition;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         * 更新正交矩阵
         * @version Egret 3.0
         * @platform Web,Native
         */
        Camera3D.prototype.updataOrth = function () {
            var _projectionHeight = 800;
            var raw = new Float32Array(16);
            var _yMax = _projectionHeight * .5;
            var _xMax = _yMax * this._aspectRatio;
            var left, right, top, bottom;
            ///return 
            if (this._scissorRect.x == 0 && this._scissorRect.y == 0 && this._scissorRect.width == this._viewPort.width && this._scissorRect.height == this._viewPort.height) {
                /// assume symmetric frustum
                left = -_xMax;
                right = _xMax;
                top = -_yMax;
                bottom = _yMax;
                raw[0] = 2 / (_projectionHeight * this._aspectRatio);
                raw[5] = 2 / _projectionHeight;
                raw[10] = 1 / (this._far - this._near);
                raw[14] = this._near / (this._near - this._far);
                raw[1] = raw[2] = raw[3] = raw[4] =
                    raw[6] = raw[7] = raw[8] = raw[9] =
                        raw[11] = raw[12] = raw[13] = 0;
                raw[15] = 1;
            }
            else {
                var xWidth = _xMax * (this._viewPort.width / this._scissorRect.width);
                var yHgt = _yMax * (this._viewPort.height / this._scissorRect.height);
                var center = _xMax * (this._scissorRect.x * 2 - this._viewPort.width) / this._scissorRect.width + _xMax;
                var middle = -_yMax * (this._scissorRect.y * 2 - this._viewPort.height) / this._scissorRect.height - _yMax;
                left = center - xWidth;
                right = center + xWidth;
                top = middle - yHgt;
                bottom = middle + yHgt;
                raw[0] = 2 * 1 / (right - left);
                raw[5] = -2 * 1 / (top - bottom);
                raw[10] = 1 / (this._far - this._near);
                raw[12] = (right + left) / (right - left);
                raw[13] = (bottom + top) / (bottom - top);
                raw[14] = this._near / (this.near - this.far);
                raw[1] = raw[2] = raw[3] = raw[4] =
                    raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
                raw[15] = 1;
            }
            this.projectMatrix.copyRawDataFrom(raw);
        };
        /**
         * @language zh_CN
         * 检测对象是否在相机视椎体内
         * @param object 需要体测的对象
         * @returns 成功返回true
         * @version Egret 3.0
         * @platform Web,Native
         */
        Camera3D.prototype.isVisibleToCamera = function (object) {
            if (this.frustum.inBox(object.box)) {
                return true;
            }
            return false;
        };
        return Camera3D;
    })(egret3d.Entity);
    egret3d.Camera3D = Camera3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.DirectLight
    * @classdesc
    * 灯光的基础类型
    * 所有的灯光基本要素 灯光的颜色，强度，位置，方向
    * 颜色的色值均是16进制 red:0xffff0000 argb的定义模式
    * 每个材质球所能最大使用的灯光建议别太多，能省则省，尤其是移动端，能用灯光缓存图 lightmap 最好
    * @see egret3d.Object3D
    * @see egret3d.LightGroup
    * @see egret3d.LightBase
    * @see egret3d.PointLight
    * @see egret3d.SportLight
    * @version Egret 3.0
    * @platform Web,Native
    */
    var LightBase = (function (_super) {
        __extends(LightBase, _super);
        function LightBase() {
            _super.call(this);
            /**
             *@language zh_CN
             *@private
             * 类型
             */
            this._lightType = -1;
            /**
             * @language zh_CN
             *@private
             * 环境颜色
             */
            this._ambient = new egret3d.Vector3D(1.0, 1.0, 1.0);
            /**
             * @language zh_CN
             *@private
             * 漫反射
             */
            this._diffuse = new egret3d.Vector3D(1.0, 1.0, 1.0);
            /**
            * @language zh_CN
            *@private
            * 背光颜色
            */
            this._halfColor = new egret3d.Vector3D(1.0, 1.0, 1.0);
            /**
             * @language zh_CN
             *@private
             * 镜面反射
             */
            this._specular = new egret3d.Vector3D(1.0, 1.0, 1.0);
            /**
             * @language zh_CN
             *@private
             */
            this._halfVector = new egret3d.Vector3D(1.0, 1.0, 1.0);
            /**
             * @language zh_CN
             *@private
             * @param value 强度
             */
            this._intensity = 1;
            /**
            *@language zh_CN
            *@private
            * @param value 背光强度
            */
            this._halfIntensity = 0.5;
            /**
             * @language zh_CN
             *@private
             */
            this._spotExponent = 1.1;
            /**
             * @language zh_CN
             *@private
             */
            this._spotCutoff = 0.7;
            /**
             * @language zh_CN
             *@private
             */
            this._spotCosCutoff = 0.1;
            /**
             * @language zh_CN
             *@private
             */
            this._constantAttenuation = 0.1;
            /**
             * @language zh_CN
             *@private
             */
            this._linearAttenuation = 0.1;
            /**
             * @language zh_CN
             *@private
             */
            this._quadraticAttenuation = 0.1;
            /**
             * @language zh_CN
             *@private
             */
            this._lightIndex = -1;
            /**
             * @language zh_CN
             *@private
             */
            this.len = 25;
            /**
             * @language zh_CN
             *@private
             */
            this._change = true;
        }
        Object.defineProperty(LightBase.prototype, "intensity", {
            /**
             * @language zh_CN
             * 得到灯光强度
             * 影响灯光的强弱显示，值的范围0~没有上限，但是值过大会导致画面过度曝光
             */
            get: function () {
                return this._intensity;
            },
            /**
             * @language zh_CN
             * 设置灯光强度
             * 影响灯光的强弱显示，值的范围0~没有上限，但是值过大会导致画面过度曝光
             */
            set: function (value) {
                if (this._intensity != value) {
                    this._intensity = value;
                    this._change = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "halfIntensity", {
            /**
             * @language zh_CN
             * 得到灯光强度
             * 影响灯光的强弱显示，值的范围0~没有上限，但是值过大会导致画面过度曝光
             */
            get: function () {
                return this._halfIntensity;
            },
            /**
            * @language zh_CN
            * 设置灯光强度
            * 影响灯光的强弱显示，值的范围0~没有上限，但是值过大会导致画面过度曝光
            */
            set: function (value) {
                if (this._halfIntensity != value) {
                    this._halfIntensity = value;
                    this._change = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "ambient", {
            /**
             * @language zh_CN
             * 获取 灯光环境颜色
             * 物体在未受到光的直接照射的地方 模拟间接环境光颜色，会影响背光面的颜色
             * return ambient  灯光环境颜色
             */
            get: function () {
                return 0;
            },
            /**
             * @language zh_CN
             * 设置灯光环境颜色
             * 物体在未受到光的直接照射的地方 模拟间接环境光颜色，会影响背光面的颜色
             */
            set: function (color) {
                this._ambient.w = (color >> 24 & 0xff) / 255;
                this._ambient.x = (color >> 16 & 0xff) / 255;
                this._ambient.y = (color >> 8 & 0xff) / 255;
                this._ambient.z = (color & 0xff) / 255;
                this._change = false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "diffuse", {
            /**
             * @language zh_CN
             * 设置灯光漫反射颜色
             * 直接影响最终灯光的颜色色值 16进制的颜色 例如 red：0xffff0000
             * 也可以通过 diffusePower 来改变这个值的总体强弱
             * return diffuse
             */
            get: function () {
                return 0;
            },
            /**
             * @language zh_CN
             * 设置灯光漫反射颜色
             * 直接影响最终灯光的颜色色值 16进制的颜色 例如 red：0xffff0000
             * 也可以通过 diffusePower 来改变这个值的总体强弱
             */
            set: function (color) {
                this._diffuse.w = (color >> 24 & 0xff) / 255;
                this._diffuse.x = (color >> 16 & 0xff) / 255;
                this._diffuse.y = (color >> 8 & 0xff) / 255;
                this._diffuse.z = (color & 0xff) / 255;
                this._change = false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightBase.prototype, "specular", {
            /**
             * @language zh_CN
             * 在灯光方向与物体和相机成一个反光角度的时候，就会产生反光，高光，而不同的物体会有不同的颜色色值，尤其是金属
             * 16进制的颜色 例如 red：0xffff0000
             * 也可以通过 specularPower 来改变这个值的总体强弱
             * return  灯光镜面高光反射颜色
             */
            get: function () {
                return 0;
            },
            /**
             * @language zh_CN
             * 设置灯光镜面高光反射颜色
             * 在灯光方向与物体和相机成一个反光角度的时候，就会产生反光，高光，而不同的物体会有不同的颜色色值，尤其是金属
             * 16进制的颜色 例如 red：0xffff0000
             * 也可以通过 specularPower 来改变这个值的总体强弱
             */
            set: function (color) {
                this._specular.w = (color >> 24 & 0xff) / 255;
                this._specular.x = (color >> 16 & 0xff) / 255;
                this._specular.y = (color >> 8 & 0xff) / 255;
                this._specular.z = (color & 0xff) / 255;
                this._change = false;
            },
            enumerable: true,
            configurable: true
        });
        LightBase.prototype.init = function () {
        };
        /**
         * @language zh_CN
         * @private
         * 更新灯光数据
         * @param index 灯光ID
         * @param lightData 灯光数据
         */
        LightBase.prototype.updateLightData = function (index, lightData) {
        };
        return LightBase;
    })(egret3d.Object3D);
    egret3d.LightBase = LightBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.DirectLight
    * @classdesc
    * 平行灯光
    * 平行光是一种只有方向，强弱度，没有大小范围的灯光，一般情况下，directlight 可以产生阴影
    * 如果要产生阴影 需要设置 egret3d.ShadowRender.castShadowLight = directLight; 及其他相关模型的设置
    *
    * @see egret3d.LightGroup
    * @see egret3d.LightBase
    * @see egret3d.PointLight
    * @see egret3d.SportLight
    * @includeExample lights/DirectLight.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var DirectLight = (function (_super) {
        __extends(DirectLight, _super);
        /**
        * @language zh_CN
        * @private
        * @param dir 光线的方向
        */
        function DirectLight(dir) {
            _super.call(this);
            dir.normalize();
            this._lightType = 0;
            this._rot.x = dir.x;
            this._rot.y = dir.y;
            this._rot.z = dir.z;
        }
        Object.defineProperty(DirectLight.prototype, "halfColor", {
            /**
            * @language zh_CN
            *
            * 背光颜色
            * 模拟间接光照而开发的背光，而不用去同时打两盏不同方向的组合灯光，可以优化显示效果
            * @param color 背光颜色色值
            */
            set: function (color) {
                this._halfColor.w = (color >> 24 & 0xff) / 255;
                this._halfColor.x = (color >> 16 & 0xff) / 255;
                this._halfColor.y = (color >> 8 & 0xff) / 255;
                this._halfColor.z = (color & 0xff) / 255;
                this._change = false;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         *
         * 是否产生阴影
         * 模拟间接光照而开发的背光，而不用去同时打两盏不同方向的组合灯光，可以优化显示效果
         * @param color 背光颜色色值
         */
        //public set castShadow(value: boolean) {
        //if (value )
        //    RttManager.getInstance().shadowMapRender.castShadowLight = this; 
        //}
        /**
         * @language en_US
         * @param index
         * @param lightData
         */
        /**
         * @language zh_CN
         * @private
         * 更新灯光数据
         * @param index 灯光ID
         * @param lightData 灯光数据
         */
        DirectLight.prototype.updateLightData = function (index, lightData) {
            lightData[index * DirectLight.stride + 0] = this._rot.x;
            lightData[index * DirectLight.stride + 1] = this._rot.y;
            lightData[index * DirectLight.stride + 2] = this._rot.z;
            lightData[index * DirectLight.stride + 3] = this._diffuse.x;
            lightData[index * DirectLight.stride + 4] = this._diffuse.y;
            lightData[index * DirectLight.stride + 5] = this._diffuse.z;
            lightData[index * DirectLight.stride + 6] = this._halfColor.x;
            lightData[index * DirectLight.stride + 7] = this._halfColor.y;
            lightData[index * DirectLight.stride + 8] = this._halfColor.z;
            lightData[index * DirectLight.stride + 9] = this._intensity;
            lightData[index * DirectLight.stride + 10] = this._halfIntensity;
        };
        /**
        * @language zh_CN
        * @private
        * 光源数据结构长度
        */
        DirectLight.stride = 11;
        return DirectLight;
    })(egret3d.LightBase);
    egret3d.DirectLight = DirectLight;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.DirectLight
    * @classdesc
    *
    * 点光源
    * 所有的灯光基本要素 灯光的颜色，强度，位置，方向
    * 颜色的色值均是16进制 red:0xffff0000 argb的定义模式
    * 每个材质球所能最大使用的灯光建议别太多，能省则省，尤其是移动端，能用灯光缓存图 lightmap 最好
    * 点光源是游戏中常常用到的动态光源，实时渲染中，灯光的数量会直接影响渲染性能
    * @see egret3d.Object3D
    * @see egret3d.LightGroup
    * @see egret3d.LightBase
    * @see egret3d.PointLight
    * @see egret3d.SportLight
    * @includeExample lights/PointLight.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        /**
         * @language zh_CN
         * @private
         * constructor
         * @param color {Number}
         */
        function PointLight(color) {
            _super.call(this);
            this._lightType = 1;
            this.diffuse = color;
        }
        /**
         * @language zh_CN
         * @private
         * 更新灯光数据
         * @param index 灯光ID
         * @param lightData 灯光数据
         */
        PointLight.prototype.updateLightData = function (index, lightData) {
            lightData[index * PointLight.stride] = this.x;
            lightData[index * PointLight.stride + 1] = this.y;
            lightData[index * PointLight.stride + 2] = this.z;
            lightData[index * PointLight.stride + 3] = this._diffuse.x;
            lightData[index * PointLight.stride + 4] = this._diffuse.y;
            lightData[index * PointLight.stride + 5] = this._diffuse.z;
            lightData[index * PointLight.stride + 6] = this._intensity;
        };
        /**
         * @language zh_CN
         * @private
         * 点光源的数据长度
         */
        PointLight.stride = 7;
        return PointLight;
    })(egret3d.LightBase);
    egret3d.PointLight = PointLight;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.DirectLight
    * @classdesc
    * spot 的灯光 也就是筒灯
    * 所有的灯光基本要素 灯光的颜色，强度，位置，方向
    * 颜色的色值均是16进制 red:0xffff0000 argb的定义模式
    * 每个材质球所能最大使用的灯光建议别太多，能省则省，尤其是移动端，能用灯光缓存图 lightmap 最好
    * spot light 可以直接想象为点光源照了个罩子，有方向且有范围的灯光
    * @see egret3d.Object3D
    * @see egret3d.LightGroup
    * @see egret3d.LightBase
    * @see egret3d.PointLight
    * @see egret3d.SportLight
    * @version Egret 3.0
    * @platform Web,Native
    */
    var SpotLight = (function (_super) {
        __extends(SpotLight, _super);
        /**
         * @language zh_CN
         * @priavete
         * constructor
         * @param color {Vector3D}
         */
        function SpotLight(color) {
            _super.call(this);
            this._diffuse = color;
            this._lightType = 2;
        }
        Object.defineProperty(SpotLight.prototype, "spotCosCutoff", {
            /**
             * @language zh_CN
             *
             * spot 的 裁切范围
             * spot light 照射范围的大小指数
             * @returns Cutoff -spot 的 裁切范围
             */
            get: function () {
                return this._spotCosCutoff;
            },
            /**
             * @language zh_CN
             *
             * spot 的 裁切范围
             * spot light 照射范围的大小指数
             *
             * @param value Cutoff
             */
            set: function (value) {
                this._spotCosCutoff = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "spotExponent", {
            /**
             * @language zh_CN
             *
             * spot 的 灯光强弱
             * spot light 灯光圆形范围内随半径大小改变发生的灯光强弱指数
             * @returns 灯光强弱指数
             */
            get: function () {
                return this._spotExponent;
            },
            /**
             * @language zh_CN
             * spot 的 灯光强弱
             * spot light 灯光圆形范围内随半径大小改变发生的灯光强弱指数
             *
             * @param value 灯光强弱指数
             */
            set: function (value) {
                this._spotExponent = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "constantAttenuation", {
            /**
             * @language zh_CN
             * spot 的 灯光衰减
             * spot light 灯光圆形范围内随半径大小改变发生的灯光衰减常数指数
             * @returns 持续衰减
             */
            get: function () {
                return this._constantAttenuation;
            },
            /**
             * @language zh_CN
             *
             * spot 的 灯光衰减
             * spot light 灯光圆形范围内随半径大小改变发生的灯光衰减常数指数
             * @param value 持续衰减
             */
            set: function (value) {
                this._constantAttenuation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "linearAttenuation", {
            /**
             * @language zh_CN
             *
             * spot 的 灯光线性衰减
             * spot light 灯光圆形范围内随半径大小改变发生的灯光线性衰减
             * @returns 线性衰减
             */
            get: function () {
                return this._linearAttenuation;
            },
            /**
             * @language zh_CN
             *
             * spot 的 灯光线性衰减
             * spot light 灯光圆形范围内随半径大小改变发生的灯光线性衰减
             * @param value 线性衰减
             */
            set: function (value) {
                this._linearAttenuation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SpotLight.prototype, "quadraticAttenuation", {
            /**
             * @language zh_CN
             *
             * spot 的 灯光线性2次衰减
             * spot light 灯光圆形范围内随半径大小改变发生的灯光线性2次衰减
             * @returns 返回2次衰减
             */
            get: function () {
                return this._quadraticAttenuation;
            },
            /**
             * @language zh_CN
             *
             * spot 的 灯光线性2次衰减
             * spot light 灯光圆形范围内随半径大小改变发生的灯光线性2次衰减
             * @param value 2次衰减
             */
            set: function (value) {
                this._quadraticAttenuation = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         * @private
         * 更新灯光数据
         * @param index 灯光ID
         * @param lightData 灯光数据
         */
        SpotLight.prototype.updateLightData = function (index, lightData) {
            lightData[index * SpotLight.stride] = this.x;
            lightData[index * SpotLight.stride + 1] = this.y;
            lightData[index * SpotLight.stride + 2] = this.z;
            lightData[index * SpotLight.stride + 3] = this._rot.x;
            lightData[index * SpotLight.stride + 4] = this._rot.y;
            lightData[index * SpotLight.stride + 5] = this._rot.z;
            lightData[index * SpotLight.stride + 6] = this._diffuse.x;
            lightData[index * SpotLight.stride + 7] = this._diffuse.y;
            lightData[index * SpotLight.stride + 8] = this._diffuse.z;
            lightData[index * SpotLight.stride + 9] = this._spotExponent;
            lightData[index * SpotLight.stride + 10] = this._spotCosCutoff;
            lightData[index * SpotLight.stride + 11] = this._constantAttenuation;
            lightData[index * SpotLight.stride + 12] = this._linearAttenuation;
            lightData[index * SpotLight.stride + 13] = this._quadraticAttenuation;
        };
        /**
         * @language zh_CN
         * @priavete
         */
        SpotLight.stride = 14;
        return SpotLight;
    })(egret3d.LightBase);
    egret3d.SpotLight = SpotLight;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
   * @class egret3d.DirectLight
   * @classdesc
   *
   * 点光源
   * 所有的灯光基本要素 灯光的颜色，强度，位置，方向
   * 颜色的色值均是16进制 red:0xffff0000 argb的定义模式
   * 每个材质球所能最大使用的灯光建议别太多，能省则省，尤其是移动端，能用灯光缓存图 lightmap 最好
   * 点光源是游戏中常常用到的动态光源，实时渲染中，灯光的数量会直接影响渲染性能
   * @see egret3d.Object3D
   * @see egret3d.LightGroup
   * @see egret3d.LightBase
   * @see egret3d.PointLight
   * @see egret3d.SportLight
   * @version Egret 3.0
   * @platform Web,Native
   */
    var LightGroup = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function LightGroup() {
            /**
             * @language en_US
             */
            /**
             * @language zh_CN
             * 灯光个数
             */
            this.lightNum = 0;
            this.directLightList = new Array();
            this.spotLightList = new Array();
            this.pointLightList = new Array();
        }
        /**
         * @language en_US
         * @param light
         */
        /**
         * @language zh_CN
         * 增加一个方向光
         * @param light  Direct Light
         */
        LightGroup.prototype.addDirectLight = function (light) {
            this.directLightList.push(light);
            this.lightNum++;
        };
        /**
         * @language en_US
         * @param light
         */
        /**
         * @language zh_CN
         * 增加一个聚光灯
         * @param light Spot Light
         */
        LightGroup.prototype.addSpotLight = function (light) {
            this.spotLightList.push(light);
            this.lightNum++;
        };
        /**
         * @language en_US
         * @param light
         */
        /**
         * @language zh_CN
         * 增加一个点光源
         * @param light  Point Light
         */
        LightGroup.prototype.addPointLight = function (light) {
            this.pointLightList.push(light);
            this.lightNum++;
        };
        return LightGroup;
    })();
    egret3d.LightGroup = LightGroup;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.RenderBase
    * @classdesc
    * 渲染器基类
    */
    var RenderBase = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function RenderBase() {
            ///protected _context3D: Context3D;
            this._renderIndex = 0;
            this._numEntity = 0;
            ///this.camera3D = camera3D;
        }
        /**
        * @language zh_CN
        * 每帧渲染
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @param context3D 设备上下文
        * @param collect 渲染对象收集器
        * @param camera 渲染时的相机
        */
        RenderBase.prototype.draw = function (time, delay, context3D, collect, camera, viewPort) {
        };
        return RenderBase;
    })();
    egret3d.RenderBase = RenderBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.SphereSky
    * @classdesc
    * default render
    * 把所有需要渲染的对象，依次进行渲染
    * @version Egret 3.0
    * @platform Web,Native
    */
    var DefaultRender = (function (_super) {
        __extends(DefaultRender, _super);
        /**
        * @language zh_CN
        * constructor
        */
        function DefaultRender() {
            _super.call(this);
        }
        /**
        * @language zh_CN
        * 把所有需要渲染的对象，依次进行渲染
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @param context3D 设备上下文
        * @param collect 渲染对象收集器
        * @param camera 渲染时的相机
        */
        DefaultRender.prototype.draw = function (time, delay, context3D, collect, camera, viewPort) {
            this._renderList = collect.renderList;
            this._numEntity = this._renderList.length;
            ///context3D.gl.clear(context3D.gl.COLOR_BUFFER_BIT | context3D.gl.DEPTH_BUFFER_BIT);
            for (this._renderIndex = 0; this._renderIndex < this._numEntity; this._renderIndex++) {
                this._renderList[this._renderIndex].update(camera, time, delay);
                if (!this._renderList[this._renderIndex].isVisible) {
                    continue;
                }
                if (this._renderList[this._renderIndex].tag && this._renderList[this._renderIndex].tag.clearDepth && this._renderList[this._renderIndex].tag.cleanState) {
                    this._renderList[this._renderIndex].tag.cleanState = false;
                    context3D.clearDepth(1);
                }
                if (this._renderList[this._renderIndex].material != null) {
                    if (this._renderList[this._renderIndex].material.alpha != 0) {
                        this._renderList[this._renderIndex].material.rendenDiffusePass(context3D, camera, this._renderList[this._renderIndex].modelMatrix, this._renderList[this._renderIndex].geometry, this._renderList[this._renderIndex].animation);
                    }
                }
            }
        };
        return DefaultRender;
    })(egret3d.RenderBase);
    egret3d.DefaultRender = DefaultRender;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.PositionRender
    * @classdesc
    * position render
    * @version Egret 3.0
    * @platform Web,Native
    */
    var PositionRender = (function (_super) {
        __extends(PositionRender, _super);
        /**
        * @language zh_CN
        * constructor
        */
        function PositionRender() {
            _super.call(this);
        }
        /**
        * @private
        * @language zh_CN
        * 渲染
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @param context3D 设备上下文
        * @param collect 渲染对象收集器
        * @param camera 渲染时的相机
        * @version Egret 3.0
        * @platform Web,Native
        */
        PositionRender.prototype.renden = function (time, delay, context3D, collect, camera, viewPort) {
            this._renderList = collect.renderList;
            this._numEntity = this._renderList.length;
            for (this._renderIndex = 0; this._renderIndex < this._numEntity; this._renderIndex++) {
                this._renderList[this._renderIndex].update(camera, time, delay);
                if (!this._renderList[this._renderIndex].isVisible) {
                    continue;
                }
                if (this._renderList[this._renderIndex].material != null) {
                }
            }
        };
        return PositionRender;
    })(egret3d.RenderBase);
    egret3d.PositionRender = PositionRender;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.NormalRender
    * @classdesc
    * 法线渲染器,渲染有法线的实现对象
    * @version Egret 3.0
    * @platform Web,Native
    */
    var NormalRender = (function (_super) {
        __extends(NormalRender, _super);
        /**
        * @language zh_CN
        * constructor
        */
        function NormalRender() {
            _super.call(this);
        }
        /**
        * @language zh_CN
        * 渲染
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @param context3D 设备上下文
        * @param collect 渲染对象收集器
        * @param camera 渲染时的相机
        * @version Egret 3.0
        * @platform Web,Native
        */
        NormalRender.prototype.draw = function (time, delay, context3D, collect, camera, viewPort) {
            this._renderList = collect.renderList;
            this._numEntity = this._renderList.length;
            for (this._renderIndex = 0; this._renderIndex < this._numEntity; this._renderIndex++) {
                this._renderList[this._renderIndex].update(camera, time, delay);
                if (!this._renderList[this._renderIndex].isVisible) {
                    continue;
                }
                if (this._renderList[this._renderIndex].material != null) {
                    this._renderList[this._renderIndex].material.rendenNormalPass(context3D, camera, this._renderList[this._renderIndex].modelMatrix, this._renderList[this._renderIndex].geometry, this._renderList[this._renderIndex].animation);
                }
            }
        };
        return NormalRender;
    })(egret3d.RenderBase);
    egret3d.NormalRender = NormalRender;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.DepthRender
    * @classdesc
    * 深度渲染器 渲染场景中的实体对象
    * @version Egret 3.0
    * @platform Web,Native
    */
    var DepthRender = (function (_super) {
        __extends(DepthRender, _super);
        /**
        * @language zh_CN
        * constructor
        */
        function DepthRender() {
            _super.call(this);
        }
        /**
        * @language zh_CN
        * 提交数据给GPU渲染
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @param context3D 设备上下文
        * @param collect 渲染对象收集器
        * @param camera 渲染时的相机
        * @version Egret 3.0
        * @platform Web,Native
        */
        DepthRender.prototype.draw = function (time, delay, context3D, collect, camera, viewPort) {
            this._renderList = collect.renderList;
            this._numEntity = this._renderList.length;
            for (this._renderIndex = 0; this._renderIndex < this._numEntity; this._renderIndex++) {
                this._renderList[this._renderIndex].update(camera, time, delay);
                if (!this._renderList[this._renderIndex].isVisible) {
                    continue;
                }
                if (this._renderList[this._renderIndex].material != null) {
                    this._renderList[this._renderIndex].material.rendenDepthPass(context3D, camera, this._renderList[this._renderIndex].modelMatrix, this._renderList[this._renderIndex].geometry, this._renderList[this._renderIndex].animation);
                }
            }
        };
        return DepthRender;
    })(egret3d.RenderBase);
    egret3d.DepthRender = DepthRender;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.ShadowRender
    * @classdesc
    * 阴影渲染器
    */
    var ShadowRender = (function (_super) {
        __extends(ShadowRender, _super);
        /**
        * @language zh_CN
        * constructor
        */
        function ShadowRender() {
            _super.call(this);
            this.shadowTexture_width = 1024;
            this.shadowTexture_height = 1024;
            this.cameraTarget = new egret3d.Vector3D();
            this.cameraPos = new egret3d.Vector3D();
            this.distance = 0;
            ShadowRender.shadowCamera3D = new egret3d.Camera3D(egret3d.CameraType.orthogonal); //temp
            ShadowRender.frameBuffer = egret3d.RttManager.creatFrameBuffer(egret3d.FrameBufferType.shadowFrameBufrfer, egret3d.Egret3DDrive.context3D, this.shadowTexture_width, this.shadowTexture_height, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGBA);
        }
        /**
        * @language zh_CN
        * 渲染
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @param context3D 设备上下文
        * @param collect 渲染对象收集器
        * @param camera 渲染时的相机
        */
        ShadowRender.prototype.draw = function (time, delay, context3D, collect, camera, viewPort) {
            if (ShadowRender.castShadowLight) {
                this.offsetPos(new egret3d.Vector3D());
                this._renderList = collect.renderList;
                this._numEntity = this._renderList.length;
                for (this._renderIndex = 0; this._renderIndex < this._numEntity; this._renderIndex++) {
                    if (this._renderList[this._renderIndex].material.castShadow) {
                        this._renderList[this._renderIndex].update(camera, time, delay);
                        if (!this._renderList[this._renderIndex].isVisible) {
                            continue;
                        }
                        this._renderList[this._renderIndex].material.rendenShadowPass(context3D, ShadowRender.shadowCamera3D, this._renderList[this._renderIndex].modelMatrix, this._renderList[this._renderIndex].geometry, this._renderList[this._renderIndex].animation);
                    }
                }
            }
        };
        ShadowRender.prototype.offsetPos = function (offset) {
            this.cameraPos.x = ShadowRender.castShadowLight.rotationX;
            this.cameraPos.y = ShadowRender.castShadowLight.rotationY;
            this.cameraPos.z = ShadowRender.castShadowLight.rotationZ;
            this.cameraPos.normalize();
            this.cameraPos.scaleBy(1.0 * 500);
            this.cameraPos.x = this.cameraPos.x + offset.x;
            this.cameraPos.y = this.cameraPos.y + offset.y;
            this.cameraPos.z = this.cameraPos.z + offset.z;
            ShadowRender.shadowCamera3D.lookAt(this.cameraPos, offset);
        };
        return ShadowRender;
    })(egret3d.RenderBase);
    egret3d.ShadowRender = ShadowRender;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    (function (RenderType) {
        RenderType[RenderType["defaultRender"] = 0] = "defaultRender";
        RenderType[RenderType["positionRender"] = 1] = "positionRender";
        RenderType[RenderType["normalRender"] = 2] = "normalRender";
        RenderType[RenderType["specularRender"] = 3] = "specularRender";
        RenderType[RenderType["shadowRender"] = 4] = "shadowRender";
    })(egret3d.RenderType || (egret3d.RenderType = {}));
    var RenderType = egret3d.RenderType;
    /**
    * @private
    * @class egret3d.RenderManager
    * @classdesc
    * 渲染器管理,管理所有的渲染器对象
    */
    var RenderManager = (function () {
        function RenderManager() {
        }
        /**
        * @language zh_CN
        * 以渲染类型拿到渲染器
        * @param renderType 渲染类型
        */
        RenderManager.getRender = function (renderType) {
            if (this.renders[renderType])
                return this.renders[renderType];
            return this.creatSystemRender(renderType);
        };
        RenderManager.creatSystemRender = function (renderType) {
            var render;
            switch (renderType) {
                case RenderType.defaultRender:
                    render = new egret3d.DefaultRender();
                    break;
                case RenderType.positionRender:
                    render = new egret3d.PositionRender();
                    break;
                case RenderType.normalRender:
                    render = new egret3d.NormalRender();
                    break;
                case RenderType.specularRender:
                    ///  render = new NormalRender();
                    break;
                case RenderType.shadowRender:
                    render = new egret3d.ShadowRender();
                    break;
            }
            this.renders[renderType] = render;
            return render;
        };
        RenderManager.renders = new Object();
        return RenderManager;
    })();
    egret3d.RenderManager = RenderManager;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.CollectBase
    * @classdesc
    * @version Egret 3.0
    * @platform Web,Native
    * Object3D 渲染对象收集器基类
    */
    var CollectBase = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param root 渲染根节点
        */
        function CollectBase(root) {
            this._num = 0;
            this._objDict = {};
            this.renderList = new Array();
            this.mousePickList = new Array();
            this._nodes = new Array();
            this._rootNode = root;
        }
        /**
        * @language zh_CN
        * 数据更新
        * @param camera 当前摄像机
        */
        CollectBase.prototype.update = function (camera) {
            this.renderList = this._nodes;
            this.renderList.length = 0;
            camera.frustum.update(camera);
        };
        /**
        * @language zh_CN
        * 查找一个对象在渲染列表的下标
        * @param obj 要查找的对象
        * @returns 返回对象在渲染列表的下标
        */
        CollectBase.prototype.findRenderObject = function (obj) {
            for (var i = 0; i < this.renderList.length; ++i) {
                if (this.renderList[i] === obj) {
                    return i;
                }
            }
            return -1;
        };
        return CollectBase;
    })();
    egret3d.CollectBase = CollectBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Layer
    * @classdesc
    * Object3D 渲染Layer
    * 每个Layer分两个渲染列表，一个是有alpha的对象列表，另一个是没有alpha的对象列表
    * 不同的Layer层级可以使用不同的渲染方式，来达到各组不同的渲染效果.
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Layer = (function () {
        function Layer() {
            /**
            * @language zh_CN
            * 没有alpha的对象列表
            */
            this.objects = new Array();
            /**
            * @language zh_CN
            * 有alpha的对象列表
            */
            this.alphaObjects = new Array();
        }
        return Layer;
    })();
    egret3d.Layer = Layer;
    /**
    * @class egret3d.Tag
    * @classdesc
    * Object3D 渲染tag
    * 图形属性标签页的属性，由layer列表组成，共用深度信息
    * 渲染每个tag他们的深度信息是不清理的
    *
    * @see egret3d.core.traverse.Layer
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Tag = (function () {
        function Tag() {
            /**
            * @language zh_CN
            * layer 列表
            */
            this.layers = new Array();
            /**
            * @language zh_CN
            * 是否清理深度
            */
            this.clearDepth = false;
            /**
            * @language zh_CN
            * 层级清理深度状态
            */
            this.cleanState = true;
        }
        return Tag;
    })();
    egret3d.Tag = Tag;
    /**
    * @class egret3d.EntityCollect
    * @classdesc
    * Object3D 渲染对象收集器,把渲染对象进行可视筛选，
    * 并且划分渲染层级，依次排序到加入列表.
    *
    * @see egret3d.Scene3D
    * @see egret3d.View3D
    * @version Egret 3.0
    * @platform Web,Native
    */
    var EntityCollect = (function (_super) {
        __extends(EntityCollect, _super);
        /**
        * @language zh_CN
        * constructor
        * @param root 渲染根节点
        * @version Egret 3.0
        * @platform Web,Native
        */
        function EntityCollect(root) {
            _super.call(this, root);
            this._tags = new Array();
            this._layers = new Array();
            this._tagsName = new Array();
            this.addTag("default");
            this.addTag("terrain");
            this.addTag("terrain_texture");
            this.addTag("shadow");
            this.addTag("character");
            this.addTag("modle_effect");
            this.addTag("particle");
            this.addTag("transparent");
            this.addTag("wireframe", true);
            var tag = { typeName: "", cleanDepth: false };
            this.addLayer("layer_0");
            this.addLayer("layer_1");
            this.addLayer("layer_2");
            this.addLayer("layer_3");
            this.addLayer("layer_4");
        }
        Object.defineProperty(EntityCollect.prototype, "tags", {
            /**
            * @language zh_CN
            * 返回tags 列表
            *
            * @returns tags 列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._tags;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 设置tag名和name的下标为index 没有的话会新加tag
        * @param name tag名
        * @param index 下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.setTags = function (name, index) {
            var curIndex = this._tagsName.indexOf(name);
            if (curIndex != -1) {
                var tag = this._tags[curIndex];
                this.removeTag(name);
                this._tagsName.splice(index, 0, name);
                this._tags.splice(index, 0, tag);
            }
            else {
                this.insertTag(name, index);
            }
        };
        /**
        * @language zh_CN
        * 设置layer名和name的下标为index
        * @param layer layer名
        * @param index 下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.setTagsItem = function (layer, index) {
            this.removeLayer(layer);
            this.insetLayer(layer, index);
        };
        /**
        * @language zh_CN
        * 得到layer的值
        * @param name tag名
        * @param layer layer名
        * @returns 返回layer的值
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.getTagLayer = function (name, layer) {
            if (name === void 0) { name = "default"; }
            if (layer === void 0) { layer = "layer_0"; }
            var typeIndex = this._tagsName.indexOf(name);
            var layerIndex = this._layers.indexOf(layer);
            return (typeIndex << 24) | layerIndex;
        };
        /**
        * @language zh_CN
        * 得到tag
        * @param name tag名
        * @returns tag
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.getTag = function (name) {
            if (name === void 0) { name = "default"; }
            var index = this._tagsName.indexOf(name);
            if (index != -1) {
                return this.tags[index];
            }
            return null;
        };
        /**
        * @language zh_CN
        * 增加tag
        * @param name tag名
        * @param clearDapth 是否清理深度
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.addTag = function (name, clearDapth) {
            if (clearDapth === void 0) { clearDapth = false; }
            if (this._tagsName.indexOf(name) != -1) {
                return;
            }
            this._tagsName.push(name);
            var tag = new Tag();
            tag.clearDepth = clearDapth;
            this._tags.push(tag);
            for (var i = 0; i < this._layers.length; ++i) {
                var layer = new Layer();
                tag.layers.push(layer);
            }
        };
        /**
        * @language zh_CN
        * 插入tag
        * @param name tag名
        * @param index 下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.insertTag = function (name, index) {
            if (this._tagsName.indexOf(name) != -1) {
                return;
            }
            this._tagsName.splice(index, 0, name);
            var tag = new Tag();
            this._tags.splice(index, 0, tag);
            for (var i = 0; i < this._layers.length; ++i) {
                var layer = new Layer();
                tag.layers.push(layer);
            }
        };
        /**
        * @language zh_CN
        * 移除tag
        * @param name tag名
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.removeTag = function (name) {
            var index = this._tagsName.indexOf(name);
            if (index == -1) {
                return;
            }
            this._tagsName.splice(index, 1);
            this._tags.splice(index, 1);
        };
        /**
        * @language zh_CN
        * 增加layer
        * @param name layer名
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.addLayer = function (name) {
            if (this._layers.indexOf(name) != -1) {
                return;
            }
            this._layers.push(name);
            for (var i = 0; i < this._tags.length; ++i) {
                var layer = new Layer();
                this._tags[i].layers.push(layer);
            }
        };
        /**
        * @language zh_CN
        * 插入layer
        * @param name layer名
        * @param index layer下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.insetLayer = function (name, index) {
            if (this._layers.indexOf(name) != -1) {
                return;
            }
            this._layers.splice(index, 0, name);
            for (var i = 0; i < this._tags.length; ++i) {
                var layer = new Layer();
                this._tags[i].layers.splice(index, 0, layer);
            }
        };
        /**
        * @language zh_CN
        * 移除layer
        * @param name layer名
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.removeLayer = function (name) {
            var index = this._layers.indexOf(name);
            if (index == -1) {
                return;
            }
            this._layers.splice(index, 1);
            for (var i = 0; i < this._tags.length; ++i) {
                this._tags[i].layers.splice(index, 1);
            }
        };
        EntityCollect.prototype.applyRender = function (child, camera) {
            this.addRenderList(child, camera);
            for (var i = 0; i < child.childs.length; i++) {
                this.applyRender(child.childs[i], camera);
            }
        };
        EntityCollect.prototype.addRenderList = function (object3d, camera) {
            if (!object3d.material)
                return;
            if (object3d.enableCut) {
                if (!camera.isVisibleToCamera(object3d)) {
                    return;
                }
            }
            if (object3d.mouseEnable) {
                this.mousePickList.push(object3d);
            }
            var layer = this.findLayer(object3d);
            var tag = this.findTag(object3d);
            if (object3d.material != null && object3d.material.materialData.alphaBlending) {
                layer.alphaObjects.push(object3d);
            }
            else {
                layer.objects.push(object3d);
            }
        };
        /**
        * @language zh_CN
        * 数据更新 处理需要渲染的对象
        * @param camera 当前摄像机
        * @version Egret 3.0
        * @platform Web,Native
        */
        EntityCollect.prototype.update = function (camera) {
            var _this = this;
            _super.prototype.update.call(this, camera);
            this.renderList.length = 0;
            this.mousePickList.length = 0;
            this.clearLayerList();
            this.applyRender(this._rootNode, camera);
            for (var i = 0; i < this._tags.length; ++i) {
                this._tags[i].clearDepth = true;
                for (var j = 0; j < this._tags[i].layers.length; ++j) {
                    for (var k = 0; k < this._tags[i].layers[j].objects.length; ++k) {
                        this.renderList.push(this._tags[i].layers[j].objects[k]);
                    }
                    this._tags[i].layers[j].alphaObjects.sort(function (a, b) { return _this.sort(a, b, camera); });
                    for (var k = 0; k < this._tags[i].layers[j].alphaObjects.length; ++k) {
                        this.renderList.push(this._tags[i].layers[j].alphaObjects[k]);
                    }
                }
            }
        };
        EntityCollect.prototype.findLayer = function (object3d) {
            var typeIndex = object3d.layer >> 24;
            var layerIndex = object3d.layer & 0x00FFFFFF;
            if (typeIndex < this._tags.length && typeIndex >= 0) {
                if (layerIndex < this._tags[typeIndex].layers.length && layerIndex >= 0) {
                    return this._tags[typeIndex].layers[layerIndex];
                }
            }
            return this._tags[0].layers[0];
        };
        EntityCollect.prototype.findTag = function (object3d) {
            var typeIndex = object3d.layer >> 24;
            if (typeIndex < this._tags.length && typeIndex >= 0) {
                return this._tags[typeIndex];
            }
            return this._tags[0];
        };
        EntityCollect.prototype.clearLayerList = function () {
            for (var i = 0; i < this._tags.length; ++i) {
                for (var j = 0; j < this._tags[i].layers.length; ++j) {
                    this._tags[i].layers[j].objects.length = 0;
                    this._tags[i].layers[j].alphaObjects.length = 0;
                }
            }
        };
        EntityCollect.prototype.sort = function (a, b, camera) {
            var dis_0 = egret3d.Vector3D.distance(a.globalPosition, camera.position);
            var dis_1 = egret3d.Vector3D.distance(b.globalPosition, camera.position);
            if (dis_0 > dis_1) {
                return -1;
            }
            else if (dis_0 < dis_1) {
                return 1;
            }
            return 0;
        };
        return EntityCollect;
    })(egret3d.CollectBase);
    egret3d.EntityCollect = EntityCollect;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    var Scene3D = (function (_super) {
        __extends(Scene3D, _super);
        function Scene3D() {
            _super.call(this);
            this.collect = new egret3d.EntityCollect(this);
        }
        return Scene3D;
    })(egret3d.Object3D);
    egret3d.Scene3D = Scene3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    (function (FrameBufferType) {
        FrameBufferType[FrameBufferType["shadowFrameBufrfer"] = 0] = "shadowFrameBufrfer";
        FrameBufferType[FrameBufferType["defaultFrameBuffer"] = 1] = "defaultFrameBuffer";
        FrameBufferType[FrameBufferType["positionFrameBuffer"] = 2] = "positionFrameBuffer";
        FrameBufferType[FrameBufferType["normalFrameBuffer"] = 3] = "normalFrameBuffer";
        FrameBufferType[FrameBufferType["specularFrameBuffer"] = 4] = "specularFrameBuffer";
        FrameBufferType[FrameBufferType["leftEyeFrameBuffer"] = 5] = "leftEyeFrameBuffer";
        FrameBufferType[FrameBufferType["rightEyeFrameBuffer"] = 6] = "rightEyeFrameBuffer";
        FrameBufferType[FrameBufferType["nextFrameBuffer"] = 7] = "nextFrameBuffer";
    })(egret3d.FrameBufferType || (egret3d.FrameBufferType = {}));
    var FrameBufferType = egret3d.FrameBufferType;
    /**
    * @private
    */
    (function (FrameBufferFormat) {
        FrameBufferFormat[FrameBufferFormat["FLOAT_RGB"] = 0] = "FLOAT_RGB";
        FrameBufferFormat[FrameBufferFormat["FLOAT_RGBA"] = 1] = "FLOAT_RGBA";
        FrameBufferFormat[FrameBufferFormat["UNSIGNED_BYTE_RGB"] = 2] = "UNSIGNED_BYTE_RGB";
        FrameBufferFormat[FrameBufferFormat["UNSIGNED_BYTE_RGBA"] = 3] = "UNSIGNED_BYTE_RGBA";
    })(egret3d.FrameBufferFormat || (egret3d.FrameBufferFormat = {}));
    var FrameBufferFormat = egret3d.FrameBufferFormat;
    /**
    * @private
    * @class egret3d.RttManager
    * @classdesc
    * 离屏渲染管理, 把数据渲染在一张纹理上，
    * @version Egret 3.0
    * @platform Web,Native
    */
    var RttManager = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function RttManager() {
            this.shadowFrameBufrfer = new egret3d.FrameBuffer();
            this.defaultFrameBuffer = new egret3d.FrameBuffer();
            this.positionFrameBuffer = new egret3d.FrameBuffer();
            this.normalFrameBuffer = new egret3d.FrameBuffer();
            this.specularFrameBuffer = new egret3d.FrameBuffer();
            this.leftEyeFrameBuffer = new egret3d.FrameBuffer();
            this.rightFrameBuffer = new egret3d.FrameBuffer();
            this.nextFrameBuffer = new egret3d.FrameBuffer();
            if (RttManager.instance)
                new Error("can't new RttManager instance!");
        }
        /**
        * @language zh_CN
        * 创建帧缓冲
        * @param framName
        * @param context3D
        * @param width
        * @param height
        * @param format
        * @returns FrameBuffer
        */
        RttManager.creatFrameBuffer = function (framName, context3D, width, height, format) {
            var frameBuffer = new egret3d.FrameBuffer();
            frameBuffer.frameBufferName = framName;
            frameBuffer.width = width;
            frameBuffer.height = height;
            frameBuffer.texture = new egret3d.RenderTexture(context3D.createFramebuffer(width, height, format));
            RttManager.instance[framName] = frameBuffer;
            return RttManager.instance[framName];
        };
        /**
        * @language zh_CN
        * 把帧缓冲的内容渲染到贴图
        * @param time
        * @param delay
        * @param context3D
        * @param collect
        * @param rec
        */
        RttManager.prototype.drawFrameBuffersToTexture = function (time, delay, context3D, collect, camera, rec) {
        };
        /**
        * @language zh_CN
        * 把帧缓冲的内容渲染到贴图
        * @param time
        * @param delay
        * @param renderTragetTexture
        * @param context3D
        * @param render
        * @param collect
        * @param camera
        * @param rec
        */
        RttManager.drawToTexture = function (time, delay, renderTragetTexture, context3D, render, collect, camera, rec) {
            context3D.viewPort(rec.x, rec.y, rec.width, rec.height);
            context3D.setRenderToTexture(renderTragetTexture, true, 0);
            render.draw(time, delay, context3D, collect, camera, rec);
            context3D.setRenderToBackBuffer();
        };
        /**
        * @language zh_CN
        * 开始渲染
        * @param renderTragetTexture
        * @param context3D
        * @param rec
        */
        RttManager.drawToTextureStart = function (renderTragetTexture, context3D, rec) {
            context3D.viewPort(rec.x, rec.y, rec.width, rec.height);
            context3D.setRenderToTexture(renderTragetTexture, true, 0);
        };
        /**
        * @language zh_CN
        * 结束渲染
        * @param time
        * @param delay
        * @param context3D
        * @param render
        * @param collect
        * @param camera
        * @param rec
        */
        RttManager.drawToTextureEnd = function (context3D) {
            context3D.setRenderToBackBuffer();
        };
        RttManager.instance = new RttManager();
        return RttManager;
    })();
    egret3d.RttManager = RttManager;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.GeometryData
     * @classdesc
     * GeometryData类 表示几何形状数据
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/GeometryData.ts
     */
    var GeometryData = (function () {
        function GeometryData() {
            /**
            * @language zh_CN
            * 顶点属性长度
            */
            this.vertexAttLength = 17;
            /**
            * @language zh_CN
            * 索引数据
            */
            this.source_indexData = new Array();
            /**
            * @language zh_CN
            * 顶点数据
            */
            this.source_vertexData = new Array();
            /**
            * @language zh_CN
            * 顶点色数据
            */
            this.source_vertexColorData = new Array();
            /**
            * @language zh_CN
            * 顶点法线
            */
            this.source_normalData = new Array();
            /**
            * @language zh_CN
            * 顶点切线数据
            */
            this.source_tangtData = new Array();
            /**
            * @language zh_CN
            * 顶点uv数据
            */
            this.source_uvData = new Array();
            /**
            * @language zh_CN
            * 顶点uv2数据
            */
            this.source_uv2Data = new Array();
            /**
            * @language zh_CN
            * 每个3角面的数据
            */
            this.source_faceData = new Array();
            /**
            * @language zh_CN
            * 蒙皮数据
            */
            this.source_skinData = new Array();
            /**
            * @language zh_CN
            * 顶点索引
            */
            this.vertexIndex = 0;
            /**
            * @language zh_CN
            * 索引数据数组
            */
            this.indices = new Array();
            /**
            * @language zh_CN
            * 顶点数据数组(x、y、z)三个number为一个顶点数据
            */
            this.vertices = new Array();
            /**
            * @language zh_CN
            * 法线数据数组(x、y、z)三个number为一个法线数据
            */
            this.normals = new Array();
            /**
            * @language zh_CN
            * 切线数据数组(x、y、z)三个number为一个切线数据
            */
            this.tangts = new Array();
            /**
            * @language zh_CN
            * 顶点颜色数据数组
            */
            this.verticesColor = new Array();
            /**
            * @language zh_CN
            * 第一套UV数据数组
            */
            this.uvs = new Array();
            /**
            * @language zh_CN
            * 第二套UV数据数组
            */
            this.uv2s = new Array();
            /**
            * @language zh_CN
            * 蒙皮数据数组
            */
            this.skinMesh = new Array();
            /**
            * @language zh_CN
            * 面法线数据数组
            */
            this.faceNormals = new Array();
            /**
            * @language zh_CN
            * 面权重数据数组
            */
            this.faceWeights = new Array();
        }
        /**
        * @language zh_CN
        * 构建顶点数据数组
        * @param source 未组合顶点数据的GeometryData对象
        * @returns 经过组合并生成顶点数据数组的新GeometryData对象
        */
        GeometryData.build = function (source) {
            if (null == source.source_faceData || source.source_faceData.length <= 0 || null == source.source_vertexData || source.source_vertexData.length <= 0)
                return null;
            var target = new GeometryData();
            target.indices = [];
            target.vertexDatas = [];
            target.vertexAttLength = source.vertexAttLength;
            var faceData = null;
            var vertex = null;
            var normal = new egret3d.Vector3D(1.0, 1.0, 1.0);
            var color = new egret3d.Vector3D(1.0, 1.0, 1.0, 1.0);
            var uv_0 = new egret3d.UV(1, 0);
            var uv_1 = new egret3d.UV(1, 0);
            for (var faceIndex = 0; faceIndex < source.source_faceData.length; faceIndex++) {
                faceData = source.source_faceData[faceIndex];
                target.indices.push(faceIndex * 3 + 0, faceIndex * 3 + 2, faceIndex * 3 + 1);
                for (var i = 0; i < 3; i++) {
                    vertex = source.source_vertexData[faceData.vertexIndices[i] - 1];
                    if (faceData.normalIndices && source.source_normalData && source.source_normalData.length > 0)
                        normal = source.source_normalData[faceData.normalIndices[i] - 1];
                    if (faceData.colorIndices && source.source_vertexColorData && source.source_vertexColorData.length > 0)
                        color = source.source_vertexColorData[faceData.colorIndices[i] - 1];
                    if (faceData.uvIndices && source.source_uvData && source.source_uvData.length > 0)
                        uv_0 = source.source_uvData[faceData.uvIndices[i] - 1];
                    if (faceData.uv2Indices && source.source_uv2Data && source.source_uv2Data.length > 0)
                        uv_1 = source.source_uv2Data[faceData.uv2Indices[i] - 1];
                    target.vertexDatas.push(vertex.x, vertex.y, vertex.z, //3 pos
                    normal.x, normal.y, normal.z, //3 normal
                    0.0, 0.0, 0.0, //3 tangent
                    color.r, color.g, color.b, color.a, //4 color
                    uv_0.u, uv_0.v, //2 uv1
                    uv_1.u, uv_1.v //2 uv2
                    );
                    if (source.source_skinData != null && source.source_skinData.length > 0) {
                        target.vertexDatas.push(//8 skin
                        source.source_skinData[(faceData.vertexIndices[i] - 1) * 8 + 0], source.source_skinData[(faceData.vertexIndices[i] - 1) * 8 + 2], source.source_skinData[(faceData.vertexIndices[i] - 1) * 8 + 4], source.source_skinData[(faceData.vertexIndices[i] - 1) * 8 + 6], source.source_skinData[(faceData.vertexIndices[i] - 1) * 8 + 1], source.source_skinData[(faceData.vertexIndices[i] - 1) * 8 + 3], source.source_skinData[(faceData.vertexIndices[i] - 1) * 8 + 5], source.source_skinData[(faceData.vertexIndices[i] - 1) * 8 + 7]);
                    }
                }
            }
            GeometryData.buildFaceTangents(target);
            return target;
        };
        GeometryData.translateMaterialGroup = function (geomtryData) {
            var faces = geomtryData.source_faceData;
            var face;
            var numFaces = faces.length;
            var numVerts;
            var targetGeomtryData = new GeometryData();
            targetGeomtryData.vertexAttLength = geomtryData.vertexAttLength;
            var j;
            for (var i = 0; i < numFaces; ++i) {
                face = faces[i];
                numVerts = face.indexIds.length - 1;
                for (j = 1; j < numVerts; ++j) {
                    this.translateVertexData(face, j, geomtryData, targetGeomtryData);
                    this.translateVertexData(face, 0, geomtryData, targetGeomtryData);
                    this.translateVertexData(face, j + 1, geomtryData, targetGeomtryData);
                }
            }
            if (targetGeomtryData.vertices.length > 0) {
                targetGeomtryData.vertLen = (targetGeomtryData.vertices.length / 3) * geomtryData.vertexAttLength;
                targetGeomtryData.vertexDatas = new Array(targetGeomtryData.vertLen);
                this.updateFaceTangents(targetGeomtryData);
                //this.updateFaceNormals(targetGeomtryData);
                this.combinGeomtryData(targetGeomtryData);
            }
            return targetGeomtryData;
        };
        GeometryData.translateVertexData = function (face, vertexIndex, sourceGeomtryData, targetGeomtryData) {
            var index;
            var vertex;
            var color;
            var vertexNormal;
            var uv;
            if (!targetGeomtryData.indices[face.indexIds[vertexIndex]]) {
                index = targetGeomtryData.vertexIndex;
                targetGeomtryData.indices[face.indexIds[vertexIndex]] = ++targetGeomtryData.vertexIndex;
                vertex = sourceGeomtryData.source_vertexData[face.vertexIndices[vertexIndex] - 1];
                targetGeomtryData.vertices.push(vertex.x, vertex.y, vertex.z);
                if (sourceGeomtryData.source_vertexColorData != null && sourceGeomtryData.source_vertexColorData.length > 0) {
                    color = sourceGeomtryData.source_vertexColorData[face.vertexIndices[vertexIndex] - 1];
                    targetGeomtryData.verticesColor.push(color.r, color.g, color.b, color.a);
                }
                if (sourceGeomtryData.source_skinData != null && sourceGeomtryData.source_skinData.length > 0) {
                    targetGeomtryData.skinMesh.push(sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 0], sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 2], sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 4], sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 6], sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 1], sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 3], sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 5], sourceGeomtryData.source_skinData[(face.vertexIndices[vertexIndex] - 1) * 8 + 7]);
                }
                if (face.normalIndices.length > 0) {
                    vertexNormal = sourceGeomtryData.source_normalData[face.normalIndices[vertexIndex] - 1];
                    targetGeomtryData.normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);
                }
                if (face.uvIndices.length > 0) {
                    try {
                        uv = sourceGeomtryData.source_uvData[face.uvIndices[vertexIndex] - 1];
                        targetGeomtryData.uvs.push(uv.u, uv.v);
                        if (sourceGeomtryData.source_uv2Data.length > 0) {
                            uv = sourceGeomtryData.source_uv2Data[face.uv2Indices[vertexIndex] - 1];
                            targetGeomtryData.uv2s.push(uv.u, uv.v);
                        }
                    }
                    catch (e) {
                        switch (vertexIndex) {
                            case 0:
                                targetGeomtryData.uvs.push(0, 1);
                                break;
                            case 1:
                                targetGeomtryData.uvs.push(.5, 0);
                                break;
                            case 2:
                                targetGeomtryData.uvs.push(1, 1);
                        }
                    }
                }
            }
            else
                index = targetGeomtryData.indices[face.indexIds[vertexIndex]] - 1;
            targetGeomtryData.indices.push(index);
        };
        /**
        * 4 pos
        * 3 normal
        * 4 color
        * 2 uv
        * 2 uv2s
        * length 15
        */
        GeometryData.combinGeomtryData = function (geomtrtData, needTangent) {
            if (needTangent === void 0) { needTangent = true; }
            var index = 0;
            var v = 0;
            var n = 0;
            var t = 0;
            var u1 = 0;
            var u2 = 0;
            var c = 0;
            var skin = 0;
            var data = geomtrtData.vertexDatas;
            while (index < geomtrtData.vertLen) {
                data[index++] = geomtrtData.vertices[v++];
                data[index++] = geomtrtData.vertices[v++];
                data[index++] = geomtrtData.vertices[v++];
                if (geomtrtData.normals && geomtrtData.normals.length) {
                    data[index++] = geomtrtData.normals[n++];
                    data[index++] = geomtrtData.normals[n++];
                    data[index++] = geomtrtData.normals[n++];
                }
                else {
                    data[index++] = 0;
                    data[index++] = 0;
                    data[index++] = 0;
                }
                if (geomtrtData.tangts) {
                    index++;
                    index++;
                    index++;
                }
                else {
                    data[index++] = 0;
                    data[index++] = 0;
                    data[index++] = 0;
                }
                if (geomtrtData.source_vertexColorData && geomtrtData.source_vertexColorData.length) {
                    data[index++] = geomtrtData.verticesColor[c++];
                    data[index++] = geomtrtData.verticesColor[c++];
                    data[index++] = geomtrtData.verticesColor[c++];
                    data[index++] = geomtrtData.verticesColor[c++];
                }
                else {
                    data[index++] = 1;
                    data[index++] = 1;
                    data[index++] = 1;
                    data[index++] = 1;
                }
                if (geomtrtData.uvs && geomtrtData.uvs.length) {
                    data[index++] = geomtrtData.uvs[u1++];
                    data[index++] = geomtrtData.uvs[u1++];
                    if (geomtrtData.uv2s && geomtrtData.uv2s.length) {
                        data[index++] = geomtrtData.uv2s[u2++];
                        data[index++] = geomtrtData.uv2s[u2++];
                    }
                    else {
                        data[index++] = geomtrtData.uvs[u2++];
                        data[index++] = geomtrtData.uvs[u2++];
                    }
                }
                else {
                    data[index++] = 0;
                    data[index++] = 0;
                    data[index++] = 0;
                    data[index++] = 0;
                }
                if (geomtrtData.skinMesh && geomtrtData.skinMesh.length) {
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                    data[index++] = geomtrtData.skinMesh[skin++];
                }
            }
            //if (needTangent)
            //    this.updateFaceTangents(geomtrtData
        };
        /**
         * Updates the normals for each face.
         */
        GeometryData.updateFaceNormals = function (geomtrtData) {
            var i = 0, j = 0, k = 0;
            var index;
            var len = geomtrtData.indices.length;
            var x1, x2, x3;
            var y1, y2, y3;
            var z1, z2, z3;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var d;
            var vertices = geomtrtData.vertexDatas;
            var posStride = 17;
            var posOffset = 3;
            //if (_useFaceWeights)
            //    _faceWeights ||= new Vector.<number>(len / 3, true);
            while (i < len) {
                index = posOffset + geomtrtData.indices[i++] * posStride;
                x1 = vertices[index];
                y1 = vertices[index + 1];
                z1 = vertices[index + 2];
                index = posOffset + geomtrtData.indices[i++] * posStride;
                x2 = vertices[index];
                y2 = vertices[index + 1];
                z2 = vertices[index + 2];
                index = posOffset + geomtrtData.indices[i++] * posStride;
                x3 = vertices[index];
                y3 = vertices[index + 1];
                z3 = vertices[index + 2];
                dx1 = x3 - x1;
                dy1 = y3 - y1;
                dz1 = z3 - z1;
                dx2 = x2 - x1;
                dy2 = y2 - y1;
                dz2 = z2 - z1;
                cx = dz1 * dy2 - dy1 * dz2;
                cy = dx1 * dz2 - dz1 * dx2;
                cz = dy1 * dx2 - dx1 * dy2;
                d = Math.sqrt(cx * cx + cy * cy + cz * cz);
                // length of cross product = 2*triangle area
                if (true) {
                    var w = d * 10000;
                    if (w < 1)
                        w = 1;
                    geomtrtData.faceWeights[k++] = w;
                }
                d = 1 / d;
                geomtrtData.faceNormals[j++] = cx * d;
                geomtrtData.faceNormals[j++] = cy * d;
                geomtrtData.faceNormals[j++] = cz * d;
            }
            //_faceNormalsDirty = false;
        };
        /**
         * Updates the vertex normals based on the geometry.
         */
        GeometryData.updateVertexNormals = function (geomtrtData) {
            this.updateFaceNormals(geomtrtData);
            var v1;
            var f1 = 0, f2 = 1, f3 = 2;
            var lenV = geomtrtData.vertexDatas.length;
            var normalStride = 17;
            var normalOffset = 3;
            //target ||= new Vector.<Number>(lenV, true);
            //v1 = normalOffset;
            //while(v1 < lenV) {
            //    target[v1] = 0.0;
            //    target[v1 + 1] = 0.0;
            //    target[v1 + 2] = 0.0;
            //    v1 += normalStride;
            //}
            var i = 0, k = 0;
            var lenI = geomtrtData.indices.length;
            var index;
            var weight;
            while (i < lenI) {
                weight = geomtrtData.faceWeights[k++];
                index = normalOffset + geomtrtData.indices[i++] * normalStride;
                geomtrtData.vertexDatas[index] += geomtrtData.faceNormals[f1] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f2] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f3] * weight;
                index = normalOffset + geomtrtData.indices[i++] * normalStride;
                geomtrtData.vertexDatas[index] += geomtrtData.faceNormals[f1] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f2] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f3] * weight;
                index = normalOffset + geomtrtData.indices[i++] * normalStride;
                geomtrtData.vertexDatas[index] += geomtrtData.faceNormals[f1] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f2] * weight;
                geomtrtData.vertexDatas[index++] += geomtrtData.faceNormals[f3] * weight;
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            //v1 = normalOffset;
            //    while(v1 < lenV) {
            //        var vx: Number = target[v1];
            //        var vy: Number = target[v1 + 1];
            //        var vz: Number = target[v1 + 2];
            //        var d: Number = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
            //        target[v1] = vx * d;
            //        target[v1 + 1] = vy * d;
            //        target[v1 + 2] = vz * d;
            //        v1 += normalStride;
            //    }
            //_vertexNormalsDirty = false;
        };
        GeometryData.buildFaceTangents = function (geomtryData) {
            var iDebug = 0;
            for (var i = 0; i < geomtryData.indices.length; i++) {
                geomtryData.vertices.push(geomtryData.vertexDatas[i * geomtryData.vertexAttLength], geomtryData.vertexDatas[i * geomtryData.vertexAttLength + 1], geomtryData.vertexDatas[i * geomtryData.vertexAttLength + 2]);
                geomtryData.uvs.push(geomtryData.vertexDatas[i * geomtryData.vertexAttLength + 13], geomtryData.vertexDatas[i * geomtryData.vertexAttLength + 14]);
            }
            GeometryData.updateFaceTangents(geomtryData);
        };
        GeometryData.updateFaceTangents = function (geomtrtData) {
            var i = 0;
            var index1, index2, index3;
            var len = geomtrtData.indices.length;
            var ui, vi;
            var v0;
            var dv1, dv2;
            var denom;
            var x0, y0, z0;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var vertices = geomtrtData.vertices;
            var uvs = geomtrtData.uvs;
            var posStride = 3;
            var posOffset = 0;
            var texStride = 2;
            var texOffset = 0;
            while (i < len) {
                index1 = geomtrtData.indices[i];
                index2 = geomtrtData.indices[i + 1];
                index3 = geomtrtData.indices[i + 2];
                ui = index1 * 2;
                v0 = uvs[ui + 1];
                ui = index2 * 2;
                dv1 = uvs[ui + 1] - v0;
                ui = index3 * 2;
                dv2 = uvs[ui + 1] - v0;
                vi = index1 * 3;
                x0 = vertices[vi];
                y0 = vertices[vi + 1];
                z0 = vertices[vi + 2];
                vi = index2 * 3;
                dx1 = vertices[vi] - x0;
                dy1 = vertices[vi + 1] - y0;
                dz1 = vertices[vi + 2] - z0;
                vi = index3 * 3;
                dx2 = vertices[vi] - x0;
                dy2 = vertices[vi + 1] - y0;
                dz2 = vertices[vi + 2] - z0;
                cx = dv2 * dx1 - dv1 * dx2;
                cy = dv2 * dy1 - dv1 * dy2;
                cz = dv2 * dz1 - dv1 * dz2;
                denom = 1 / Math.sqrt(cx * cx + cy * cy + cz * cz);
                geomtrtData.tangts[i++] = denom * cx;
                geomtrtData.tangts[i++] = denom * cy;
                geomtrtData.tangts[i++] = denom * cz;
            }
            var i;
            var lenV = geomtrtData.vertexDatas.length;
            var tangentStride = geomtrtData.vertexAttLength;
            var tangentOffset = 6;
            var target = geomtrtData.vertexDatas;
            i = tangentOffset;
            while (i < lenV) {
                target[i] = 0.0;
                target[i + 1] = 0.0;
                target[i + 2] = 0.0;
                i += tangentStride;
            }
            var k;
            var lenI = len;
            var index;
            var weight;
            var f1 = 0, f2 = 1, f3 = 2;
            i = 0;
            while (i < lenI) {
                weight = 1;
                index = tangentOffset + geomtrtData.indices[i++] * tangentStride;
                target[index++] += -geomtrtData.tangts[f1] * weight;
                target[index++] += geomtrtData.tangts[f2] * weight;
                target[index] += geomtrtData.tangts[f3] * weight;
                index = tangentOffset + geomtrtData.indices[i++] * tangentStride;
                target[index++] += -geomtrtData.tangts[f1] * weight;
                target[index++] += geomtrtData.tangts[f2] * weight;
                target[index] += geomtrtData.tangts[f3] * weight;
                index = tangentOffset + geomtrtData.indices[i++] * tangentStride;
                target[index++] += -geomtrtData.tangts[f1] * weight;
                target[index++] += geomtrtData.tangts[f2] * weight;
                target[index] += geomtrtData.tangts[f3] * weight;
                f1 += 3;
                f2 += 3;
                f3 += 3;
            }
            i = tangentOffset;
            while (i < lenV) {
                var vx = target[i];
                var vy = target[i + 1];
                var vz = target[i + 2];
                var d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
                target[i] = vx * d;
                target[i + 1] = vy * d;
                target[i + 2] = vz * d;
                i += tangentStride;
            }
        };
        return GeometryData;
    })();
    egret3d.GeometryData = GeometryData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.GeometryBase
     * @classdesc
     * 网格类型类型
     * @version Egret 3.0
     * @platform Web,Native
     */
    (function (GeometryType) {
        /**
        * @language zh_CN
        * 静态模型类型
        */
        GeometryType[GeometryType["Static"] = 0] = "Static";
        /**
        * @language zh_CN
        * 骨骼动画模型类型
        */
        GeometryType[GeometryType["Skin"] = 1] = "Skin";
        /**
        * @language zh_CN
        * 粒子类型
        */
        GeometryType[GeometryType["Particle"] = 2] = "Particle";
        /**
        * @language zh_CN
        * 公告板类型
        */
        GeometryType[GeometryType["Billbord"] = 3] = "Billbord";
        /**
        * @language zh_CN
        * 顶点动画类型
        */
        GeometryType[GeometryType["VertexAnim"] = 4] = "VertexAnim";
        /**
        * @language zh_CN
        * 草地类型
        */
        GeometryType[GeometryType["Grass"] = 5] = "Grass";
        /**
        * @language zh_CN
        * 带形状类型
        */
        GeometryType[GeometryType["Ribbon"] = 6] = "Ribbon";
        /**
        * @language zh_CN
        * 线框类型
        */
        GeometryType[GeometryType["wrieFrame"] = 7] = "wrieFrame";
        /**
        * @language zh_CN
        * 影引类型
        */
        GeometryType[GeometryType["Shadow"] = 8] = "Shadow";
    })(egret3d.GeometryType || (egret3d.GeometryType = {}));
    var GeometryType = egret3d.GeometryType;
    /**
     * @private
     * @language zh_CN
     * @class egret3d.GeometryBase
     * @classdesc
     * GeometryBase类 表示几何形状基类
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/GeometryBase.ts
     */
    var GeometryBase = (function () {
        /**
        * @language zh_CN
        * 构造函数
        */
        function GeometryBase() {
            /**
            * @language zh_CN
            * 网格类型
            */
            this.geomtryType = 0;
            /**
            * @language zh_CN
            * 顶点属性长度
            */
            this.vertexAttLength = 17;
            /**
            * @language zh_CN
            * 顶点坐标大小
            */
            this.positionSize = 3;
            /**
            * @language zh_CN
            * 顶点法线大小
            */
            this.normalSize = 3;
            /**
            * @language zh_CN
            * 顶点切线大小
            */
            this.tangentSize = 3;
            /**
            * @language zh_CN
            * 顶点色大小
            */
            this.colorSize = 4;
            /**
            * @language zh_CN
            * 顶点uv大小
            */
            this.uvSize = 2;
            /**
            * @language zh_CN
            * 顶点uv2大小
            */
            this.uv2Size = 2;
            /**
            * @language zh_CN
            * Item数
            */
            this.numItems = 0;
            /**
            * @language zh_CN
            * 包围盒min pos
            */
            this.minPos = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 包围盒max pos
            */
            this.maxPos = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 漫反射贴图名
            */
            this.textureFile = "";
            /**
            * @language zh_CN
            * 高光贴图名
            */
            this.textureSpecular = "";
            /**
            * @language zh_CN
            * 法线贴图名
            */
            this.textureBump = "";
        }
        /**
        * @language zh_CN
        * 生成网格
        */
        GeometryBase.prototype.buildGeomtry = function () {
        };
        /**
        * @language zh_CN
        * 数据更新
        * @param time 当前时间
        * @param delay 每帧间隔时间
        */
        GeometryBase.prototype.updata = function (time, delay) {
        };
        /**
        * @language zh_CN
        * 生成包围盒
        */
        GeometryBase.prototype.buildBoundBox = function () {
            this.minPos.copyFrom(new egret3d.Vector3D(99999.0, 99999.0, 99999.0));
            this.maxPos.copyFrom(new egret3d.Vector3D(-99999.0, -99999.0, -99999.0));
            for (var i = 0; i < this.verticesData.length; i += this.vertexAttLength) {
                if (this.maxPos.x < this.verticesData[i]) {
                    this.maxPos.x = this.verticesData[i];
                }
                if (this.maxPos.y < this.verticesData[i + 1]) {
                    this.maxPos.y = this.verticesData[i + 1];
                }
                if (this.maxPos.z < this.verticesData[i + 2]) {
                    this.maxPos.z = this.verticesData[i + 2];
                }
                if (this.minPos.x > this.verticesData[i]) {
                    this.minPos.x = this.verticesData[i];
                }
                if (this.minPos.y > this.verticesData[i + 1]) {
                    this.minPos.y = this.verticesData[i + 1];
                }
                if (this.minPos.z > this.verticesData[i + 2]) {
                    this.minPos.z = this.verticesData[i + 2];
                }
            }
        };
        /**
        * @language zh_CN
        * 转旋网格的每个顶点
        * @param euler 转旋欧拉角
        */
        GeometryBase.prototype.rotationGeomtry = function (euler) {
            this.rotationQ = new egret3d.Quaternion();
            this.rotationQ.fromEulerAngles(euler.x * egret3d.Matrix3DUtils.RADIANS_TO_DEGREES, euler.y * egret3d.Matrix3DUtils.RADIANS_TO_DEGREES, euler.z * egret3d.Matrix3DUtils.RADIANS_TO_DEGREES);
            var pos = new egret3d.Vector3D();
            for (var i = 0; i < this.verticesData.length / this.vertexAttLength; i++) {
                pos.x = this.verticesData[this.vertexAttLength * i + 0];
                pos.y = this.verticesData[this.vertexAttLength * i + 1];
                pos.z = this.verticesData[this.vertexAttLength * i + 2];
                this.rotationQ.rotatePoint(pos, pos);
                this.verticesData[this.vertexAttLength * i + 0] = pos.x;
                this.verticesData[this.vertexAttLength * i + 1] = pos.y;
                this.verticesData[this.vertexAttLength * i + 2] = pos.z;
            }
        };
        GeometryBase.prototype.dispose = function () {
        };
        return GeometryBase;
    })();
    egret3d.GeometryBase = GeometryBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.SubGeometry
     * @classdesc
     * SubGeometry类
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/SubGeometry.ts
     */
    var SubGeometry = (function (_super) {
        __extends(SubGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        */
        function SubGeometry() {
            _super.call(this);
        }
        /**
        * @language zh_CN
        * 设置网格数据
        * @param indexData 顶点
        * @param vertexData: 索引
        */
        SubGeometry.prototype.setGeomtryData = function (indexData, vertexData) {
            this.indexData = indexData;
            this.verticesData = vertexData;
            this.numItems = indexData.length;
        };
        return SubGeometry;
    })(egret3d.GeometryBase);
    egret3d.SubGeometry = SubGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.CubeGeometry
     * @classdesc
     * CubeGeometry类 表示立方体
     *
     * 示例：
     * //用 CubeGeometry 对象创建一个mesh，并给予默认纹理材质TextureMaterial（默认为棋盘格纹理）;
     * var box: egret3d.Mesh = new egret3d.Mesh( new egret3d.CubeGeometry(), new egret3d.TextureMaterial() );
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/CubeGeometry.ts
     */
    var CubeGeometry = (function (_super) {
        __extends(CubeGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param width 宽度
        * @param height 高度
        * @param depth 深度
        */
        function CubeGeometry(width, height, depth) {
            if (width === void 0) { width = 80; }
            if (height === void 0) { height = 80; }
            if (depth === void 0) { depth = 80; }
            _super.call(this);
            /**
            * @language zh_CN
            * Cube宽度
            *
            */
            this.width = 80;
            /**
            * @language zh_CN
            * Cube高度
            *
            */
            this.height = 80;
            /**
            * @language zh_CN
            * Cube深度
            *
            */
            this.depth = 80;
            this.width = width;
            this.height = height;
            this.depth = depth;
            this.buildGeomtry();
        }
        /**
        * @language zh_CN
        * 生成网格
        */
        CubeGeometry.prototype.buildGeomtry = function () {
            var vertices = new Array();
            vertices.push(-this.width, -this.height, -this.depth, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, -this.width, this.height, -this.depth, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, this.width, this.height, -this.depth, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0, this.width, this.height, -this.depth, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0, this.width, -this.height, -this.depth, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, -this.width, -this.height, -this.depth, 0.0, 0.0, -10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, -this.width, -this.height, this.depth, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, this.width, -this.height, this.depth, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, this.width, this.height, this.depth, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, this.width, this.height, this.depth, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, -this.width, this.height, this.depth, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0, -this.width, -this.height, this.depth, 0.0, 0.0, 10.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, -this.width, -this.height, -this.depth, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, this.width, -this.height, -this.depth, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, this.width, -this.height, this.depth, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, this.width, -this.height, this.depth, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, -this.width, -this.height, this.depth, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0, -this.width, -this.height, -this.depth, 0.0, -10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, this.width, -this.height, -this.depth, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, this.width, this.height, -this.depth, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, this.width, this.height, this.depth, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, this.width, this.height, this.depth, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, this.width, -this.height, this.depth, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0, this.width, -this.height, -this.depth, 10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, this.width, this.height, -this.depth, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, -this.width, this.height, -this.depth, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, -this.width, this.height, this.depth, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, -this.width, this.height, this.depth, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, this.width, this.height, this.depth, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0, this.width, this.height, -this.depth, 0.0, 10.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, -this.width, this.height, -this.depth, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0, -this.width, -this.height, -this.depth, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, -this.width, -this.height, this.depth, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, -this.width, -this.height, this.depth, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 1.0, 1.0, 0, 0, -this.width, this.height, this.depth, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 1.0, 0, 0, -this.width, this.height, -this.depth, -10.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1, 1, 1, 1, 0.0, 0.0, 0, 0);
            var cubeVertexIndices = new Array();
            cubeVertexIndices.push(0, 2, 1, 3, 5, 4, 6, 8, 7, 9, 11, 10, 12, 14, 13, 15, 17, 16, 18, 20, 19, 21, 23, 22, 24, 26, 25, 27, 29, 28, 30, 32, 31, 33, 35, 34);
            this.setGeomtryData(cubeVertexIndices, vertices);
            this.buildBoundBox();
        };
        return CubeGeometry;
    })(egret3d.SubGeometry);
    egret3d.CubeGeometry = CubeGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.SphereGeometry
     * @classdesc
     * SphereGeometry类 表示球体
     *
     * 示例：
     * //用 SphereGeometry 对象创建一个mesh，并给予默认纹理材质TextureMaterial（默认为棋盘格纹理）;
     * var box: egret3d.Mesh = new egret3d.Mesh( new egret3d.SphereGeometry(), new egret3d.TextureMaterial() );
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/SphereGeometry.ts
     */
    var SphereGeometry = (function (_super) {
        __extends(SphereGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param r 半径
        * @param segmentsW 宽度分段数
        * @param segmentsH 高度分段数
        */
        function SphereGeometry(r, segmentsW, segmentsH) {
            if (r === void 0) { r = 100.0; }
            if (segmentsW === void 0) { segmentsW = 15; }
            if (segmentsH === void 0) { segmentsH = 15; }
            _super.call(this);
            this._segmentsW = 50;
            this._segmentsH = 50;
            this._radius = 100;
            this._radius = r;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this.buildSphere();
        }
        SphereGeometry.prototype.buildSphere = function () {
            var vertices;
            var indices;
            var i = 0, j = 0, triIndex = 0;
            var numVerts = (this._segmentsH + 1) * (this._segmentsW + 1);
            var stride = this.vertexAttLength;
            var skip = stride - 9;
            vertices = new Array(numVerts * stride);
            indices = new Array((this._segmentsH - 1) * this._segmentsW * 6);
            var startIndex = 0;
            var index = 0;
            var comp1 = 0, comp2 = 0, t1 = 0, t2 = 0;
            for (j = 0; j <= this._segmentsH; ++j) {
                startIndex = index;
                var horangle = Math.PI * j / this._segmentsH;
                var z = -this._radius * Math.cos(horangle);
                var ringradius = this._radius * Math.sin(horangle);
                for (i = 0; i <= this._segmentsW; ++i) {
                    var verangle = 2 * Math.PI * i / this._segmentsW;
                    var x = ringradius * Math.cos(verangle);
                    var y = ringradius * Math.sin(verangle);
                    var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
                    var tanLen = Math.sqrt(y * y + x * x);
                    t1 = 0;
                    t2 = tanLen > .007 ? x / tanLen : 0;
                    comp1 = -z;
                    comp2 = y;
                    if (i == this._segmentsW) {
                        vertices[index++] = vertices[startIndex];
                        vertices[index++] = vertices[startIndex + 1];
                        vertices[index++] = vertices[startIndex + 2];
                        vertices[index++] = x * normLen;
                        ;
                        vertices[index++] = comp1 * normLen;
                        ;
                        vertices[index++] = comp2 * normLen;
                        ;
                        vertices[index++] = tanLen > .007 ? -y / tanLen : 1;
                        vertices[index++] = t1;
                        vertices[index++] = t2;
                        vertices[index + 0] = 1.0;
                        vertices[index + 1] = 1.0;
                        vertices[index + 2] = 1.0;
                        vertices[index + 3] = 1.0;
                    }
                    else {
                        vertices[index++] = x;
                        vertices[index++] = comp1;
                        vertices[index++] = comp2;
                        vertices[index++] = x * normLen;
                        vertices[index++] = comp1 * normLen;
                        vertices[index++] = comp2 * normLen;
                        vertices[index++] = tanLen > .007 ? -y / tanLen : 1;
                        vertices[index++] = t1;
                        vertices[index++] = t2;
                        vertices[index] = 1.0;
                        vertices[index + 1] = 1.0;
                        vertices[index + 2] = 1.0;
                        vertices[index + 3] = 1.0;
                    }
                    if (i > 0 && j > 0) {
                        var a = (this._segmentsW + 1) * j + i;
                        var b = (this._segmentsW + 1) * j + i - 1;
                        var c = (this._segmentsW + 1) * (j - 1) + i - 1;
                        var d = (this._segmentsW + 1) * (j - 1) + i;
                        if (j == this._segmentsH) {
                            vertices[index - 9] = vertices[startIndex];
                            vertices[index - 8] = vertices[startIndex + 1];
                            vertices[index - 7] = vertices[startIndex + 2];
                            indices[triIndex++] = a;
                            indices[triIndex++] = d;
                            indices[triIndex++] = c;
                        }
                        else if (j == 1) {
                            indices[triIndex++] = a;
                            indices[triIndex++] = c;
                            indices[triIndex++] = b;
                        }
                        else {
                            indices[triIndex++] = a;
                            indices[triIndex++] = d;
                            indices[triIndex++] = c;
                            indices[triIndex++] = a;
                            indices[triIndex++] = c;
                            indices[triIndex++] = b;
                        }
                    }
                    index += skip;
                }
            }
            //var i: number, j: number;
            var stride = 17;
            var numUvs = (this._segmentsH + 1) * (this._segmentsW + 1) * stride;
            var data;
            var skip = stride - 2;
            var index = 13;
            for (j = 0; j <= this._segmentsH; ++j) {
                for (i = 0; i <= this._segmentsW; ++i) {
                    vertices[index++] = (i / this._segmentsW);
                    vertices[index++] = (j / this._segmentsH);
                    index += skip;
                }
            }
            this.setGeomtryData(indices, vertices);
        };
        return SphereGeometry;
    })(egret3d.SubGeometry);
    egret3d.SphereGeometry = SphereGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.PlaneGeometry
     * @classdesc
     * PlaneGeometry类 表示面板几何体
     *
     * 示例：
     * //用 PlaneGeometry 对象创建一个mesh，并给予默认纹理材质TextureMaterial（默认为棋盘格纹理）;
     * var box: egret3d.Mesh = new egret3d.Mesh( new egret3d.PlaneGeometry(), new egret3d.TextureMaterial() );
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/PlaneGeometry.ts
     */
    var PlaneGeometry = (function (_super) {
        __extends(PlaneGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param width 宽度
        * @param height 高度
        * @param segmentsW 宽度分段数
        * @param segmentsH 高度分段数
        * @param uScale U缩放
        * @param vScale V缩放
        */
        function PlaneGeometry(width, height, segmentsW, segmentsH, uScale, vScale) {
            if (width === void 0) { width = 500; }
            if (height === void 0) { height = 500; }
            if (segmentsW === void 0) { segmentsW = 1; }
            if (segmentsH === void 0) { segmentsH = 1; }
            if (uScale === void 0) { uScale = 1; }
            if (vScale === void 0) { vScale = 1; }
            _super.call(this);
            this._segmentsW = 1;
            this._segmentsH = 1;
            this._width = 500.0;
            this._height = 500.0;
            this._scaleU = 1;
            this._scaleV = 1;
            this._width = width;
            this._height = height;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._scaleU = uScale;
            this._scaleV = vScale;
            this.buildGeometry();
        }
        PlaneGeometry.prototype.buildGeometry = function () {
            var vertices;
            var indices;
            var x, y;
            var numIndices;
            var base;
            var tw = this._segmentsW + 1;
            var numVertices = (this._segmentsH + 1) * tw;
            var stride = this.vertexAttLength;
            var skip = stride - 15;
            numIndices = this._segmentsH * this._segmentsW * 6;
            vertices = new Array(numVertices * stride);
            indices = new Array(numIndices);
            numIndices = 0;
            var point = new egret3d.Vector3D();
            var index = 0;
            for (var yi = 0; yi <= this._segmentsH; ++yi) {
                for (var xi = 0; xi <= this._segmentsW; ++xi) {
                    x = (xi / this._segmentsW - .5) * this._width;
                    y = (yi / this._segmentsH - .5) * this._height;
                    vertices[index++] = x;
                    vertices[index++] = 0;
                    vertices[index++] = y;
                    vertices[index++] = 0;
                    vertices[index++] = 1;
                    vertices[index++] = 0;
                    vertices[index++] = 1;
                    vertices[index++] = 0;
                    vertices[index++] = 0;
                    vertices[index++] = 1;
                    vertices[index++] = 1;
                    vertices[index++] = 1;
                    vertices[index++] = 1;
                    vertices[index++] = (xi / this._segmentsW) * this._scaleU;
                    vertices[index++] = (1 - yi / this._segmentsH) * this._scaleV;
                    index += skip;
                    if (xi != this._segmentsW && yi != this._segmentsH) {
                        base = xi + yi * tw;
                        var mult = 1;
                        indices[numIndices++] = base * mult;
                        indices[numIndices++] = (base + tw + 1) * mult;
                        indices[numIndices++] = (base + tw) * mult;
                        indices[numIndices++] = base * mult;
                        indices[numIndices++] = (base + 1) * mult;
                        indices[numIndices++] = (base + tw + 1) * mult;
                    }
                }
            }
            this.setGeomtryData(indices, vertices);
            this.buildBoundBox();
        };
        return PlaneGeometry;
    })(egret3d.SubGeometry);
    egret3d.PlaneGeometry = PlaneGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.CylinderGeometry
     * @classdesc
     * CylinderGeometry类 表示圆柱体
     *
     * 示例：
     * //用 CylinderGeometry 对象创建一个mesh，并给予默认纹理材质TextureMaterial（默认为棋盘格纹理）;
     * var box: egret3d.Mesh = new egret3d.Mesh( new egret3d.CylinderGeometry(), new egret3d.TextureMaterial() );
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/CylinderGeometry.ts
     */
    var CylinderGeometry = (function (_super) {
        __extends(CylinderGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        */
        function CylinderGeometry() {
            _super.call(this);
            this.buildGeomtry();
        }
        /**
        * @language zh_CN
        * 生成网格
        */
        CylinderGeometry.prototype.buildGeomtry = function () {
            var vertices = new Array();
            var vertexIndices = new Array();
            var m_nSegments = 10;
            var m_rRadius = 10;
            var m_rHeight = 60;
            var nCurrentSegment = 10;
            var rDeltaSegAngle = (2.0 * Math.PI / m_nSegments);
            var rSegmentLength = 1.0 / m_nSegments;
            for (nCurrentSegment = 0; nCurrentSegment <= m_nSegments; nCurrentSegment++) {
                var x0 = m_rRadius * Math.sin(nCurrentSegment * rDeltaSegAngle);
                var z0 = m_rRadius * Math.cos(nCurrentSegment * rDeltaSegAngle);
                vertices.push(x0, 0.0 + (m_rHeight / 2.0), z0, x0, 0.0, z0, 1, 1, 1, 1, 1.0, 0.0, 0, 0, x0, 0.0 - (m_rHeight / 2.0), z0, x0, 0.0, z0, 1, 1, 1, 1, 1.0, 0.0, 0, 0);
            }
            vertices.push(0.0, 0.0 + (m_rHeight / 2.0), 0.0, 0.0, 1.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0);
            for (nCurrentSegment = 0; nCurrentSegment <= m_nSegments; nCurrentSegment++) {
                var x0 = m_rRadius * Math.sin(nCurrentSegment * rDeltaSegAngle);
                var z0 = m_rRadius * Math.cos(nCurrentSegment * rDeltaSegAngle);
                //float tu0 = (0.5f * sinf(nCurrentSegment * rDeltaSegAngle)) + 0.5f;
                //float tv0 = (0.5f * cosf(nCurrentSegment * rDeltaSegAngle)) + 0.5f;
                vertices.push(x0, 0.0 + (m_rHeight / 2.0), z0, 0.0, 1.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0);
            }
            vertices.push(0.0, 0.0 - (m_rHeight / 2.0), 0.0, 0.0, -1.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0);
            for (nCurrentSegment = m_nSegments; nCurrentSegment >= 0; nCurrentSegment--) {
                var x0 = m_rRadius * Math.sin(nCurrentSegment * rDeltaSegAngle);
                var z0 = m_rRadius * Math.cos(nCurrentSegment * rDeltaSegAngle);
                vertices.push(x0, 0.0 - (m_rHeight / 2.0), z0, 0.0, -1.0, 0.0, 1, 1, 1, 1, 1.0, 0.0, 0, 0);
            }
            this.setGeomtryData(vertexIndices, vertices);
        };
        return CylinderGeometry;
    })(egret3d.SubGeometry);
    egret3d.CylinderGeometry = CylinderGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.FaceData
     * @classdesc
     * FaceData类 表示三角面索引数据
     *
     * FaceData用于储存三角面所需的各类索引数据，如顶点索引、UV纹理索引、法线索引、定点颜色索引等。
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/FaceData.ts
     */
    var FaceData = (function () {
        function FaceData() {
            /**
            * @language zh_CN
            * 顶点索引数据
            */
            this.vertexIndices = new Array();
            /**
            * @language zh_CN
            * uv索引数据
            */
            this.uvIndices = new Array();
            /**
            * @language zh_CN
            * uv2索引数据
            */
            this.uv2Indices = new Array();
            /**
            * @language zh_CN
            * 法线索引数据
            */
            this.normalIndices = new Array();
            /**
            * @language zh_CN
            * 顶点色索引数据
            */
            this.colorIndices = new Array();
            /**
            * @language zh_CN
            * 索引数据数组
            */
            this.indexIds = new Array(); // used for real index lookups
        }
        return FaceData;
    })();
    egret3d.FaceData = FaceData;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.SkinGeometry
     * @classdesc
     * SkinGeometry类 表示带有蒙皮信息的几何图形。
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/SkinGeometry.ts
     */
    var SkinGeometry = (function (_super) {
        __extends(SkinGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        */
        function SkinGeometry() {
            _super.call(this);
            this.geomtryType = egret3d.GeometryType.Skin;
        }
        /**
        * @language zh_CN
        * 设置网格数据
        * @param indexData 顶点
        * @param vertexData: 索引
        * @param skeleton: 骨骼
        */
        SkinGeometry.prototype.setGeomtryData = function (indexData, vertexData, skeleton) {
            this.indexData = indexData;
            this.verticesData = vertexData;
            this.numItems = indexData.length;
            this.initialSkeleton = skeleton;
        };
        return SkinGeometry;
    })(egret3d.GeometryBase);
    egret3d.SkinGeometry = SkinGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.ElevationGeometry
     * @classdesc
     * ElevationGeometry类 表示高度图几何图形
     *
     * 高度图几何图形常用于做场景地形，其由一张色彩图片记录高度信息，在程序中解析该色彩图生成相应大小高度的模型网格，以达到逼真动态地形。
     *
     * @version Egret 3.0
     * @platform Web,Native
     * @includeExample geometry/ElevationGeometry.ts
     */
    var ElevationGeometry = (function (_super) {
        __extends(ElevationGeometry, _super);
        /**
        * @language zh_CN
        * 构造函数
        * @param heightmap 附带高度信息的高度图纹理
        * @param width 宽度
        * @param height 高度
        * @param depth 深度
        * @param segmentsW 宽度片段数
        * @param segmentsH 高度片段数
        * @param maxElevation 最大高度
        * @param minElevation 最小高度
        */
        function ElevationGeometry(heightmap, width, height, depth, segmentsW, segmentsH, maxElevation, minElevation) {
            if (width === void 0) { width = 1000; }
            if (height === void 0) { height = 100; }
            if (depth === void 0) { depth = 1000; }
            if (segmentsW === void 0) { segmentsW = 30; }
            if (segmentsH === void 0) { segmentsH = 30; }
            if (maxElevation === void 0) { maxElevation = 255; }
            if (minElevation === void 0) { minElevation = 0; }
            _super.call(this);
            this._scaleU = 1.0;
            this._scaleV = 1.0;
            this._segmentsW = segmentsW;
            this._segmentsH = segmentsH;
            this._width = width;
            this._height = height;
            this._depth = depth;
            this._minElevation = minElevation;
            this._maxElevation = maxElevation;
            this.heightmap = heightmap;
            this.canvas = document.createElement("canvas");
            this.ctx = this.canvas.getContext("2d");
            this.canvas.width = heightmap.width;
            this.canvas.height = heightmap.height;
            this.ctx.drawImage(heightmap.imageData, 0, 0, heightmap.width, heightmap.height);
            document.body.appendChild(this.canvas);
            this.canvas.hidden = true;
            this.imageData = this.ctx.getImageData(0, 0, this.heightmap.imageData.width, this.heightmap.imageData.height);
            this.buildElevationGeometry();
        }
        /**
        * @language zh_CN
        * 获取像素
        * @param x 纹理X位置
        * @param z 纹理Y位置
        */
        ElevationGeometry.prototype.getPixel = function (x, z) {
            var index = z * (this.heightmap.imageData.width * 4) + x * 4;
            var color = this.imageData.data[index + 3] << 24 | this.imageData.data[index + 0] << 16 | this.imageData.data[index + 1] << 8 | this.imageData.data[index + 2];
            return color;
        };
        /**
        * @language zh_CN
        * 获取高度值
        * @param x X位置
        * @param z Y位置
        */
        ElevationGeometry.prototype.getHeightBypos = function (x, z) {
            var color = this.getPixel(x, z);
            return (color > this._maxElevation) ? (this._maxElevation / 0xff) * this._height : ((color < this._minElevation) ? (this._minElevation / 0xff) * this._height : (color / 0xff) * this._height);
        };
        ElevationGeometry.prototype.buildElevationGeometry = function () {
            var vertices;
            var indices;
            var x, z;
            var numInds;
            var base;
            var tw = this._segmentsW + 1;
            var numVerts = (this._segmentsH + 1) * tw;
            var uDiv = (this.heightmap.width - 1) / this._segmentsW;
            var vDiv = (this.heightmap.height - 1) / this._segmentsH;
            var u, v;
            var y;
            //if (numVerts == this._subGeometry.numVertices) {
            //    vertices = this._subGeometry.vertexData;
            //    indices = this._subGeometry.indexData;
            // } else {
            vertices = new Array(numVerts * 3);
            indices = new Array(this._segmentsH * this._segmentsW * 6);
            //}
            numVerts = 0;
            numInds = 0;
            var col;
            for (var zi = 0; zi <= this._segmentsH; ++zi) {
                for (var xi = 0; xi <= this._segmentsW; ++xi) {
                    x = (xi / this._segmentsW - 0.5) * this._width;
                    z = (zi / this._segmentsH - 0.5) * this._depth;
                    u = Math.floor(xi * uDiv);
                    v = Math.floor((this._segmentsH - zi) * vDiv);
                    col = this.getPixel(u, v) & 0xff;
                    y = (col > this._maxElevation) ? (this._maxElevation / 0xff) * this._height : ((col < this._minElevation) ? (this._minElevation / 0xff) * this._height : (col / 0xff) * this._height);
                    //pos
                    vertices[numVerts++] = x;
                    vertices[numVerts++] = y; //Math.random() * 1000;;
                    vertices[numVerts++] = z;
                    //normal
                    vertices[numVerts++] = 1.0;
                    vertices[numVerts++] = 1.0;
                    vertices[numVerts++] = 1.0;
                    //tan
                    vertices[numVerts++] = -1.0;
                    vertices[numVerts++] = 0.0;
                    vertices[numVerts++] = 0.0;
                    //color
                    vertices[numVerts++] = 1.0;
                    vertices[numVerts++] = 1.0;
                    vertices[numVerts++] = 1.0;
                    vertices[numVerts++] = 1.0;
                    //uv
                    vertices[numVerts++] = xi / this._segmentsW * this._scaleU;
                    vertices[numVerts++] = zi / this._segmentsH * this._scaleV;
                    vertices[numVerts++] = xi / this._segmentsW;
                    vertices[numVerts++] = zi / this._segmentsH;
                    if (xi != this._segmentsW && zi != this._segmentsH) {
                        base = xi + zi * tw;
                        indices[numInds++] = base;
                        indices[numInds++] = base + tw + 1;
                        indices[numInds++] = base + tw;
                        indices[numInds++] = base;
                        indices[numInds++] = base + 1;
                        indices[numInds++] = base + tw + 1;
                    }
                }
            }
            this.indexData = indices;
            this.verticesData = vertices;
            this.numItems = indices.length;
            // this.updateFaceNormals();
            //this._subGeometry.autoDeriveVertexNormals = true;
            //this._subGeometry.autoDeriveVertexTangents = true;
            //this._subGeometry.updateVertexData(vertices);
            //this._subGeometry.updateIndexData(indices);
        };
        ElevationGeometry.prototype.updateFaceNormals = function () {
            var i = 0, j = 0, k = 0;
            var index;
            var len = this.indexData.length;
            var x1, x2, x3;
            var y1, y2, y3;
            var z1, z2, z3;
            var dx1, dy1, dz1;
            var dx2, dy2, dz2;
            var cx, cy, cz;
            var d;
            var vertices = this.verticesData;
            var posStride = 17;
            var posOffset = 0;
            while (i < len) {
                index = posOffset + this.indexData[i++] * posStride;
                x1 = vertices[index];
                y1 = vertices[index + 1];
                z1 = vertices[index + 2];
                index = posOffset + this.indexData[i++] * posStride;
                x2 = vertices[index];
                y2 = vertices[index + 1];
                z2 = vertices[index + 2];
                index = posOffset + this.indexData[i++] * posStride;
                x3 = vertices[index];
                y3 = vertices[index + 1];
                z3 = vertices[index + 2];
                dx1 = x3 - x1;
                dy1 = y3 - y1;
                dz1 = z3 - z1;
                dx2 = x2 - x1;
                dy2 = y2 - y1;
                dz2 = z2 - z1;
                cx = dz1 * dy2 - dy1 * dz2;
                cy = dx1 * dz2 - dz1 * dx2;
                cz = dy1 * dx2 - dx1 * dy2;
                d = Math.sqrt(cx * cx + cy * cy + cz * cz);
                // length of cross product = 2*triangle area
                //if (true) {
                //    var w: number = d * 10000;
                //    if (w < 1)
                //        w = 1;
                //    geomtrtData.faceWeights[k++] = w;
                //}
                d = 1 / d;
                vertices[j * posStride + 3] = cx * d;
                vertices[j * posStride + 4] = cy * d;
                vertices[j * posStride + 5] = cz * d;
                j++;
            }
        };
        return ElevationGeometry;
    })(egret3d.GeometryBase);
    egret3d.ElevationGeometry = ElevationGeometry;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.GeometryUtil
    * @classdesc
    * 网格工具类
    */
    var GeometryUtil = (function () {
        function GeometryUtil() {
        }
        /**
        * @language zh_CN
        * 打包模型数据
        * @param num 顶点数
        * @param vertexLen 顶点长度
        * @param source 模型数据
        * @returns 打包后的模型
        */
        GeometryUtil.packageGeometry = function (num, vertexLen, source) {
            source.numberOfVertices = source.verticesData.length / source.vertexAttLength;
            var geometry = new egret3d.SubGeometry();
            var vertexAttLength = source.vertexAttLength;
            var newGeometryNumberOfVertices = source.numberOfVertices * vertexLen;
            var vertexData = new Array(newGeometryNumberOfVertices * num);
            var indexData = new Array(num * source.indexData.length);
            for (var i = 0; i < num; i++) {
                for (var j = 0; j < source.numberOfVertices; j++) {
                    vertexData[(j * vertexLen + 0) + i * newGeometryNumberOfVertices] = source.verticesData[j * vertexAttLength + 0];
                    vertexData[(j * vertexLen + 1) + i * newGeometryNumberOfVertices] = source.verticesData[j * vertexAttLength + 1];
                    vertexData[(j * vertexLen + 2) + i * newGeometryNumberOfVertices] = source.verticesData[j * vertexAttLength + 2];
                    vertexData[(j * vertexLen + 3) + i * newGeometryNumberOfVertices] = i;
                    vertexData[(j * vertexLen + 4) + i * newGeometryNumberOfVertices] = 0;
                    vertexData[(j * vertexLen + 5) + i * newGeometryNumberOfVertices] = 0;
                    vertexData[(j * vertexLen + 6) + i * newGeometryNumberOfVertices] = 0;
                    vertexData[(j * vertexLen + 7) + i * newGeometryNumberOfVertices] = source.verticesData[j * vertexAttLength + 13];
                    vertexData[(j * vertexLen + 8) + i * newGeometryNumberOfVertices] = source.verticesData[j * vertexAttLength + 14];
                }
            }
            for (var i = 0; i < num; i++) {
                for (var j = 0; j < source.indexData.length; j++) {
                    indexData[j + i * source.indexData.length] = source.indexData[j] + i * source.numberOfVertices;
                }
            }
            geometry.setGeomtryData(indexData, vertexData);
            geometry.geometryNum = num;
            geometry.vertexAttLength = vertexLen;
            geometry.numberOfVertices = geometry.verticesData.length / geometry.vertexAttLength;
            return geometry;
        };
        return GeometryUtil;
    })();
    egret3d.GeometryUtil = GeometryUtil;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Mesh
    * @classdesc
    * 3d模型网格 生成渲染模型
    * 创建一个Mesh网格数据和材质数据是必需的，如果是动态模型就加上动画数据
    * 继承Object3D对象，场景中实体渲染对象
    *
    * @see egret3d.core.node.Object3D
    * @see egret3d.geometry.GeometryBase
    * @see egret3d.material.MaterialBase
    * @see egret3d.animation.IAnimation
    *
    * 示例:
    * @includeExample core/node/Mesh.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Mesh = (function (_super) {
        __extends(Mesh, _super);
        /**
        * @language zh_CN
        * 构建一个Mesh对象
        * @param geometry 模型数据
        * @param material 模型材质
        * @param animation 模型动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Mesh(geometry, material, animation) {
            if (animation === void 0) { animation = null; }
            _super.call(this);
            this.geometry = geometry;
            this.material = material;
            this.animation = animation;
            this.box.fillBox(this.geometry.minPos, this.geometry.maxPos);
        }
        /**
        * @language zh_CN
        * 克隆一个模型
        * @returns 克隆后的模型
        * @version Egret 3.0
        * @platform Web,Native
        */
        Mesh.prototype.clone = function () {
            return new Mesh(this.geometry, this.material, this.animation ? this.animation.clone() : null);
        };
        /**
        * @language zh_CN
        * 当前对象数据更新，只有在视锥内的对象才会执行此更新
        * @param camera 当前渲染的摄相机
        * @param time 当前时间
        * @param delay 每帧时间间隔
        * @version Egret 3.0
        * @platform Web,Native
        */
        Mesh.prototype.update = function (camera, time, delay) {
            if (this.isDisable)
                return;
            if (this.animation) {
                this.animation.updata(time, delay);
            }
        };
        return Mesh;
    })(egret3d.Object3D);
    egret3d.Mesh = Mesh;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    (function (LoaderType) {
        LoaderType[LoaderType["LOADER_MODEL_TYPE"] = 0] = "LOADER_MODEL_TYPE";
        LoaderType[LoaderType["LOADER_SCENE_TYPE"] = 1] = "LOADER_SCENE_TYPE";
        LoaderType[LoaderType["LOADER_TEXTURE_TYPE"] = 2] = "LOADER_TEXTURE_TYPE";
    })(egret3d.LoaderType || (egret3d.LoaderType = {}));
    var LoaderType = egret3d.LoaderType;
    /**
     * @language zh_CN
     * @class egret3d.BaseLoader
     * @classdesc
     * BaseLoader类
     * @private
     */
    var BaseLoader = (function (_super) {
        __extends(BaseLoader, _super);
        /**
         * @language zh_CN
         * constructor
         * @param type
         * @param url
         */
        function BaseLoader(type, url) {
            if (url === void 0) { url = null; }
            _super.call(this);
            this.type = type;
            this.url = url;
        }
        /**
         * @language zh_CN
         *  加载场景;
         * @param url场景URL路径目录;
         * @returns {}
         */
        BaseLoader.prototype.load = function (url) {
            if (url === void 0) { url = null; }
            if (url != null) {
                this.url = url;
            }
            if (null == this.url)
                return;
            this.onLoad();
        };
        /**
         * @language zh_CN
         */
        BaseLoader.prototype.onLoad = function () {
        };
        return BaseLoader;
    })(egret3d.EventDispatcher);
    egret3d.BaseLoader = BaseLoader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.TextureLoader
     * @classdesc
     * TextureLoader类 用于Texture文件加载
     */
    var TextureLoader = (function (_super) {
        __extends(TextureLoader, _super);
        /**
         * @language zh_CN
         * constructor
         * @param url
         */
        function TextureLoader(url) {
            if (url === void 0) { url = null; }
            _super.call(this, egret3d.LoaderType.LOADER_TEXTURE_TYPE, url);
        }
        Object.defineProperty(TextureLoader.prototype, "texture", {
            /**
             * @language zh_CN
             * @returns TextureBase
             */
            get: function () {
                return this._texture;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         * @returns {}
         */
        TextureLoader.prototype.onLoad = function () {
            var _this = this;
            var textureLoader = new egret3d.URLLoader();
            textureLoader.onLoadComplete = function (textureLoader) { return _this.onEMFileLoadComplete(textureLoader); };
            textureLoader.load(this.url);
        };
        TextureLoader.prototype.onEMFileLoadComplete = function (textureLoader) {
            this._texture = textureLoader.data;
            this.dispatchEvent(new egret3d.Event3D(egret3d.Event3D.EVENT_LOAD_COMPLETE, this));
        };
        return TextureLoader;
    })(egret3d.BaseLoader);
    egret3d.TextureLoader = TextureLoader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ModeLoader
     * @classdesc
     * ModeLoader类
     */
    var ModeLoader = (function (_super) {
        __extends(ModeLoader, _super);
        /**
         * @language zh_CN
         * constructor
         * @param rootURL
         * @param ESMFile
         * @param EAMFiles
         */
        function ModeLoader(rootURL, ESMFile, EAMFiles) {
            if (rootURL === void 0) { rootURL = null; }
            if (ESMFile === void 0) { ESMFile = null; }
            if (EAMFiles === void 0) { EAMFiles = null; }
            _super.call(this, egret3d.LoaderType.LOADER_MODEL_TYPE, rootURL);
            this.url = rootURL;
            this._esmFile = ESMFile;
            this._eamFiles = EAMFiles;
        }
        Object.defineProperty(ModeLoader.prototype, "esmFile", {
            /**
             * @language zh_CN
             * @returns string
             */
            get: function () {
                return this._esmFile;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModeLoader.prototype, "mesh", {
            /**
             * 模型Mesh对象;
             */
            /**
             * @language zh_CN
             * 模型Mesh对象;
             * @returns Mesh
             */
            get: function () {
                return this._mesh;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModeLoader.prototype, "geomtry", {
            /**
             * 模型GeometryBase对象;
             */
            /**
             * @language zh_CN
             * 模型GeometryBase对象;
             * @returns GeometryBase
             */
            get: function () {
                return this._geomtry;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         */
        ModeLoader.prototype.onLoad = function () {
            var _this = this;
            this._mesh = null;
            this._geomtry = null;
            var esmLoader = new egret3d.URLLoader();
            esmLoader.onLoadComplete = function (loader) { return _this.onESMLoadComplete(_this.url, loader, _this._eamFiles); };
            esmLoader.load(this.url + this._esmFile);
        };
        ModeLoader.prototype.onESMLoadComplete = function (rootURL, esmLoader, EAMFiles) {
            this._geomtry = esmLoader.data;
            var useDiffuse = (this._geomtry.textureFile && this._geomtry.textureFile.length > 0);
            var useNormal = (this._geomtry.textureBump && this._geomtry.textureBump.length > 0);
            var useSpecular = (this._geomtry.textureSpecular && this._geomtry.textureSpecular.length > 0);
            var material = new egret3d.TextureMaterial(null);
            if (this._geomtry.textureFile.length > 0) {
                var asynLoadingMaterial = new egret3d.AsyncLoadingTexturematerial(material);
                asynLoadingMaterial.loadTexture(useDiffuse ? (rootURL + this._geomtry.textureFile) : null, useNormal ? (rootURL + this._geomtry.textureBump) : null, useSpecular ? (rootURL + this._geomtry.textureSpecular) : null);
            }
            if (this._geomtry.geomtryType == egret3d.GeometryType.Skin) {
                var skinGeomtry = this._geomtry;
                this._mesh = new egret3d.Mesh(this._geomtry, material, new egret3d.SkeletonAnimation(skinGeomtry.initialSkeleton));
            }
            else {
                this._mesh = new egret3d.Mesh(this._geomtry, material);
            }
            if (EAMFiles && EAMFiles.length > 0) {
                this.loadEAMFile(rootURL, 0, EAMFiles);
            }
            else {
                var e = new egret3d.Event3D(egret3d.Event3D.EVENT_LOAD_COMPLETE);
                e.data = this;
                this.dispatchEvent(e);
            }
        };
        ModeLoader.prototype.loadEAMFile = function (rootURL, index, EAMFiles) {
            var _this = this;
            if (index >= EAMFiles.length) {
                var e = new egret3d.Event3D(egret3d.Event3D.EVENT_LOAD_COMPLETE);
                e.data = this;
                this.dispatchEvent(e);
                return;
            }
            var urlLoader = new egret3d.URLLoader();
            urlLoader.onLoadComplete = function (loader) { return _this.onEAMLoadComplete(rootURL, loader.data, index, EAMFiles); };
            urlLoader.load(rootURL + EAMFiles[index]);
        };
        ModeLoader.prototype.onEAMLoadComplete = function (rootURL, animation, index, EAMFiles) {
            this._mesh.animation.addSkeletonAnimationClip(animation);
            this.loadEAMFile(rootURL, index + 1, EAMFiles);
        };
        return ModeLoader;
    })(egret3d.BaseLoader);
    egret3d.ModeLoader = ModeLoader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.SceneLoader
     * @classdesc
     * SceneLoader类 用于Scene文件加载
     * @version Egret 3.0
     * @platform Web,Native
     */
    var SceneLoader = (function (_super) {
        __extends(SceneLoader, _super);
        /**
         * @language zh_CN
         * constructor
         * @param sceneURL {String}
         */
        function SceneLoader(sceneURL) {
            if (sceneURL === void 0) { sceneURL = null; }
            _super.call(this, egret3d.LoaderType.LOADER_SCENE_TYPE, sceneURL);
            this._meshList = [];
            this._totalNumber = 0;
        }
        Object.defineProperty(SceneLoader.prototype, "meshList", {
            /**
             * @language zh_CN
             * 场景对象列表;
             * @returns Array<egret3d.Mesh>
             */
            get: function () {
                return this._meshList;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @language zh_CN
         */
        SceneLoader.prototype.onLoad = function () {
            var _this = this;
            this._meshList = [];
            var emLoader = new egret3d.URLLoader();
            emLoader.onLoadComplete = function (emLoader) { return _this.onEMFileLoadComplete(_this.url, emLoader); };
            emLoader.load(this.url + "/config.em");
        };
        SceneLoader.prototype.onEMFileLoadComplete = function (sceneURL, emLoader) {
            var obj = this.parsingXML(emLoader.data);
            var nodeList = obj.getElementsByTagName("mesh");
            this._totalNumber = nodeList.length;
            for (var i = 0; i < nodeList.length; i++) {
                var linkURL = sceneURL;
                linkURL += "/" + nodeList[i].attributes.getNamedItem("link").value;
                var rotation = new egret3d.Vector3D();
                rotation.parsing(nodeList[i].attributes.getNamedItem("rotation").value);
                var scaling = new egret3d.Vector3D();
                scaling.parsing(nodeList[i].attributes.getNamedItem("scaling").value);
                var translation = new egret3d.Vector3D();
                translation.parsing(nodeList[i].attributes.getNamedItem("translation").value);
                this.loadChild(linkURL, rotation, scaling, translation, sceneURL + "/");
            }
        };
        SceneLoader.prototype.loadChild = function (linkURL, rotation, scaling, translation, url) {
            var _this = this;
            var linkLoader = new egret3d.URLLoader();
            linkLoader.onLoadComplete = function (linkLoader) { return _this.onLoadComplete(linkLoader, rotation, scaling, translation, url); };
            linkLoader.load(linkURL);
        };
        SceneLoader.prototype.onLoadComplete = function (linkLoader, rotation, scaling, translation, url) {
            var geomtry = linkLoader.data;
            var material = new egret3d.TextureMaterial();
            var asynLoadingMaterial = new egret3d.AsyncLoadingTexturematerial(material);
            asynLoadingMaterial.loadTexture(geomtry.textureFile.length > 0 ? (url + geomtry.textureFile) : null, geomtry.textureBump.length > 0 ? (url + geomtry.textureBump) : null, geomtry.textureSpecular.length > 0 ? (url + geomtry.textureSpecular) : null);
            var mesh = new egret3d.Mesh(linkLoader.data, material);
            mesh.scaleX = scaling.x;
            mesh.scaleY = scaling.y;
            mesh.scaleZ = scaling.z;
            mesh.rotationX = rotation.x;
            mesh.rotationY = rotation.y;
            mesh.rotationZ = rotation.z;
            mesh.x = translation.x;
            mesh.y = translation.y;
            mesh.z = translation.z;
            this._meshList.push(mesh);
            if (this._meshList.length >= this._totalNumber) {
                this.dispatchEvent(new egret3d.Event3D(egret3d.Event3D.EVENT_LOAD_COMPLETE, this));
            }
        };
        SceneLoader.prototype.parsingXML = function (xmlString) {
            var xmlDoc = null;
            if (!window["DOMParser"] && window["ActiveXObject"]) {
                var xmlDomVersions = ['MSXML.2.DOMDocument.6.0', 'MSXML.2.DOMDocument.3.0', 'Microsoft.XMLDOM'];
                for (var i = 0; i < xmlDomVersions.length; i++) {
                    try {
                        xmlDoc = new ActiveXObject(xmlDomVersions[i]);
                        xmlDoc.async = false;
                        xmlDoc.loadXML(xmlString); //loadXML方法载入xml字符串
                        break;
                    }
                    catch (e) {
                    }
                }
            }
            else if (window["DOMParser"] && document.implementation && document.implementation.createDocument) {
                try {
                    var domParser = new DOMParser();
                    xmlDoc = domParser.parseFromString(xmlString, 'text/xml');
                }
                catch (e) {
                }
            }
            else {
                return null;
            }
            return xmlDoc;
        };
        return SceneLoader;
    })(egret3d.BaseLoader);
    egret3d.SceneLoader = SceneLoader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.URLLoader
     * @classdesc
     * URLLoader类
     * 用于加载和解析各类3d资源.
     * DDS, TGA, jpg, png等格式的贴图文件.
     * ESM, EAM, ECA等egret3d独有的模型文件,动作文件,相机动画文件
     * @includeExample loader/URLLoader.ts
     *
     * @version Egret 3.0
     *@platform Web,Native
     */
    var URLLoader = (function () {
        /**
         * @language en_US
         */
        /**
         * @language zh_CN
         * 构造函数
         * @param url 加载数据的地址.如果参数不为空的话.将直接开始加载
         * @param dataformat 以什么方式进行加载.如果为空的话.将通过目标文件的后缀名判断,
         * 如果为空且文件后缀不为内置支持的集中文件类型的话.将以文本格式进行加载解析
         * @version Egret 3.0
         * @platform Web,Native
         */
        function URLLoader(url, dataformat) {
            if (url === void 0) { url = null; }
            if (dataformat === void 0) { dataformat = null; }
            /**
             * @language en_US
             */
            /**
             * @private
             * @language zh_CN
             * 加载的地址
             * @version Egret 3.0
             *@platform Web,Native
             */
            this._url = "";
            /**
             * @language en_US
             */
            /**
             * @private
             * @language zh_CN
             * 加载的数据.
             * @version Egret 3.0
             *@platform Web,Native
             */
            this._data = null;
            /**
             * @language en_US
             */
            /**
             * @language zh_CN
             * 控制以哪种方式接收加载的数据.
             * 如果未赋值则通过加载文件的后缀名来判断加载的类型以解析.
             * 如果未赋值且加载的类型并非为内置支持的文件类型.将以文本格式进行加载
             * @version Egret 3.0
             * @platform Web,Native
             */
            this._dataformat = null;
            /**
             * @language en_US
             */
            /**
             * @language zh_CN
             * 加载完成的回调函数.
             * 回调函数参数为该UrlLoader实例
             * @version Egret 3.0
             *@platform Web,Native
             */
            this.onLoadComplete = null;
            /**
             * @language en_US
             */
            /**
             * @language zh_CN
             * 加载失败的回调函数
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.onLoadError = null;
            /**
             * @language en_US
             */
            /**
             * @language zh_CN
             * 加载过程调用的函数
             * @version Egret 3.0
             * @platform Web,Native
             */
            this.onLoadProgress = null;
            if (url) {
                if (dataformat) {
                    this.dataformat = dataformat;
                }
                this.load(url);
            }
        }
        /**
         * @language en_US
         */
        /**
         * @language zh_CN
         * 加载目标地址的数据
         * @param url 数据地址
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.prototype.load = function (url) {
            var _this = this;
            this._data = null;
            this._url = url;
            if (null == this._dataformat) {
                this._dataformat = URLLoader.DATAFORMAT_TEXT;
                if (this._url.length >= 4)
                    switch (this._url.substr(this._url.length - 4, 4).toLowerCase()) {
                        case ".dds":
                            this._dataformat = URLLoader.DATAFORMAT_DDS;
                            break;
                        case ".tga":
                            this._dataformat = URLLoader.DATAFORMAT_TGA;
                            break;
                        case ".bmp":
                            this._dataformat = URLLoader.DATAFORMAT_BITMAP;
                            break;
                        case ".png":
                            this._dataformat = URLLoader.DATAFORMAT_BITMAP;
                            break;
                        case ".jpg":
                            this._dataformat = URLLoader.DATAFORMAT_BITMAP;
                            break;
                        case "glsl":
                            this._dataformat = URLLoader.DATAFORMAT_TEXT;
                            break;
                        case ".pvr":
                            this._dataformat = URLLoader.DATAFORMAT_PVR;
                            break;
                        case ".esm":
                            this._dataformat = URLLoader.DATAFORMAT_ESM;
                            break;
                        case ".eam":
                            this._dataformat = URLLoader.DATAFORMAT_EAM;
                            break;
                        case ".eca":
                            this._dataformat = URLLoader.DATAFORMAT_ECA;
                            break;
                    }
            }
            if (this._xhr == null) {
                this._xhr = this.getXHR();
            }
            if (this._xhr == null) {
                alert("Your browser does not support XMLHTTP.");
                return;
            }
            if (this._xhr.readyState > 0) {
                this._xhr.abort();
            }
            this._xhr.open("GET", this._url, true);
            this._xhr.addEventListener("progress", function (e) { return _this.onProgress(e); }, false);
            this._xhr.addEventListener("readystatechange", function (e) { return _this.onReadyStateChange(e); }, false);
            this._xhr.addEventListener("error", function (e) { return _this.onError(e); }, false);
            if (this.dataformat == URLLoader.DATAFORMAT_BITMAP) {
                this._xhr.responseType = "blob";
            }
            else if (this.dataformat != URLLoader.DATAFORMAT_TEXT) {
                this._xhr.responseType = "arraybuffer";
            }
            this._xhr.send();
        };
        Object.defineProperty(URLLoader.prototype, "dataformat", {
            /**
             * @language zh_CN
             * 控制以哪种方式接收加载的数据.
             * 如果未赋值则通过加载文件的后缀名来判断加载的类型以解析.
             * 如果未赋值且加载的类型并非为内置支持的文件类型.将以文本格式进行加载
             * @returns string
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._dataformat;
            },
            /**
             * @language zh_CN
             * 控制以哪种方式接收加载的数据.
             * 如果未赋值则通过加载文件的后缀名来判断加载的类型以解析.
             * 如果未赋值且加载的类型并非为内置支持的文件类型.将以文本格式进行加载
             * @param value
             * @version Egret 3.0
             * @platform Web,Native
             */
            set: function (value) {
                this._dataformat = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URLLoader.prototype, "data", {
            /**
             * @language zh_CN
             * 加载的数据.
             * @returns any
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URLLoader.prototype, "url", {
            /**
             * @language zh_CN
             * 加载的地址
             * @readonly
             * @returns string
             * @version Egret 3.0
             * @platform Web,Native
             */
            get: function () {
                return this._url;
            },
            enumerable: true,
            configurable: true
        });
        URLLoader.prototype.onReadyStateChange = function (event) {
            if (this._xhr.readyState == 4) {
                if (this._xhr.status >= 400 || this._xhr.status == 0) {
                    console.log(this._url, "load fail");
                }
                else {
                    this.loadComplete();
                }
            }
        };
        URLLoader.prototype.loadComplete = function () {
            switch (this.dataformat) {
                case URLLoader.DATAFORMAT_BINARY:
                    this._data = new egret3d.ByteArray(this._xhr.response);
                    break;
                case URLLoader.DATAFORMAT_SOUND:
                    this._data = this._xhr.responseBody;
                    break;
                case URLLoader.DATAFORMAT_TEXT:
                    this._data = this._xhr.responseText;
                    break;
                case URLLoader.DATAFORMAT_BITMAP:
                    var img = document.createElement("img");
                    img.src = window["URL"].createObjectURL(this._xhr.response);
                    var that = this;
                    img.onload = function () {
                        that._data = new egret3d.ImageTexture(img);
                        if (that.onLoadComplete) {
                            that.onLoadComplete(that);
                        }
                    };
                    return;
                case URLLoader.DATAFORMAT_DDS:
                    this._data = egret3d.DDSParser.parse(this._xhr.response);
                    break;
                case URLLoader.DATAFORMAT_TGA:
                    this._data = egret3d.TGAParser.parse(this._xhr.response);
                    break;
                case URLLoader.DATAFORMAT_ESM:
                    var geomtry = egret3d.ESMParser.parse(this._xhr.response);
                    this._data = geomtry;
                    break;
                case URLLoader.DATAFORMAT_EAM:
                    var skeletonAnimationClip = egret3d.EAMParser.parse(this._xhr.response);
                    this._data = skeletonAnimationClip;
                    break;
                case URLLoader.DATAFORMAT_ECA:
                    var cameraAnimationController = egret3d.ECAParser.parse(this._xhr.response);
                    this._data = cameraAnimationController;
                    break;
                case URLLoader.DATAFORMAT_PVR:
                    var pvr = egret3d.PVRParser.parse(this._xhr.response);
                    this._data = pvr;
                    break;
                default:
                    this._data = this._xhr.responseText;
            }
            if (this.onLoadComplete) {
                this.onLoadComplete(this);
            }
        };
        URLLoader.prototype.onProgress = function (event) {
            //console.log("progress event```");
        };
        URLLoader.prototype.onError = function (event) {
            if (this.onLoadError) {
                this.onLoadError();
            }
            egret3d.Debug.instance.trace("loaderror, url: ", this._url);
            console.log("load error", event);
        };
        URLLoader.prototype.getXHR = function () {
            var xhr = null;
            if (window["XMLHttpRequest"]) {
                xhr = new window["XMLHttpRequest"]();
            }
            else {
                xhr = new ActiveXObject("MSXML2.XMLHTTP");
            }
            return xhr;
        };
        /**
         * @language en_US
         */
        /**
         * @language zh_CN
         * 以二进制方式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_BINARY = "binary";
        /**
         * @language en_US
         */
        /**
         * @language zh_CN
         * 以文本的方式接收加载的数据
         * 默认方式
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_TEXT = "text";
        /**
         * @language en_US
         */
        /**
         * @language zh_CN
         * 以音频的方式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_SOUND = "sound";
        /**
         * @language en_US
         */
        /**
         * @language zh_CN
         * 以图像的方式接收加载的数据
         * 支持jpg.png.等格式
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_BITMAP = "bitmap";
        /**
         * @language en_US
         */
        /**
         * @language zh_CN
         * 以DDS的方式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_DDS = "dds";
        /**
         * @language en_US
         */
        /**
         * @language zh_CN
         * 以TGA的方式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_TGA = "tga";
        /**
         * @language en_US
         */
        /**
         * @language zh_CN
         * 以ESM格式接收加载的数据
         * Egret3D独有的格式 模型+蒙皮
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_ESM = "esm";
        /**
         * @language en_US
         */
        /**
         * @language zh_CN
         * 以EAM格式接收加载的数据
         * Egret3D独有的格式 动作文件
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_EAM = "eam";
        /**
         * @language en_US
         */
        /**
         * @language zh_CN
         * 以ECA格式接收加载的数据
         * Egret3D独有的格式 相机动画文件
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_ECA = "eca";
        /**
         * @language en_US

         */
        /**
         * @private
         * @language zh_CN
         * 以pvr格式接收加载的数据
         * @version Egret 3.0
         * @platform Web,Native
         */
        URLLoader.DATAFORMAT_PVR = "pvr";
        return URLLoader;
    })();
    egret3d.URLLoader = URLLoader;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.AsyncLoadingTexturematerial
     * @classdesc
     * AsyncLoadingTexturematerial类 用于纹理的加载
     */
    var AsyncLoadingTexturematerial = (function () {
        /**
        * @language zh_CN
        * constructor
        * @param mat {egret3d.TextureMaterial}
        */
        function AsyncLoadingTexturematerial(mat) {
            this._mat = mat;
        }
        /**
         * 加载纹理
         * @param texture
         * @param bump
         * @param spec
         */
        AsyncLoadingTexturematerial.prototype.loadTexture = function (texture, bump, spec) {
            var _this = this;
            if (bump === void 0) { bump = null; }
            if (spec === void 0) { spec = null; }
            if (texture) {
                var textureUrlLoader = new egret3d.URLLoader();
                textureUrlLoader.onLoadComplete = function (urlLoader) { return _this.__textureComplete(urlLoader); };
                //textureUrlLoader.dataformat = BlackSwan.URLLoader.DATAFORMAT_DDS;
                textureUrlLoader.load(texture);
            }
            if (bump) {
                var bumpUrlLoader = new egret3d.URLLoader();
                bumpUrlLoader.onLoadComplete = function (urlLoader) { return _this.__bumpComplete(urlLoader); };
                //bumpUrlLoader.dataformat = BlackSwan.URLLoader.DATAFORMAT_DDS;
                bumpUrlLoader.load(bump);
            }
            if (spec) {
                var specUrlLoader = new egret3d.URLLoader();
                specUrlLoader.onLoadComplete = function (urlLoader) { return _this.__specComplete(urlLoader); };
                //bumpUrlLoader.dataformat = BlackSwan.URLLoader.DATAFORMAT_DDS;
                specUrlLoader.load(spec);
            }
        };
        AsyncLoadingTexturematerial.prototype.__specComplete = function (e) {
            e.data.upload(egret3d.Egret3DDrive.context3D);
            this._mat.specularTexture = e.data;
        };
        AsyncLoadingTexturematerial.prototype.__textureComplete = function (e) {
            e.data.upload(egret3d.Egret3DDrive.context3D);
            this._mat.diffuseTexture = e.data;
        };
        AsyncLoadingTexturematerial.prototype.__bumpComplete = function (e) {
            e.data.upload(egret3d.Egret3DDrive.context3D);
            this._mat.normalTexture = e.data;
        };
        return AsyncLoadingTexturematerial;
    })();
    egret3d.AsyncLoadingTexturematerial = AsyncLoadingTexturematerial;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * dds / st3c compressed texture formats
     */
    (function (DDSFormat) {
        DDSFormat[DDSFormat["RGB_S3TC_DXT1_FORMAT"] = 2001] = "RGB_S3TC_DXT1_FORMAT";
        DDSFormat[DDSFormat["RGBA_S3TC_DXT1_FORMAT"] = 2002] = "RGBA_S3TC_DXT1_FORMAT";
        DDSFormat[DDSFormat["RGBA_S3TC_DXT3_FORMAT"] = 2003] = "RGBA_S3TC_DXT3_FORMAT";
        DDSFormat[DDSFormat["RGBA_S3TC_DXT5_FORMAT"] = 2003] = "RGBA_S3TC_DXT5_FORMAT";
    })(egret3d.DDSFormat || (egret3d.DDSFormat = {}));
    var DDSFormat = egret3d.DDSFormat;
    ;
    /**
     * @private
     * @language zh_CN
     * @class egret3d.DDSParser
     * @classdesc
     * 用 DDSParser 类 解析.dds 文件
     */
    var DDSParser = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function DDSParser() {
        }
        /**
         * @language zh_CN
         * @param buffer 二进制
         * @param loadMipmaps 是否加载mipmaps
         * @returns TextureBase
         */
        DDSParser.parse = function (buffer, loadMipmaps) {
            if (loadMipmaps === void 0) { loadMipmaps = true; }
            var dds = new DDS();
            var headerLengthInt = 31; // The header length in 32 bit ints
            var off_magic = 0;
            var DDS_MAGIC = 0x20534444;
            var DDSD_CAPS = 0x1, DDSD_HEIGHT = 0x2, DDSD_WIDTH = 0x4, DDSD_PITCH = 0x8, DDSD_PIXELFORMAT = 0x1000, DDSD_MIPMAPCOUNT = 0x20000, DDSD_LINEARSIZE = 0x80000, DDSD_DEPTH = 0x800000;
            var DDSCAPS_COMPLEX = 0x8, DDSCAPS_MIPMAP = 0x400000, DDSCAPS_TEXTURE = 0x1000;
            var DDSCAPS2_CUBEMAP = 0x200, DDSCAPS2_CUBEMAP_POSITIVEX = 0x400, DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800, DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000, DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000, DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000, DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000, DDSCAPS2_VOLUME = 0x200000;
            var DDPF_ALPHAPIXELS = 0x1, DDPF_ALPHA = 0x2, DDPF_FOURCC = 0x4, DDPF_RGB = 0x40, DDPF_YUV = 0x200, DDPF_LUMINANCE = 0x20000;
            var FOURCC_DXT1 = DDSParser.fourCCToInt32("DXT1");
            var FOURCC_DXT3 = DDSParser.fourCCToInt32("DXT3");
            var FOURCC_DXT5 = DDSParser.fourCCToInt32("DXT5");
            //Pixel formats
            var RGBA_FORMAT = 1021;
            var off_magic = 0;
            var off_size = 1;
            var off_flags = 2;
            var off_height = 3;
            var off_width = 4;
            var off_mipmapCount = 7;
            var off_pfFlags = 20;
            var off_pfFourCC = 21;
            var off_RGBBitCount = 22;
            var off_RBitMask = 23;
            var off_GBitMask = 24;
            var off_BBitMask = 25;
            var off_ABitMask = 26;
            var off_caps = 27;
            var off_caps2 = 28;
            var off_caps3 = 29;
            var off_caps4 = 30;
            var header = new Int32Array(buffer, 0, headerLengthInt);
            if (header[off_magic] !== DDS_MAGIC) {
                console.error('DDSParser.parse: Invalid magic number in DDS header.');
                return null;
            }
            if (!(header[off_pfFlags] & DDPF_FOURCC)) {
                console.error('DDSParser.parse: Unsupported format, must contain a FourCC code.');
                return null;
            }
            var blockBytes;
            var fourCC = header[off_pfFourCC];
            var isRGBAUncompressed = false;
            switch (fourCC) {
                case FOURCC_DXT1:
                    blockBytes = 8;
                    dds.format = DDSFormat.RGB_S3TC_DXT1_FORMAT;
                    break;
                case FOURCC_DXT3:
                    blockBytes = 16;
                    dds.format = DDSFormat.RGBA_S3TC_DXT3_FORMAT;
                    break;
                case FOURCC_DXT5:
                    blockBytes = 16;
                    dds.format = DDSFormat.RGBA_S3TC_DXT5_FORMAT;
                    break;
                default:
                    if (header[off_RGBBitCount] == 32
                        && header[off_RBitMask] & 0xff0000
                        && header[off_GBitMask] & 0xff00
                        && header[off_BBitMask] & 0xff
                        && header[off_ABitMask] & 0xff000000) {
                        isRGBAUncompressed = true;
                        blockBytes = 64;
                        dds.format = RGBA_FORMAT;
                    }
                    else {
                        console.error('DDSParser.parse: Unsupported FourCC code ', DDSParser.int32ToFourCC(fourCC));
                        return null;
                    }
            }
            dds.mipmapCount = 1;
            if ((header[off_flags] & DDSD_MIPMAPCOUNT) && loadMipmaps !== false) {
                dds.mipmapCount = Math.max(1, header[off_mipmapCount]);
            }
            dds.isCubemap = header[off_caps2] & DDSCAPS2_CUBEMAP ? true : false;
            dds.width = header[off_width];
            dds.height = header[off_height];
            var dataOffset = header[off_size] + 4;
            // Extract mipmaps buffers
            var width = dds.width;
            var height = dds.height;
            var faces = dds.isCubemap ? 6 : 1;
            //是否软解DXT;
            var useSoftwareSolution = false;
            if (dds.format == DDSFormat.RGB_S3TC_DXT1_FORMAT && egret3d.Egret3DDrive.ColorFormat_DXT1_RGB == 0)
                useSoftwareSolution = true;
            else if (dds.format == DDSFormat.RGBA_S3TC_DXT3_FORMAT && egret3d.Egret3DDrive.ColorFormat_DXT3_RGBA == 0)
                useSoftwareSolution = true;
            else if (dds.format == DDSFormat.RGBA_S3TC_DXT5_FORMAT && egret3d.Egret3DDrive.ColorFormat_DXT5_RGBA == 0)
                useSoftwareSolution = true;
            for (var face = 0; face < faces; face++) {
                for (var i = 0; i < dds.mipmapCount; i++) {
                    var byteArray;
                    if (isRGBAUncompressed) {
                        byteArray = DDSParser.loadARGBMip(buffer, dataOffset, width, height);
                        var dataLength = byteArray.length;
                    }
                    else {
                        var dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
                        byteArray = new Uint8Array(buffer, dataOffset, dataLength);
                        if (useSoftwareSolution) {
                            byteArray = DDSParser.softSolutionDXT(width, height, dds.format, byteArray);
                        }
                    }
                    var mipmap = new egret3d.MipmapData(byteArray, width, height);
                    dds.mipmaps.push(mipmap);
                    dataOffset += dataLength;
                    width = Math.max(width * 0.5, 1);
                    height = Math.max(height * 0.5, 1);
                }
                width = dds.width;
                height = dds.height;
            }
            var texture = new egret3d.TextureBase();
            if (useSoftwareSolution) {
                texture.internalFormat = egret3d.InternalFormat.PixelArray;
                texture.colorFormat = egret3d.Egret3DDrive.ColorFormat_RGBA8888;
            }
            else {
                texture.internalFormat = egret3d.InternalFormat.CompressData;
                if (FOURCC_DXT1 == fourCC)
                    texture.colorFormat = egret3d.Egret3DDrive.ColorFormat_DXT1_RGB;
                else if (FOURCC_DXT3 == fourCC)
                    texture.colorFormat = egret3d.Egret3DDrive.ColorFormat_DXT3_RGBA;
                else if (FOURCC_DXT5 == fourCC)
                    texture.colorFormat = egret3d.Egret3DDrive.ColorFormat_DXT5_RGBA;
            }
            texture.mimapData = dds.mipmaps;
            return texture;
        };
        DDSParser.loadARGBMip = function (buffer, dataOffset, width, height) {
            var dataLength = width * height * 4;
            var srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);
            var byteArray = new Uint8Array(dataLength);
            var dst = 0;
            var src = 0;
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var b = srcBuffer[src];
                    src++;
                    var g = srcBuffer[src];
                    src++;
                    var r = srcBuffer[src];
                    src++;
                    var a = srcBuffer[src];
                    src++;
                    byteArray[dst] = r;
                    dst++; //r
                    byteArray[dst] = g;
                    dst++; //g
                    byteArray[dst] = b;
                    dst++; //b
                    byteArray[dst] = a;
                    dst++; //a
                }
            }
            return byteArray;
        };
        DDSParser.fourCCToInt32 = function (value) {
            return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
        };
        DDSParser.int32ToFourCC = function (value) {
            return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff69);
        };
        //软解DXT数据块到像素组;
        DDSParser.softSolutionDXT = function (width, height, format, byteArray) {
            var nCount;
            var colorArray = new Uint8Array(width * height * 4);
            //色彩表;
            var colorTab = [new egret3d.Color(), new egret3d.Color(), new egret3d.Color(), new egret3d.Color()];
            //索引表;
            var indexTab = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            switch (format) {
                case DDSFormat.RGB_S3TC_DXT1_FORMAT:
                case DDSFormat.RGBA_S3TC_DXT1_FORMAT:
                    {
                        nCount = byteArray.length / 8;
                        for (var blockIndex = 0; blockIndex < nCount; blockIndex++) {
                            var _16bit_0 = byteArray[blockIndex * 8 + 0] | (byteArray[blockIndex * 8 + 1] << 8);
                            var _16bit_1 = byteArray[blockIndex * 8 + 2] | (byteArray[blockIndex * 8 + 3] << 8);
                            //极端颜色1;
                            colorTab[0].r = (_16bit_0 >> 11) & 0x1F;
                            colorTab[0].g = (_16bit_0 >> 5) & 0x3F;
                            colorTab[0].b = _16bit_0 & 0x1F;
                            colorTab[0].a = 0xFF;
                            //极端颜色2;
                            colorTab[1].r = (_16bit_1 >> 11) & 0x1F;
                            colorTab[1].g = (_16bit_1 >> 5) & 0x3F;
                            colorTab[1].b = _16bit_1 & 0x1F;
                            colorTab[1].a = 0xFF;
                            if (_16bit_0 > _16bit_1) {
                                //线性插值计算出剩下的两个颜色;
                                colorTab[2].lerp(colorTab[0], colorTab[1], 0.33);
                                colorTab[3].lerp(colorTab[0], colorTab[1], 0.66);
                            }
                            else {
                                //线性插值计算出剩下的一个颜色;
                                colorTab[2].lerp(colorTab[0], colorTab[1], 0.5);
                            }
                            //取出16个2位索引;
                            for (var i = 0; i < 4; i++) {
                                indexTab[(i * 4) + 0] = byteArray[blockIndex * 8 + 4 + i] & 0x03;
                                indexTab[(i * 4) + 1] = (byteArray[blockIndex * 8 + 4 + i] >> 2) & 0x03;
                                indexTab[(i * 4) + 2] = (byteArray[blockIndex * 8 + 4 + i] >> 4) & 0x03;
                                indexTab[(i * 4) + 3] = (byteArray[blockIndex * 8 + 4 + i] >> 6) & 0x03;
                            }
                            for (var ci = 0; ci < colorTab.length; ci++) {
                                colorTab[ci].r = colorTab[ci].r * 8;
                                colorTab[ci].g = colorTab[ci].g * 4;
                                colorTab[ci].b = colorTab[ci].b * 8;
                            }
                            //填充像素数组;
                            var globalX = (blockIndex % (width / 4)) * 4;
                            var globalY = Math.floor(blockIndex / (width / 4)) * 4;
                            if (globalY + 0 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[0]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[0]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[0]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 3] = colorTab[indexTab[0]].a;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[1]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[1]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[1]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 3] = colorTab[indexTab[1]].a;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[2]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[2]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[2]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 3] = colorTab[indexTab[2]].a;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[3]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[3]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[3]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 3] = colorTab[indexTab[3]].a;
                                }
                            }
                            if (globalY + 1 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[4]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[4]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[4]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 3] = colorTab[indexTab[4]].a;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[5]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[5]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[5]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 3] = colorTab[indexTab[5]].a;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[6]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[6]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[6]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 3] = colorTab[indexTab[6]].a;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[7]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[7]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[7]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 3] = colorTab[indexTab[7]].a;
                                }
                            }
                            if (globalY + 2 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[8]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[8]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[8]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 3] = colorTab[indexTab[8]].a;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[9]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[9]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[9]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 3] = colorTab[indexTab[9]].a;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[10]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[10]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[10]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 3] = colorTab[indexTab[10]].a;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[11]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[11]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[11]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 3] = colorTab[indexTab[11]].a;
                                }
                            }
                            if (globalY + 3 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[12]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[12]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[12]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 3] = colorTab[indexTab[12]].a;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[13]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[13]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[13]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 3] = colorTab[indexTab[13]].a;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[14]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[14]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[14]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 3] = colorTab[indexTab[14]].a;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[15]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[15]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[15]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 3] = colorTab[indexTab[15]].a;
                                }
                            }
                        }
                    }
                    break;
                case DDSFormat.RGBA_S3TC_DXT3_FORMAT:
                    {
                        nCount = byteArray.length / 16;
                        for (var blockIndex = 0; blockIndex < nCount; blockIndex++) {
                            var _16bit_0 = byteArray[blockIndex * 16 + 8] | (byteArray[blockIndex * 16 + 9] << 8);
                            var _16bit_1 = byteArray[blockIndex * 16 + 10] | (byteArray[blockIndex * 16 + 11] << 8);
                            //极端颜色1;
                            colorTab[0].r = (_16bit_0 >> 11) & 0x1F;
                            colorTab[0].g = (_16bit_0 >> 5) & 0x3F;
                            colorTab[0].b = _16bit_0 & 0x1F;
                            colorTab[0].a = 0xFF;
                            //极端颜色2;
                            colorTab[1].r = (_16bit_1 >> 11) & 0x1F;
                            colorTab[1].g = (_16bit_1 >> 5) & 0x3F;
                            colorTab[1].b = _16bit_1 & 0x1F;
                            colorTab[1].a = 0xFF;
                            if (_16bit_0 > _16bit_1) {
                                //线性插值计算出剩下的两个颜色;
                                colorTab[2].lerp(colorTab[0], colorTab[1], 0.33);
                                colorTab[3].lerp(colorTab[0], colorTab[1], 0.66);
                            }
                            else {
                                //线性插值计算出剩下的一个颜色;
                                colorTab[2].lerp(colorTab[0], colorTab[1], 0.5);
                                colorTab[3].a = 0;
                            }
                            //取出16个2位索引;
                            for (var i = 0; i < 4; i++) {
                                indexTab[(i * 4) + 0] = byteArray[blockIndex * 16 + 12 + i] & 0x03;
                                indexTab[(i * 4) + 1] = (byteArray[blockIndex * 16 + 12 + i] >> 2) & 0x03;
                                indexTab[(i * 4) + 2] = (byteArray[blockIndex * 16 + 12 + i] >> 4) & 0x03;
                                indexTab[(i * 4) + 3] = (byteArray[blockIndex * 16 + 12 + i] >> 6) & 0x03;
                            }
                            for (var ci = 0; ci < colorTab.length; ci++) {
                                colorTab[ci].r = colorTab[ci].r * 8;
                                colorTab[ci].g = colorTab[ci].g * 4;
                                colorTab[ci].b = colorTab[ci].b * 8;
                            }
                            //填充像素数组;
                            var globalX = (blockIndex % (width / 4)) * 4;
                            var globalY = Math.floor(blockIndex / (width / 4)) * 4;
                            if (globalY + 0 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[0]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[0]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[0]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 0) * 4) + 3] = (byteArray[blockIndex * 16 + 0] & 0x0F) * 17;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[1]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[1]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[1]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 1) * 4) + 3] = ((byteArray[blockIndex * 16 + 0] >> 4) & 0x0F) * 17;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[2]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[2]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[2]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 2) * 4) + 3] = (byteArray[blockIndex * 16 + 1] & 0x0F) * 17;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[3]].r;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[3]].g;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[3]].b;
                                    colorArray[(globalY + 0) * (width * 4) + ((globalX + 3) * 4) + 3] = ((byteArray[blockIndex * 16 + 1] >> 4) & 0x0F) * 17;
                                }
                            }
                            if (globalY + 1 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[4]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[4]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[4]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 0) * 4) + 3] = (byteArray[blockIndex * 16 + 2] & 0x0F) * 17;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[5]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[5]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[5]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 1) * 4) + 3] = ((byteArray[blockIndex * 16 + 2] >> 4) & 0x0F) * 17;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[6]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[6]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[6]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 2) * 4) + 3] = (byteArray[blockIndex * 16 + 3] & 0x0F) * 17;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[7]].r;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[7]].g;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[7]].b;
                                    colorArray[(globalY + 1) * (width * 4) + ((globalX + 3) * 4) + 3] = ((byteArray[blockIndex * 16 + 3] >> 4) & 0x0F) * 17;
                                }
                            }
                            if (globalY + 2 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[8]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[8]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[8]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 0) * 4) + 3] = (byteArray[blockIndex * 16 + 4] & 0x0F) * 17;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[9]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[9]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[9]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 1) * 4) + 3] = ((byteArray[blockIndex * 16 + 4] >> 4) & 0x0F) * 17;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[10]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[10]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[10]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 2) * 4) + 3] = (byteArray[blockIndex * 16 + 5] & 0x0F) * 17;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[11]].r;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[11]].g;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[11]].b;
                                    colorArray[(globalY + 2) * (width * 4) + ((globalX + 3) * 4) + 3] = ((byteArray[blockIndex * 16 + 5] >> 4) & 0x0F) * 17;
                                }
                            }
                            if (globalY + 3 < height) {
                                if (globalX + 0 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 0] = colorTab[indexTab[12]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 1] = colorTab[indexTab[12]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 2] = colorTab[indexTab[12]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 0) * 4) + 3] = (byteArray[blockIndex * 16 + 6] & 0x0F) * 17;
                                }
                                if (globalX + 1 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 0] = colorTab[indexTab[13]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 1] = colorTab[indexTab[13]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 2] = colorTab[indexTab[13]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 1) * 4) + 3] = ((byteArray[blockIndex * 16 + 6] >> 4) & 0x0F) * 17;
                                }
                                if (globalX + 2 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 0] = colorTab[indexTab[14]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 1] = colorTab[indexTab[14]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 2] = colorTab[indexTab[14]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 2) * 4) + 3] = (byteArray[blockIndex * 16 + 7] & 0x0F) * 17;
                                }
                                if (globalX + 3 < width) {
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 0] = colorTab[indexTab[15]].r;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 1] = colorTab[indexTab[15]].g;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 2] = colorTab[indexTab[15]].b;
                                    colorArray[(globalY + 3) * (width * 4) + ((globalX + 3) * 4) + 3] = ((byteArray[blockIndex * 16 + 7] >> 4) & 0x0F) * 17;
                                }
                            }
                        }
                    }
                    break;
                case DDSFormat.RGBA_S3TC_DXT5_FORMAT:
                    break;
            }
            return colorArray;
        };
        return DDSParser;
    })();
    egret3d.DDSParser = DDSParser;
    /**
     * @private
     */
    var DDS = (function () {
        function DDS() {
            this.mipmaps = new Array();
            this.width = 0;
            this.height = 0;
            this.format = null;
            this.mipmapCount = 1;
        }
        return DDS;
    })();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.TGAParser
     * @classdesc
     * 用 TGAParser 类 解析.tga 文件
     */
    var TGAParser = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function TGAParser() {
        }
        /**
         * @language zh_CN
         * @param buffer 二进制流
         * @returns TexureBase
         */
        TGAParser.parse = function (buffer) {
            var TGA_TYPE_NO_DATA = 0, TGA_TYPE_INDEXED = 1, TGA_TYPE_RGB = 2, TGA_TYPE_GREY = 3, TGA_TYPE_RLE_INDEXED = 9, TGA_TYPE_RLE_RGB = 10, TGA_TYPE_RLE_GREY = 11, TGA_ORIGIN_MASK = 0x30, TGA_ORIGIN_SHIFT = 0x04, TGA_ORIGIN_BL = 0x00, TGA_ORIGIN_BR = 0x01, TGA_ORIGIN_UL = 0x02, TGA_ORIGIN_UR = 0x03;
            if (buffer.byteLength < 19) {
                console.error('TGAParser.parse: Not enough data to contain header.');
            }
            var content = new Uint8Array(buffer), offset = 0, header = {
                id_length: content[offset++],
                colormap_type: content[offset++],
                image_type: content[offset++],
                colormap_index: content[offset++] | content[offset++] << 8,
                colormap_length: content[offset++] | content[offset++] << 8,
                colormap_size: content[offset++],
                origin: [
                    content[offset++] | content[offset++] << 8,
                    content[offset++] | content[offset++] << 8
                ],
                width: content[offset++] | content[offset++] << 8,
                height: content[offset++] | content[offset++] << 8,
                pixel_size: content[offset++],
                flags: content[offset++]
            };
            function tgaCheckHeader(header) {
                switch (header.image_type) {
                    // Check indexed type
                    case TGA_TYPE_INDEXED:
                    case TGA_TYPE_RLE_INDEXED:
                        if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {
                            console.error('TGAParser.parse.tgaCheckHeader: Invalid type colormap data for indexed type');
                        }
                        break;
                    // Check colormap type
                    case TGA_TYPE_RGB:
                    case TGA_TYPE_GREY:
                    case TGA_TYPE_RLE_RGB:
                    case TGA_TYPE_RLE_GREY:
                        if (header.colormap_type) {
                            console.error('TGAParser.parse.tgaCheckHeader: Invalid type colormap data for colormap type');
                        }
                        break;
                    // What the need of a file without data ?
                    case TGA_TYPE_NO_DATA:
                        console.error('TGAParser.parse.tgaCheckHeader: No data');
                        break;
                    // Invalid type ?
                    default:
                        console.error('TGAParser.parse.tgaCheckHeader: Invalid type " ' + header.image_type + '"');
                }
                // Check image width and height
                if (header.width <= 0 || header.height <= 0) {
                    console.error('TGAParser.parse.tgaCheckHeader: Invalid image size');
                }
                // Check image pixel size
                if (header.pixel_size !== 8 &&
                    header.pixel_size !== 16 &&
                    header.pixel_size !== 24 &&
                    header.pixel_size !== 32) {
                    console.error('TGAParser.parse.tgaCheckHeader: Invalid pixel size "' + header.pixel_size + '"');
                }
            }
            // Check tga if it is valid format
            tgaCheckHeader(header);
            if (header.id_length + offset > buffer.byteLength) {
                console.error('TGAParser.parse: No data');
            }
            // Skip the needn't data
            offset += header.id_length;
            // Get targa information about RLE compression and palette
            var use_rle = false, use_pal = false, use_grey = false;
            switch (header.image_type) {
                case TGA_TYPE_RLE_INDEXED:
                    use_rle = true;
                    use_pal = true;
                    break;
                case TGA_TYPE_INDEXED:
                    use_pal = true;
                    break;
                case TGA_TYPE_RLE_RGB:
                    use_rle = true;
                    break;
                case TGA_TYPE_RGB:
                    break;
                case TGA_TYPE_RLE_GREY:
                    use_rle = true;
                    use_grey = true;
                    break;
                case TGA_TYPE_GREY:
                    use_grey = true;
                    break;
            }
            // Parse tga image buffer
            function tgaParse(use_rle, use_pal, header, offset, data) {
                var pixel_data, pixel_size, pixel_total, palettes;
                pixel_size = header.pixel_size >> 3;
                pixel_total = header.width * header.height * pixel_size;
                // Read palettes
                if (use_pal) {
                    palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));
                }
                // Read RLE
                if (use_rle) {
                    pixel_data = new Uint8Array(pixel_total);
                    var c, count, i;
                    var shift = 0;
                    var pixels = new Uint8Array(pixel_size);
                    while (shift < pixel_total) {
                        c = data[offset++];
                        count = (c & 0x7f) + 1;
                        // RLE pixels.
                        if (c & 0x80) {
                            // Bind pixel tmp array
                            for (i = 0; i < pixel_size; ++i) {
                                pixels[i] = data[offset++];
                            }
                            // Copy pixel array
                            for (i = 0; i < count; ++i) {
                                pixel_data.set(pixels, shift + i * pixel_size);
                            }
                            shift += pixel_size * count;
                        }
                        else {
                            // Raw pixels.
                            count *= pixel_size;
                            for (i = 0; i < count; ++i) {
                                pixel_data[shift + i] = data[offset++];
                            }
                            shift += count;
                        }
                    }
                }
                else {
                    // RAW Pixels
                    pixel_data = data.subarray(offset, offset += (use_pal ? header.width * header.height : pixel_total));
                }
                return {
                    pixel_data: pixel_data,
                    palettes: palettes
                };
            }
            function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {
                var colormap = palettes;
                var color, i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i++) {
                        color = image[i];
                        imageData[(x + width * y) * 4 + 3] = 255;
                        imageData[(x + width * y) * 4 + 2] = colormap[(color * 3) + 0];
                        imageData[(x + width * y) * 4 + 1] = colormap[(color * 3) + 1];
                        imageData[(x + width * y) * 4 + 0] = colormap[(color * 3) + 2];
                    }
                }
                return imageData;
            }
            function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var color, i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i += 2) {
                        color = image[i + 0] + (image[i + 1] << 8); // Inversed ?
                        imageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;
                        imageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;
                        imageData[(x + width * y) * 4 + 2] = (color & 0x001F) >> 3;
                        imageData[(x + width * y) * 4 + 3] = (color & 0x8000) ? 0 : 255;
                    }
                }
                return imageData;
            }
            function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i += 3) {
                        imageData[(x + width * y) * 4 + 3] = 255;
                        imageData[(x + width * y) * 4 + 2] = image[i + 0];
                        imageData[(x + width * y) * 4 + 1] = image[i + 1];
                        imageData[(x + width * y) * 4 + 0] = image[i + 2];
                    }
                }
                return imageData;
            }
            function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i += 4) {
                        imageData[(x + width * y) * 4 + 2] = image[i + 0];
                        imageData[(x + width * y) * 4 + 1] = image[i + 1];
                        imageData[(x + width * y) * 4 + 0] = image[i + 2];
                        imageData[(x + width * y) * 4 + 3] = image[i + 3];
                    }
                }
                return imageData;
            }
            function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var color, i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i++) {
                        color = image[i];
                        imageData[(x + width * y) * 4 + 0] = color;
                        imageData[(x + width * y) * 4 + 1] = color;
                        imageData[(x + width * y) * 4 + 2] = color;
                        imageData[(x + width * y) * 4 + 3] = 255;
                    }
                }
                return imageData;
            }
            function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
                var i = 0, x, y;
                var width = header.width;
                for (y = y_start; y !== y_end; y += y_step) {
                    for (x = x_start; x !== x_end; x += x_step, i += 2) {
                        imageData[(x + width * y) * 4 + 0] = image[i + 0];
                        imageData[(x + width * y) * 4 + 1] = image[i + 0];
                        imageData[(x + width * y) * 4 + 2] = image[i + 0];
                        imageData[(x + width * y) * 4 + 3] = image[i + 1];
                    }
                }
                return imageData;
            }
            function getTgaRGBA(width, height, image, palette) {
                var x_start, y_start, x_step, y_step, x_end, y_end, data = new Uint8Array(width * height * 4);
                switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {
                    default:
                    case TGA_ORIGIN_UL:
                        x_start = 0;
                        x_step = 1;
                        x_end = width;
                        y_start = 0;
                        y_step = 1;
                        y_end = height;
                        break;
                    case TGA_ORIGIN_BL:
                        x_start = 0;
                        x_step = 1;
                        x_end = width;
                        y_start = height - 1;
                        y_step = -1;
                        y_end = -1;
                        break;
                    case TGA_ORIGIN_UR:
                        x_start = width - 1;
                        x_step = -1;
                        x_end = -1;
                        y_start = 0;
                        y_step = 1;
                        y_end = height;
                        break;
                    case TGA_ORIGIN_BR:
                        x_start = width - 1;
                        x_step = -1;
                        x_end = -1;
                        y_start = height - 1;
                        y_step = -1;
                        y_end = -1;
                        break;
                }
                if (use_grey) {
                    switch (header.pixel_size) {
                        case 8:
                            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        case 16:
                            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        default:
                            console.error('TGAParser.parse.getTgaRGBA: not support this format');
                            break;
                    }
                }
                else {
                    switch (header.pixel_size) {
                        case 8:
                            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);
                            break;
                        case 16:
                            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        case 24:
                            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        case 32:
                            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
                            break;
                        default:
                            console.error('TGAParser.parse.getTgaRGBA: not support this format');
                            break;
                    }
                }
                // Load image data according to specific method
                // var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';
                // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );
                return data;
            }
            var result = tgaParse(use_rle, use_pal, header, offset, content);
            var rgbaData = getTgaRGBA(header.width, header.height, result.pixel_data, result.palettes);
            var texture = new egret3d.TextureBase();
            texture.internalFormat = egret3d.InternalFormat.PixelArray;
            texture.colorFormat = egret3d.Egret3DDrive.ColorFormat_RGBA8888;
            texture.mimapData.push(new egret3d.MipmapData(rgbaData, header.width, header.height));
            return texture;
        };
        return TGAParser;
    })();
    egret3d.TGAParser = TGAParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * data format describe;
     */
    (function (ESMDataFormat) {
        ESMDataFormat[ESMDataFormat["DATA_FORMAT_STATIC_MODEL"] = 1] = "DATA_FORMAT_STATIC_MODEL";
        ESMDataFormat[ESMDataFormat["DATA_FORMAT_SKELETAL_ANIM_MODEL"] = 2] = "DATA_FORMAT_SKELETAL_ANIM_MODEL";
        ESMDataFormat[ESMDataFormat["DATA_FORMAT_EXPORT_MESH"] = 4] = "DATA_FORMAT_EXPORT_MESH";
        ESMDataFormat[ESMDataFormat["DATA_FORMAT_EXIST_VERTEX_POS"] = 8] = "DATA_FORMAT_EXIST_VERTEX_POS";
        ESMDataFormat[ESMDataFormat["DATA_FORMAT_EXIST_VERTEX_NORMAL"] = 16] = "DATA_FORMAT_EXIST_VERTEX_NORMAL";
        ESMDataFormat[ESMDataFormat["DATA_FORMAT_EXIST_VERTEX_TANGENT"] = 32] = "DATA_FORMAT_EXIST_VERTEX_TANGENT";
        ESMDataFormat[ESMDataFormat["DATA_FORMAT_EXIST_VERTEX_COLOR"] = 64] = "DATA_FORMAT_EXIST_VERTEX_COLOR";
        ESMDataFormat[ESMDataFormat["DATA_FORMAT_EXIST_VERTEX_UV1"] = 128] = "DATA_FORMAT_EXIST_VERTEX_UV1";
        ESMDataFormat[ESMDataFormat["DATA_FORMAT_EXIST_VERTEX_UV2"] = 256] = "DATA_FORMAT_EXIST_VERTEX_UV2";
        ESMDataFormat[ESMDataFormat["DATA_FORMAT_EXIST_SKELETAL_DATA"] = 512] = "DATA_FORMAT_EXIST_SKELETAL_DATA";
        ESMDataFormat[ESMDataFormat["DATA_FORMAT_EXIST_WEIGHTS_DATA"] = 1024] = "DATA_FORMAT_EXIST_WEIGHTS_DATA";
    })(egret3d.ESMDataFormat || (egret3d.ESMDataFormat = {}));
    var ESMDataFormat = egret3d.ESMDataFormat;
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ESMParser
     * @classdesc
     * 用 ESMParser 类 解析.esm 文件
     */
    var ESMParser = (function () {
        function ESMParser() {
        }
        /**
          * @language zh_CN
          * 从二进制流中解析出模型Geometry信息
          * @param datas 加载的二进制流
          * @returns GeometryBase
          */
        ESMParser.parse = function (datas) {
            var bytes = new egret3d.ByteArray(datas);
            var geomtryData = new egret3d.GeometryData();
            var formatDescription = bytes.readUnsignedInt();
            var version = (formatDescription >> 28) & 0x0F;
            var textureDiffuse = bytes.readUTF();
            var textureSpecular = "";
            var textureNormal = "";
            if (version > 0) {
                textureSpecular = bytes.readUTF();
                textureNormal = bytes.readUTF();
            }
            ESMParser.readMeshInfo(bytes, geomtryData, formatDescription, version);
            var skeleton = new egret3d.Skeleton();
            ESMParser.readBoneSkinInfo(bytes, geomtryData, skeleton, version);
            var geomtry;
            if (geomtryData.source_skinData.length > 0) {
                var skinGeomtry = new egret3d.SkinGeometry();
                skinGeomtry.vertexAttLength = geomtryData.vertexAttLength = 17 + 8;
                geomtryData = egret3d.GeometryData.build(geomtryData);
                skinGeomtry.setGeomtryData(geomtryData.indices, geomtryData.vertexDatas, skeleton);
                geomtry = skinGeomtry;
            }
            else {
                geomtryData = egret3d.GeometryData.build(geomtryData);
                var staticGeomtry = new egret3d.SubGeometry();
                staticGeomtry.setGeomtryData(geomtryData.indices, geomtryData.vertexDatas);
                geomtry = staticGeomtry;
            }
            geomtry.buildBoundBox();
            geomtry.textureFile = textureDiffuse;
            geomtry.textureSpecular = textureSpecular;
            geomtry.textureBump = textureNormal;
            return geomtry;
        };
        /**
         * @language zh_CN
         * 读取mesh信息到传入的geomtryData中
         * @param bytes 二进制流
         * @param geomtryData 网格实例
         * @param formatDescription 数据格式
         * @param version 版本
         */
        ESMParser.readMeshInfo = function (bytes, geomtryData, formatDescription, version) {
            if (formatDescription & ESMDataFormat.DATA_FORMAT_EXIST_VERTEX_POS) {
                ESMParser.readVertexInfo(bytes, geomtryData, version);
            }
            if (formatDescription & ESMDataFormat.DATA_FORMAT_EXIST_VERTEX_NORMAL) {
                ESMParser.readVertexNormalsInfo(bytes, geomtryData, version);
            }
            if (formatDescription & ESMDataFormat.DATA_FORMAT_EXIST_VERTEX_COLOR) {
                ESMParser.readVertexColorsInfo(bytes, geomtryData, version);
            }
            if (formatDescription & ESMDataFormat.DATA_FORMAT_EXIST_VERTEX_UV1) {
                ESMParser.readVertexUVInfo(bytes, geomtryData.source_uvData, version);
            }
            if (formatDescription & ESMDataFormat.DATA_FORMAT_EXIST_VERTEX_UV2) {
                ESMParser.readVertexUVInfo(bytes, geomtryData.source_uv2Data, version);
            }
            ESMParser.readVertexIndexInfo(bytes, geomtryData, formatDescription, version);
        };
        /**
         * @language zh_CN
         * 读取顶点信息到geomtryData实例中
         * @param bytes 二进制信息
         * @param geomtryData geomtryData实例
         * @param version 版本
         */
        ESMParser.readVertexInfo = function (bytes, geomtryData, version) {
            var vertexCount = bytes.readInt();
            for (var i = 0; i < vertexCount; i++) {
                geomtryData.source_vertexData.push(new egret3d.Vector3D(bytes.readFloat(), bytes.readFloat(), bytes.readFloat()));
            }
        };
        /**
         * @language zh_CN
         * 读取顶点法线信息
         * @param bytes
         * @param geomtryData
         * @param version
         */
        ESMParser.readVertexNormalsInfo = function (bytes, geomtryData, version) {
            var vertexNormalCount = bytes.readInt();
            for (var i = 0; i < vertexNormalCount; i++) {
                geomtryData.source_normalData.push(new egret3d.Vector3D(bytes.readFloat(), bytes.readFloat(), bytes.readFloat()));
            }
        };
        /**
         * @language zh_CN
         * 读取顶点颜色
         * @param bytes
         * @param geomtryData
         * @param version
         */
        ESMParser.readVertexColorsInfo = function (bytes, geomtryData, version) {
            var vertexColorCount = bytes.readInt();
            for (var i = 0; i < vertexColorCount; i++) {
                geomtryData.source_vertexColorData.push(new egret3d.Vector3D(bytes.readFloat(), bytes.readFloat(), bytes.readFloat(), bytes.readFloat()));
            }
        };
        /**
         * @language zh_CN
         * 读取顶点UV
         * @param bytes
         * @param source_uvData
         * @param version
         */
        ESMParser.readVertexUVInfo = function (bytes, source_uvData, version) {
            var uvCount = bytes.readInt();
            for (var i = 0; i < uvCount; i++) {
                source_uvData.push(new egret3d.UV(bytes.readFloat(), bytes.readFloat()));
            }
        };
        ESMParser.readVertexIndexInfo = function (bytes, geomtryData, formatDescription, version) {
            var PosIndex1, PosIndex2, PosIndex3;
            var uv1_1, uv1_2, uv1_3;
            var facesCount = bytes.readInt();
            var uv1_index = 1;
            var uv2_index = 1;
            for (var i = 0; i < facesCount; i++) {
                var faceData = new egret3d.FaceData();
                PosIndex1 = bytes.readUnsignedInt();
                PosIndex2 = bytes.readUnsignedInt();
                PosIndex3 = bytes.readUnsignedInt();
                faceData.vertexIndices.push(PosIndex1 + 1, PosIndex2 + 1, PosIndex3 + 1);
                if (formatDescription & ESMDataFormat.DATA_FORMAT_EXIST_VERTEX_NORMAL) {
                    faceData.normalIndices.push(bytes.readUnsignedInt() + 1, bytes.readUnsignedInt() + 1, bytes.readUnsignedInt() + 1);
                }
                if (formatDescription & ESMDataFormat.DATA_FORMAT_EXIST_VERTEX_COLOR) {
                    faceData.colorIndices.push(bytes.readUnsignedInt() + 1, bytes.readUnsignedInt() + 1, bytes.readUnsignedInt() + 1);
                }
                if (formatDescription & ESMDataFormat.DATA_FORMAT_EXIST_VERTEX_UV1) {
                    if (version >= 2) {
                        faceData.uvIndices.push(bytes.readUnsignedInt() + 1, bytes.readUnsignedInt() + 1, bytes.readUnsignedInt() + 1);
                    }
                    else {
                        faceData.uvIndices.push(uv1_index++, uv1_index++, uv1_index++);
                    }
                }
                if (formatDescription & ESMDataFormat.DATA_FORMAT_EXIST_VERTEX_UV2) {
                    if (version >= 2) {
                        faceData.uv2Indices.push(bytes.readUnsignedInt() + 1, bytes.readUnsignedInt() + 1, bytes.readUnsignedInt() + 1);
                    }
                    else {
                        faceData.uv2Indices.push(uv2_index++, uv2_index++, uv2_index++);
                    }
                }
                faceData.indexIds.push(String(PosIndex1 + 1) + "/" + String(uv1_1 + 1) + "/" + String(PosIndex1 + 1));
                faceData.indexIds.push(String(PosIndex2 + 1) + "/" + String(uv1_2 + 1) + "/" + String(PosIndex2 + 1));
                faceData.indexIds.push(String(PosIndex3 + 1) + "/" + String(uv1_3 + 1) + "/" + String(PosIndex3 + 1));
                geomtryData.source_faceData.push(faceData);
            }
        };
        ESMParser.readBoneSkinInfo = function (bytes, geomtryData, skeleton, version) {
            ESMParser.readBoneInfo(bytes, skeleton, version);
            ESMParser.readSkinInfo(bytes, geomtryData, version);
        };
        ESMParser.readBoneInfo = function (bytes, skeleton, version) {
            var nBoneCount = bytes.readUnsignedByte();
            var orientation = new egret3d.Quaternion();
            var rotation = new egret3d.Vector3D();
            var scaling = new egret3d.Vector3D();
            var translation = new egret3d.Vector3D();
            for (var i = 0; i < nBoneCount; i++) {
                var joint = new egret3d.Joint(null);
                bytes.readInt();
                joint.parentIndex = bytes.readInt();
                joint.name = bytes.readUTF();
                rotation.x = bytes.readFloat() * egret3d.Matrix3DUtils.RADIANS_TO_DEGREES;
                rotation.y = bytes.readFloat() * egret3d.Matrix3DUtils.RADIANS_TO_DEGREES;
                rotation.z = bytes.readFloat() * egret3d.Matrix3DUtils.RADIANS_TO_DEGREES;
                /*orientation.x = bytes.readFloat();
                orientation.y = bytes.readFloat();
                orientation.z = bytes.readFloat();
                orientation.w = bytes.readFloat();*/
                scaling.x = bytes.readFloat();
                scaling.y = bytes.readFloat();
                scaling.z = bytes.readFloat();
                translation.x = bytes.readFloat();
                translation.y = bytes.readFloat();
                translation.z = bytes.readFloat();
                joint.setInverseBindPose(translation, rotation, scaling);
                skeleton.joints.push(joint);
            }
        };
        ESMParser.readSkinInfo = function (bytes, geomtryData, version) {
            var nVertsCount = bytes.readInt();
            var nBoneIndex = 0;
            var nBoneWeight = 0;
            for (var i = 0; i < nVertsCount; i++) {
                var nCount = bytes.readUnsignedByte();
                for (var j = 0; j < nCount; j++) {
                    nBoneIndex = bytes.readUnsignedByte();
                    nBoneWeight = bytes.readFloat();
                    geomtryData.source_skinData.push(nBoneIndex, nBoneWeight);
                }
                for (var j = nCount; j < 4; j++) {
                    nBoneIndex = 0;
                    nBoneWeight = 0;
                    geomtryData.source_skinData.push(nBoneIndex, nBoneWeight);
                }
            }
        };
        return ESMParser;
    })();
    egret3d.ESMParser = ESMParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.EAMParser
     * @classdesc
     * 用 EAMParser 类 解析.eam 文件
     */
    var EAMParser = (function () {
        function EAMParser() {
        }
        /**
         * @language zh_CN
         * @param datas 加载的二进制流
         * @returns SkeletonAnimationClip
         */
        EAMParser.parse = function (datas) {
            var bytes = new egret3d.ByteArray(datas);
            var boneCount = bytes.readUnsignedByte();
            var animationName = bytes.readUTF();
            var sampling = bytes.readUnsignedByte();
            if (boneCount <= 0)
                return new egret3d.SkeletonAnimationClip(animationName);
            var boneNameArray = new Array();
            var parentBoneNameArray = new Array();
            for (var i = 0; i < boneCount; i++) {
                boneNameArray.push(bytes.readUTF());
                parentBoneNameArray.push(bytes.readUTF());
            }
            var frameCount = bytes.readInt();
            var poseArray = new Array();
            var nCount = bytes.readInt();
            for (var i = 0; i < nCount; i++) {
                var skeletonPose = new egret3d.Skeleton();
                skeletonPose.frameTime = bytes.readInt();
                for (var j = 0; j < boneCount; j++) {
                    var jointPose = new egret3d.Joint(boneNameArray[j]);
                    jointPose.parent = parentBoneNameArray[j];
                    jointPose.setLocalTransform(new egret3d.Quaternion().fromEulerAngles(bytes.readFloat() * egret3d.Matrix3DUtils.RADIANS_TO_DEGREES, bytes.readFloat() * egret3d.Matrix3DUtils.RADIANS_TO_DEGREES, bytes.readFloat() * egret3d.Matrix3DUtils.RADIANS_TO_DEGREES), new egret3d.Vector3D(bytes.readFloat(), bytes.readFloat(), bytes.readFloat()), new egret3d.Vector3D(bytes.readFloat(), bytes.readFloat(), bytes.readFloat()));
                    skeletonPose.joints.push(jointPose);
                }
                if (i > 0) {
                    var pose = new egret3d.Skeleton();
                    pose.frameTime = skeletonPose.frameTime - 160 / 2;
                    var currentSkeletonPose = poseArray[poseArray.length - 1];
                    for (var j = 0; j < boneCount; j++) {
                        var jointPose = new egret3d.Joint(currentSkeletonPose.joints[j].name);
                        jointPose.parent = currentSkeletonPose.joints[j].parent;
                        jointPose.orientation = new egret3d.Quaternion();
                        jointPose.orientation.lerp(currentSkeletonPose.joints[j].orientation, skeletonPose.joints[j].orientation, 0.5);
                        jointPose.scale = new egret3d.Vector3D();
                        jointPose.scale.lerp(currentSkeletonPose.joints[j].scale, skeletonPose.joints[j].scale, 0.5);
                        jointPose.translation = new egret3d.Vector3D();
                        jointPose.translation.lerp(currentSkeletonPose.joints[j].translation, skeletonPose.joints[j].translation, 0.5);
                        jointPose.setLocalTransform(jointPose.orientation, jointPose.scale, jointPose.translation);
                        pose.joints.push(jointPose);
                    }
                    poseArray.push(pose);
                }
                poseArray.push(skeletonPose);
            }
            var skeletonAnimationClip = new egret3d.SkeletonAnimationClip(animationName);
            skeletonAnimationClip.sampling = sampling;
            skeletonAnimationClip.frameCount = frameCount * 2;
            skeletonAnimationClip.poseArray = poseArray;
            return skeletonAnimationClip;
        };
        return EAMParser;
    })();
    egret3d.EAMParser = EAMParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.ECAParser
     * @classdesc
     * 用 ECAParser 类 解析.eca 文件
     */
    var ECAParser = (function () {
        function ECAParser() {
        }
        /**
         * @language zh_CN
         * @param datas 加载的二进制流
         * @returns CameraAnimationController
         */
        ECAParser.parse = function (datas) {
            var bytes = new egret3d.ByteArray(datas);
            var cameraAnimationController = new egret3d.CameraAnimationController();
            var nFrame = bytes.readUnsignedInt();
            var cameraAnimationFrame = null;
            var scaling = new egret3d.Vector3D(1, 1, 1, 1);
            while (nFrame--) {
                cameraAnimationFrame = new egret3d.CameraAnimationFrame();
                cameraAnimationFrame.time = bytes.readInt();
                cameraAnimationFrame.fov = bytes.readFloat();
                cameraAnimationFrame.rotation = new egret3d.Vector3D(bytes.readFloat(), bytes.readFloat(), bytes.readFloat());
                cameraAnimationFrame.translation = new egret3d.Vector3D(bytes.readFloat(), bytes.readFloat(), bytes.readFloat());
                cameraAnimationFrame.matrix = new egret3d.Matrix4_4();
                cameraAnimationFrame.matrix.recompose([cameraAnimationFrame.translation, cameraAnimationFrame.rotation, scaling]);
                cameraAnimationController.cameraAnimationFrames.push(cameraAnimationFrame);
            }
            return cameraAnimationController;
        };
        return ECAParser;
    })();
    egret3d.ECAParser = ECAParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.PVR
     * @classdesc
     * PVR  object
     */
    var PVR = (function () {
        function PVR() {
        }
        return PVR;
    })();
    egret3d.PVR = PVR;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    */
    (function (PVRFormat) {
        PVRFormat[PVRFormat["RGB_PVRTC_4BPPV1_Format"] = 2100] = "RGB_PVRTC_4BPPV1_Format";
        PVRFormat[PVRFormat["RGB_PVRTC_2BPPV1_Format"] = 2101] = "RGB_PVRTC_2BPPV1_Format";
        PVRFormat[PVRFormat["RGBA_PVRTC_4BPPV1_Format"] = 2102] = "RGBA_PVRTC_4BPPV1_Format";
        PVRFormat[PVRFormat["RGBA_PVRTC_2BPPV1_Format"] = 2103] = "RGBA_PVRTC_2BPPV1_Format";
    })(egret3d.PVRFormat || (egret3d.PVRFormat = {}));
    var PVRFormat = egret3d.PVRFormat;
    ;
    /**
     * @private
     * @language zh_CN
     * @class egret3d.PVRParser
     * @classdesc
     * �� PVRParser �� ����.pvr �ļ�
     */
    var PVRParser = (function () {
        function PVRParser() {
        }
        /**
         * @language zh_CN
         * @param buffer
         */
        PVRParser.parse = function (buffer) {
            var pvr = new egret3d.PVR;
            var headerLengthInt = 13;
            var header = new Uint32Array(buffer, 0, headerLengthInt);
            var pvrDatas = {
                buffer: buffer,
                header: header
            };
            // PVR v3
            if (header[0] === 0x03525650) {
                pvr = PVRParser._parseV3(pvrDatas);
            }
            else if (header[11] === 0x21525650) {
                pvr = PVRParser._parseV2(pvrDatas);
            }
            else {
                console.log("PVRParser unknow pvr format. PVRParser::parse");
            }
            return pvr;
        };
        PVRParser._parseV2 = function (pvrDatas) {
            var header = pvrDatas.header;
            var headerLength = header[0], height = header[1], width = header[2], numMipmaps = header[3], flags = header[4], dataLength = header[5], bpp = header[6], bitmaskRed = header[7], bitmaskGreen = header[8], bitmaskBlue = header[9], bitmaskAlpha = header[10], pvrTag = header[11], numSurfs = header[12];
            var TYPE_MASK = 0xff;
            var PVRTC_2 = 24, PVRTC_4 = 25;
            var formatFlags = flags & TYPE_MASK;
            var bpp, format;
            var _hasAlpha = bitmaskAlpha > 0;
            if (formatFlags === PVRTC_4) {
                format = _hasAlpha ? PVRFormat.RGBA_PVRTC_4BPPV1_Format : PVRFormat.RGB_PVRTC_4BPPV1_Format;
                bpp = 4;
            }
            else if (formatFlags === PVRTC_2) {
                format = _hasAlpha ? PVRFormat.RGBA_PVRTC_2BPPV1_Format : PVRFormat.RGB_PVRTC_2BPPV1_Format;
                bpp = 2;
            }
            else
                throw new Error("pvrtc - unknown format " + formatFlags);
            pvrDatas.dataPtr = headerLength;
            pvrDatas.bpp = bpp;
            pvrDatas.format = format;
            pvrDatas.width = width;
            pvrDatas.height = height;
            pvrDatas.numSurfaces = numSurfs;
            pvrDatas.numMipmaps = numMipmaps + 1;
            // guess cubemap type seems tricky in v2
            // it juste a pvr containing 6 surface (no explicit cubemap type)
            pvrDatas.isCubemap = (numSurfs === 6);
            return PVRParser._extract(pvrDatas);
        };
        PVRParser._parseV3 = function (pvrDatas) {
            var header = pvrDatas.header;
            var bpp, format;
            var metaLen = header[12], pixelFormat = header[2], height = header[6], width = header[7], numSurfs = header[9], numFaces = header[10], numMipmaps = header[11];
            switch (pixelFormat) {
                case 0:
                    bpp = 2;
                    format = PVRFormat.RGB_PVRTC_2BPPV1_Format;
                    break;
                case 1:
                    bpp = 2;
                    format = PVRFormat.RGBA_PVRTC_2BPPV1_Format;
                    break;
                case 2:
                    bpp = 4;
                    format = PVRFormat.RGB_PVRTC_4BPPV1_Format;
                    break;
                case 3:
                    bpp = 4;
                    format = PVRFormat.RGBA_PVRTC_4BPPV1_Format;
                    break;
                default:
                    throw new Error("pvrtc - unsupported PVR format " + pixelFormat);
            }
            pvrDatas.dataPtr = 52 + metaLen;
            pvrDatas.bpp = bpp;
            pvrDatas.format = format;
            pvrDatas.width = width;
            pvrDatas.height = height;
            pvrDatas.numSurfaces = numFaces;
            pvrDatas.numMipmaps = numMipmaps;
            pvrDatas.isCubemap = (numFaces === 6);
            return PVRParser._extract(pvrDatas);
        };
        PVRParser._extract = function (pvrDatas) {
            var pvr = new egret3d.PVR();
            var buffer = pvrDatas.buffer;
            var dataOffset = pvrDatas.dataPtr, bpp = pvrDatas.bpp, numSurfs = pvrDatas.numSurfaces, dataSize = 0, blockSize = 0, blockWidth = 0, blockHeight = 0, widthBlocks = 0, heightBlocks = 0;
            if (bpp === 2) {
                blockWidth = 8;
                blockHeight = 4;
            }
            else {
                blockWidth = 4;
                blockHeight = 4;
            }
            blockSize = (blockWidth * blockHeight) * bpp / 8;
            pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;
            var mipLevel = 0;
            while (mipLevel < pvrDatas.numMipmaps) {
                var sWidth = pvrDatas.width >> mipLevel;
                var sHeight = pvrDatas.height >> mipLevel;
                widthBlocks = sWidth / blockWidth;
                heightBlocks = sHeight / blockHeight;
                // Clamp to minimum number of blocks
                if (widthBlocks < 2) {
                    widthBlocks = 2;
                }
                if (heightBlocks < 2) {
                    heightBlocks = 2;
                }
                dataSize = widthBlocks * heightBlocks * blockSize;
                for (var surfIndex = 0; surfIndex < numSurfs; surfIndex++) {
                    var byteArray = new Uint8Array(buffer, dataOffset, dataSize);
                    var mipmap = {
                        data: byteArray,
                        width: sWidth,
                        height: sHeight
                    };
                    pvr.mipmaps[surfIndex * pvrDatas.numMipmaps + mipLevel] = mipmap;
                    dataOffset += dataSize;
                }
                mipLevel++;
            }
            return pvr;
        };
        return PVRParser;
    })();
    egret3d.PVRParser = PVRParser;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.AssetsManager
     * @classdesc
     * AssetsManager 资源管理类.
     * 用于加载各类3d美术资源.
     * 模型.场景.贴图,等.
     * @version Egret 3.0
     * @platform Web,Native
     */
    var AssetsManager = (function (_super) {
        __extends(AssetsManager, _super);
        /**
         * @private
         * @language zh_CN
         * constructor
         * @version Egret 3.0
         * @platform Web,Native
         */
        function AssetsManager() {
            _super.call(this);
            this.loadList = [];
            this.completeCount = 0;
            this.assets = {};
            this.assetsModel = {};
            this.assetsScene = {};
            this.assetsTexture = {};
            this.rootURL = "";
        }
        /**
         * @language zh_CN
         * 获取单例实例
         * @returns AssetsManager
         * @version Egret 3.0
         * @platform Web,Native
         */
        AssetsManager.getInstance = function () {
            return AssetsManager._instance;
        };
        /**
         * @language zh_CN
         * 设置根路径
         * @param rootURL
         * @version Egret 3.0
         * @platform Web,Native
         */
        AssetsManager.prototype.setRootURL = function (rootURL) {
            this.rootURL = rootURL;
        };
        /**
         * @language zh_CN
         * 查找资源
         * @param url 路径地址
         * @returns 返回对应url的资源
         * @version Egret 3.0
         * @platform Web,Native
         */
        AssetsManager.prototype.findAssets = function (url) {
            return this.assets[this.rootURL + url];
        };
        /**
         * @language zh_CN
         * 查找已下载的模型.
         * @param url 路径地址
         * @returns mesh
         * @version Egret 3.0
         * @platform Web,Native
         */
        AssetsManager.prototype.findModel = function (url) {
            return this.assetsModel[this.rootURL + url];
        };
        /**
         * @language zh_CN
         * 查找已下载的动作模型文件
         * @param url 路径地址
         * @returns Mesh
         * @version Egret 3.0
         * @platform Web,Native
         */
        AssetsManager.prototype.findAnimModel = function (url) {
            return this.assetsModel[this.rootURL + url];
        };
        /**
         * @language zh_CN
         * 查找已经下载完成的场景资源文件
         * @param url 路径地址
         * @returns Array<Mesh>
         * @version Egret 3.0
         * @platform Web,Native
         */
        AssetsManager.prototype.findScene = function (url) {
            return this.assetsScene[this.rootURL + url];
        };
        /**
         * @language zh_CN
         * 查找贴图
         * @param url 路径地址
         * @returns TexureBase
         * @version Egret 3.0
         * @platform Web,Native
         */
        AssetsManager.prototype.findTexture = function (url) {
            return this.assetsTexture[this.rootURL + url];
        };
        /**
         * @language zh_CN
         * 启动加载, 加载目标为通过add系列方法添加的资源路径
         * @version Egret 3.0
         * @platform Web,Native
         */
        AssetsManager.prototype.startLoad = function () {
            var _this = this;
            for (var i = 0; i < this.loadList.length; i++) {
                var loader = this.loadList[i];
                loader.addEventListener(egret3d.Event3D.EVENT_LOAD_COMPLETE, function (e) { return _this.checkComplete(e); });
                loader.load();
            }
        };
        /**
         * @language zh_CN
         * 加载模型, 将地址传入加载队列, 调用startLoad之后才会进行加载
         * @param url 模型路径
         * @param ESMFile 模型文件名
         * @version Egret 3.0
         * @platform Web,Native
         */
        AssetsManager.prototype.addLoadModel = function (url, ESMFile) {
            var modelLoad = new egret3d.ModeLoader(this.rootURL + url, ESMFile);
            this.loadList.push(modelLoad);
        };
        /**
         * @language zh_CN
         * 加载模型动作文件, 将加入加载队列, 在调用startLoad()之后进行加载  加载完成后, 会自动将加载的动作文件和模型一起绑定
         * @param url 模型路径
         * @param ESMFile 模型文件名
         * @param EAMFiles 模型动作名列表
         * @version Egret 3.0
         * @platform Web,Native
         */
        AssetsManager.prototype.addLoadAnimModel = function (url, ESMFile, EAMFiles) {
            var modelLoad = new egret3d.ModeLoader(this.rootURL + url, ESMFile, EAMFiles);
            this.loadList.push(modelLoad);
        };
        /**
         * @language zh_CN
         * 加载场景, 将加入加载队列, 在调用startLoad()之后进行加载
         * @param url 场景文件地址
         * @version Egret 3.0
         * @platform Web,Native
         */
        AssetsManager.prototype.addLoadScene = function (url) {
            var sceneLoader = new egret3d.SceneLoader(this.rootURL + url);
            this.loadList.push(sceneLoader);
        };
        /**
         * @language zh_CN
         * 加载贴图文件, 将加入加载队列, 在调用startLoad()之后进行加载
         * @param url 要加载的贴图文件地址
         * @version Egret 3.0
         * @platform Web,Native
         */
        AssetsManager.prototype.addLoadTexture = function (url) {
            var textureLoader = new egret3d.TextureLoader(this.rootURL + url);
            this.loadList.push(textureLoader);
        };
        /**
         * @private
         * @param e
         * @version Egret 3.0
         * @platform Web,Native
         */
        AssetsManager.prototype.checkComplete = function (e) {
            var loader = e.data;
            switch (loader.type) {
                case egret3d.LoaderType.LOADER_MODEL_TYPE:
                    var modeLoader = loader;
                    this.assets[modeLoader.url + modeLoader.esmFile] = modeLoader.mesh;
                    this.assetsModel[modeLoader.url + modeLoader.esmFile] = modeLoader.mesh;
                    break;
                case egret3d.LoaderType.LOADER_SCENE_TYPE:
                    this.assets[loader.url] = loader.meshList;
                    this.assetsScene[loader.url] = loader.meshList;
                    break;
                case egret3d.LoaderType.LOADER_TEXTURE_TYPE:
                    this.assets[loader.url] = loader.texture;
                    this.assetsTexture[loader.url] = loader.texture;
                    break;
            }
            this.completeCount++;
            if (this.completeCount >= this.loadList.length) {
                this.dispatchEvent(new egret3d.Event3D(egret3d.Event3D.EVENT_LOAD_COMPLETE, this));
            }
        };
        /**
         * @language zh_CN
         * @private
         */
        AssetsManager._instance = new AssetsManager();
        return AssetsManager;
    })(egret3d.EventDispatcher);
    egret3d.AssetsManager = AssetsManager;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.Picker
    * @classdesc
    * 射线对场景中的实体对像进行检测。
    * 以摄像机向场景中产生的一条射线对所有场景中的对象进行拾取，
    * 根据性能的需要分为几种拣选类型
    * 1.包围盒拣选
    * 2.模型拣选返回模型拣选到的位置
    * 3.模型拣选返回模型拣选到的UV坐标
    *
    * @see egret3d.geom.Ray
    * @see egret3d.core.PickType
    *
    * 示例:鼠标拣选模型,拣选到的进行绕Y轴旋转
    * @includeExample core/traverse/Picker.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var Picker = (function () {
        function Picker() {
        }
        /**
        * @language zh_CN
        * 返回鼠标拾取对象得到的所有对象,调用之前到设置被拣选对象的pickType.
        * @param camera 当前相机
        * @param objects 检测的对象列表
        * @returns 拾取的object列表
        * @version Egret 3.0
        * @platform Web,Native
        */
        Picker.pickObject3DList = function (camera, objects) {
            var ret = new Array();
            var ray = this.ray;
            ray.CalculateAndTransformRay(egret3d.Egret3DDrive.canvasRectangle.width, egret3d.Egret3DDrive.canvasRectangle.height, camera.modelMatrix, camera.projectMatrix, egret3d.Input.instance.mouseX, egret3d.Input.instance.mouseY);
            for (var i = 0; i < objects.length; ++i) {
                var mesh = objects[i];
                var inPos = new egret3d.Vector3D();
                switch (mesh.pickType) {
                    case egret3d.PickType.BoundPick:
                        if (mesh.box != null) {
                            if (ray.IntersectMesh(mesh.box.vexData, mesh.box.indexData, 3, mesh.box.indexData.length / 3, 0, mesh.modelMatrix, mesh.pickerData)) {
                                var target = new egret3d.PickResult();
                                ret.push(objects[i]);
                            }
                        }
                        break;
                    case egret3d.PickType.PositionPick:
                        if (ray.IntersectMeshEx(mesh, 13, mesh.pickerData)) {
                            var target = new egret3d.PickResult();
                            ret.push(objects[i]);
                        }
                        break;
                    case egret3d.PickType.UVPick:
                        if (ray.IntersectMeshEx(mesh, 13, mesh.pickerData)) {
                            var target = new egret3d.PickResult();
                            ret.push(objects[i]);
                        }
                        break;
                }
            }
            return ret;
        };
        Picker.ray = new egret3d.Ray();
        return Picker;
    })();
    egret3d.Picker = Picker;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.ControllerBase
    * @classdesc
    * 控制器 基类, 抽象控制器的一些数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var ControllerBase = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @param targetObject 控制的目标
        */
        function ControllerBase(targetObject, lookAtObject) {
            if (targetObject === void 0) { targetObject = null; }
            if (lookAtObject === void 0) { lookAtObject = null; }
            this._autoUpdate = true;
            this._origin = new egret3d.Vector3D(0.0, 0.0, 0.0);
            this._target = targetObject;
            this._lookAtObject = lookAtObject;
        }
        Object.defineProperty(ControllerBase.prototype, "target", {
            /**
            * @language zh_CN
            *
            * @returns 返回当前的目标
            */
            get: function () {
                return this._target;
            },
            /**
            * @language zh_CN
            *
            * @param val 当前的目标
            */
            set: function (val) {
                if (this._target == val)
                    return;
                ///if (this._target && _autoUpdate)
                ///    this._target._controller = null;
                this._target = val;
                ///if (this._target && _autoUpdate)
                ///    this._target._controller = this;
                ///notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ControllerBase.prototype, "autoUpdate", {
            /**
            * @language zh_CN
            *
            * @returns 是否自动更新
            */
            get: function () {
                return this._autoUpdate;
            },
            /**
            * @language zh_CN
            *
            * @param val 是否自动更新
            */
            set: function (val) {
                if (this._autoUpdate == val)
                    return;
                this._autoUpdate = val;
            },
            enumerable: true,
            configurable: true
        });
        ControllerBase.prototype.notifyUpdate = function () {
            ///if (_targetObject && _targetObject.implicitPartition && _autoUpdate)
            ///    _targetObject.implicitPartition.markForUpdate(_targetObject);
        };
        /**
        * @language zh_CN
        * 数据更新
        */
        ControllerBase.prototype.update = function () {
            ///throw null ;
        };
        return ControllerBase;
    })();
    egret3d.ControllerBase = ControllerBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.LookAtController
    * @classdesc
    * look at 摄像机控制器 。
    * 指定摄像机看向的目标对象
    * 1.按下鼠标左键并移动鼠标可以使摄像机绕着目标进行旋转.
    * 2.按下键盘的(w s a d) 可以摄像机(上 下 左 右)移动.
    * 3.滑动鼠标滚轮可以控制摄像机的视距.
    *
    * 示例:
    * @includeExample controller/ctl/LookAtController.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var LookAtController = (function (_super) {
        __extends(LookAtController, _super);
        /**
        * @language zh_CN
        * 控制的目标相机，目标对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function LookAtController(targetObject, lookAtObject) {
            var _this = this;
            if (targetObject === void 0) { targetObject = null; }
            if (lookAtObject === void 0) { lookAtObject = null; }
            _super.call(this, targetObject);
            this._origin = new egret3d.Vector3D(0.0, 0.0, 0.0);
            this._lookAtPosition = new egret3d.Vector3D();
            this._eyesPos = new egret3d.Vector3D();
            this._up = egret3d.Vector3D.Y_AXIS;
            this._eyesLength = 0;
            this._rotaEyesLine = new egret3d.Vector3D(0, 0, 1);
            this._rotaAngle = new egret3d.Vector3D();
            this._matRot = new egret3d.Matrix4_4();
            this._quaRot = new egret3d.Quaternion();
            this._tempVec = new egret3d.Vector3D();
            this._matTemp = new egret3d.Matrix4_4();
            this._mouseDown = false;
            this._mouseRightDown = false;
            this._screenMoveStartDetail = new egret3d.Point();
            this._screenMoveDelay = new egret3d.Point();
            this._isUpdate = false;
            this._elapsed = 0;
            this._speed = 3;
            this._xAngle = 0;
            this._keyArray = new Array();
            /**
            * @language zh_CN
            * 目标点偏移
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lookAtOffset = new egret3d.Vector3D(0, 0, 0);
            /**
            * @language zh_CN
            * 是否第一人称相机
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.firstCamera = false;
            this._keyArray.push(false);
            this._keyArray.push(false);
            this._keyArray.push(false);
            this._keyArray.push(false);
            if (lookAtObject)
                this.lookAtObject = lookAtObject;
            else
                this.lookAtPosition = new egret3d.Vector3D();
            this._eyesPos.copyFrom(targetObject.position);
            this._lookAtPosition.copyFrom(lookAtObject.position.add(this.lookAtOffset));
            this._target.lookAt(this._eyesPos, this._lookAtPosition);
            egret3d.Input.instance.addListenerMouseWheel(function () { return _this.mouseWheel(); });
            egret3d.Input.instance.addListenerMouseMove(function () { return _this.mouseMove(); });
            egret3d.Input.instance.addListenerKeyUp(function (e) { return _this.keyUp(e); });
            egret3d.Input.instance.addListenerKeyDown(function (e) { return _this.keyDown(e); });
            egret3d.Input.instance.addListenerSwipe(function () { return _this.mouseMove(); });
        }
        LookAtController.prototype.mouseWheel = function () {
            this.setEyesLength(this._eyesLength - egret3d.Input.instance.wheelDelta * 0.1);
        };
        LookAtController.prototype.mouseMove = function () {
            if (this._mouseDown) {
                this._rotaAngle.y += egret3d.Input.instance.mouseOffsetX;
                this._rotaAngle.x += egret3d.Input.instance.mouseOffsetY;
                this._rotaAngle.y %= 360;
                this._rotaAngle.x %= 360;
            }
        };
        Object.defineProperty(LookAtController.prototype, "lookAtPosition", {
            /**
            * @language zh_CN
            * 返回目标的位置
            *
            * @returns 目标的位置
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._lookAtPosition;
            },
            /**
            * @language zh_CN
            * 设置目标坐标
            *
            * @param val 摄像机看向的目标点
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._lookAtObject)
                    this._lookAtObject = null;
                this._lookAtPosition.copyFrom(val.add(this.lookAtOffset));
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "lookAtObject", {
            /**
            * @language zh_CN
            *
            * 返回目标对象
            * @returns 目标对象
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._lookAtObject;
            },
            /**
            * @language zh_CN
            *
            * 设置目标对象
            * @param val 目标
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                if (this._lookAtObject == val)
                    return;
                this._lookAtObject = val;
                this._lookAtPosition.copyFrom(this._lookAtObject.position.add(this.lookAtOffset));
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 设置目标和相机的距离
        * @param length 距离
        * @version Egret 3.0
        * @platform Web,Native
        */
        LookAtController.prototype.setEyesLength = function (length) {
            this._eyesLength = length;
            if (this._eyesLength < 1) {
                this._eyesLength = 1;
            }
        };
        Object.defineProperty(LookAtController.prototype, "rotationX", {
            /**
            * @language zh_CN
            * 设置相机x轴旋转
            * @param x 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (x) {
                this._rotaAngle.x = x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "rotationY", {
            /**
            * @language zh_CN
            * 设置相机y轴旋转
            * @param y 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (y) {
                this._rotaAngle.y = y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LookAtController.prototype, "rotationZ", {
            /**
            * @language zh_CN
            * 设置相机z轴旋转
            * @param z 旋转角度
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (z) {
                this._rotaAngle.z = z;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 控制器数据更新
        * @version Egret 3.0
        * @platform Web,Native
        */
        LookAtController.prototype.update = function () {
            if (this._target) {
                if (this._target.isController == false) {
                    return;
                }
                if (this._keyArray[0]) {
                    this._tempVec.copyFrom(this._rotaEyesLine);
                    this._tempVec.y = 0;
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(this._speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.add(this._tempVec));
                    this._lookAtObject.position = this._tempVec;
                }
                if (this._keyArray[1]) {
                    this._tempVec.copyFrom(this._rotaEyesLine);
                    this._matTemp.identity();
                    this._matTemp.appendRotation(90, egret3d.Vector3D.Y_AXIS);
                    this._tempVec.copyFrom(this._matTemp.transformVector(this._tempVec));
                    this._tempVec.y = 0;
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(this._speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.subtract(this._tempVec));
                    this._lookAtObject.position = this._tempVec;
                }
                if (this._keyArray[2]) {
                    this._tempVec.copyFrom(this._rotaEyesLine);
                    this._tempVec.y = 0;
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(this._speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.subtract(this._tempVec));
                    this._lookAtObject.position = this._tempVec;
                }
                if (this._keyArray[3]) {
                    this._tempVec.copyFrom(this._rotaEyesLine);
                    this._matTemp.identity();
                    this._matTemp.appendRotation(90, egret3d.Vector3D.Y_AXIS);
                    this._tempVec.copyFrom(this._matTemp.transformVector(this._tempVec));
                    this._tempVec.y = 0;
                    this._tempVec.normalize();
                    this._tempVec.scaleBy(this._speed);
                    this._tempVec.copyFrom(this._lookAtObject.position.add(this._tempVec));
                    this._lookAtObject.position = this._tempVec;
                }
                this._quaRot.fromEulerAngles(this._rotaAngle.x, this._rotaAngle.y, 0);
                this._rotaEyesLine.copyFrom(this._quaRot.rotatePoint(egret3d.Vector3D.Z_AXIS));
                this._rotaEyesLine.normalize();
                this._tempVec.copyFrom(this._rotaEyesLine);
                this._tempVec.scaleBy(this._eyesLength);
                this._eyesPos.copyFrom(this._lookAtPosition.subtract(this._tempVec));
                if (this._lookAtObject) {
                    this._lookAtPosition.copyFrom(this._lookAtObject.position.add(this.lookAtOffset));
                }
                this._quaRot.fromEulerAngles(this._rotaAngle.x, this._rotaAngle.y, this._rotaAngle.z);
                this._tempVec.copyFrom(this._up);
                this._tempVec.copyFrom(this._quaRot.rotatePoint(this._tempVec));
                this._tempVec.normalize();
                if (this.firstCamera) {
                    this._lookAtObject.rotationY = this._rotaAngle.y;
                    this._lookAtObject.rotationX = this._rotaAngle.x;
                }
                this._target.lookAt(this._eyesPos, this._lookAtPosition, this._tempVec);
            }
        };
        LookAtController.prototype.keyDown = function (key) {
            switch (key) {
                case egret3d.KeyCode.Key_W:
                    this._keyArray[0] = true;
                    break;
                case egret3d.KeyCode.Key_A:
                    this._keyArray[1] = true;
                    break;
                case egret3d.KeyCode.Key_S:
                    this._keyArray[2] = true;
                    break;
                case egret3d.KeyCode.Key_D:
                    this._keyArray[3] = true;
                    break;
                case egret3d.KeyCode.Key_Mouse_Left:
                    this._mouseDown = true;
                    break;
                case egret3d.KeyCode.Key_Mouse_Right:
                    this._mouseRightDown = true;
                    break;
            }
        };
        LookAtController.prototype.keyUp = function (key) {
            switch (key) {
                case egret3d.KeyCode.Key_W:
                    this._keyArray[0] = false;
                    break;
                case egret3d.KeyCode.Key_A:
                    this._keyArray[1] = false;
                    break;
                case egret3d.KeyCode.Key_S:
                    this._keyArray[2] = false;
                    break;
                case egret3d.KeyCode.Key_D:
                    this._keyArray[3] = false;
                    break;
                case egret3d.KeyCode.Key_Mouse_Left:
                    this._mouseDown = false;
                    break;
                case egret3d.KeyCode.Key_Mouse_Right:
                    this._mouseRightDown = false;
                    break;
            }
        };
        return LookAtController;
    })(egret3d.ControllerBase);
    egret3d.LookAtController = LookAtController;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var HoverController = (function (_super) {
        __extends(HoverController, _super);
        function HoverController(targetObject, lookAtObject, panAngle, tiltAngle, distance, minTiltAngle, maxTiltAngle, minPanAngle, maxPanAngle, steps, yFactor, wrapPanAngle) {
            var _this = this;
            if (targetObject === void 0) { targetObject = null; }
            if (lookAtObject === void 0) { lookAtObject = null; }
            if (panAngle === void 0) { panAngle = 0; }
            if (tiltAngle === void 0) { tiltAngle = 90; }
            if (distance === void 0) { distance = 100; }
            if (minTiltAngle === void 0) { minTiltAngle = -90; }
            if (maxTiltAngle === void 0) { maxTiltAngle = 90; }
            if (minPanAngle === void 0) { minPanAngle = NaN; }
            if (maxPanAngle === void 0) { maxPanAngle = NaN; }
            if (steps === void 0) { steps = 8; }
            if (yFactor === void 0) { yFactor = 2; }
            if (wrapPanAngle === void 0) { wrapPanAngle = false; }
            _super.call(this, targetObject, lookAtObject);
            this._currentPanAngle = 0;
            this._currentTiltAngle = 90;
            this._panAngle = 0;
            this._tiltAngle = 90;
            this._distance = 1000;
            this._minPanAngle = -Infinity;
            this._maxPanAngle = Infinity;
            this._minTiltAngle = -90;
            this._maxTiltAngle = 90;
            this._steps = 8;
            this._yFactor = 2;
            this._wrapPanAngle = false;
            this._lookAtPosition = new egret3d.Vector3D(0.0, 0.0, 0.0);
            this._mouseDown = false;
            this._mouseRightDown = false;
            this._keyArray = new Array();
            this.distance = distance;
            this.panAngle = panAngle;
            this.tiltAngle = tiltAngle;
            this.minPanAngle = minPanAngle || -Infinity;
            this.maxPanAngle = maxPanAngle || Infinity;
            this.minTiltAngle = minTiltAngle;
            this.maxTiltAngle = maxTiltAngle;
            this.steps = steps;
            this.yFactor = yFactor;
            this.wrapPanAngle = wrapPanAngle;
            //values passed in contrustor are applied immediately
            this._currentPanAngle = this._panAngle;
            this._currentTiltAngle = this._tiltAngle;
            egret3d.Input.instance.addListenerMouseMove(function () { return _this.mouseMove(); });
            egret3d.Input.instance.addListenerKeyUp(function (e) { return _this.keyUp(e); });
            egret3d.Input.instance.addListenerKeyDown(function (e) { return _this.keyDown(e); });
            egret3d.Input.instance.addListenerMouseWheel(function () { return _this.mouseWheel(); });
            egret3d.Input.instance.addListenerSwipe(function () { return _this.mouseMove(); });
        }
        HoverController.prototype.mouseWheel = function () {
            this._distance -= egret3d.Input.instance.wheelDelta * 0.1;
        };
        HoverController.prototype.keyDown = function (key) {
            switch (key) {
                case egret3d.KeyCode.Key_W:
                    this._keyArray[0] = true;
                    break;
                case egret3d.KeyCode.Key_A:
                    this._keyArray[1] = true;
                    break;
                case egret3d.KeyCode.Key_S:
                    this._keyArray[2] = true;
                    break;
                case egret3d.KeyCode.Key_D:
                    this._keyArray[3] = true;
                    break;
                case egret3d.KeyCode.Key_Mouse_Left:
                    this._mouseDown = true;
                    break;
                case egret3d.KeyCode.Key_Mouse_Right:
                    this._mouseRightDown = true;
                    break;
            }
        };
        HoverController.prototype.keyUp = function (key) {
            switch (key) {
                case egret3d.KeyCode.Key_W:
                    this._keyArray[0] = false;
                    break;
                case egret3d.KeyCode.Key_A:
                    this._keyArray[1] = false;
                    break;
                case egret3d.KeyCode.Key_S:
                    this._keyArray[2] = false;
                    break;
                case egret3d.KeyCode.Key_D:
                    this._keyArray[3] = false;
                    break;
                case egret3d.KeyCode.Key_Mouse_Left:
                    this._mouseDown = false;
                    break;
                case egret3d.KeyCode.Key_Mouse_Right:
                    this._mouseRightDown = false;
                    break;
            }
        };
        HoverController.prototype.mouseMove = function () {
            //Input.instance.mouseLastX
            if (this._mouseDown) {
                this._tiltAngle += egret3d.Input.instance.mouseOffsetY * 0.1;
                this._panAngle -= egret3d.Input.instance.mouseOffsetX * 0.1;
            }
        };
        Object.defineProperty(HoverController.prototype, "lookAtPosition", {
            get: function () {
                return this._lookAtPosition;
            },
            set: function (val) {
                this._lookAtPosition = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "steps", {
            get: function () {
                return this._steps;
            },
            set: function (val) {
                val = (val < 1) ? 1 : val;
                if (this._steps == val)
                    return;
                this._steps = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "panAngle", {
            /**
             * Rotation of the camera in degrees around the y axis. Defaults to 0.
             */
            get: function () {
                return this._panAngle;
            },
            set: function (val) {
                val = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, val));
                if (this._panAngle == val)
                    return;
                this._panAngle = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "tiltAngle", {
            /**
             * Elevation angle of the camera in degrees. Defaults to 90.
             */
            get: function () {
                return this._tiltAngle;
            },
            set: function (val) {
                val = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, val));
                if (this._tiltAngle == val)
                    return;
                this._tiltAngle = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "distance", {
            get: function () {
                return this._distance;
            },
            set: function (val) {
                if (this._distance == val)
                    return;
                this._distance = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "minPanAngle", {
            get: function () {
                return this._minPanAngle;
            },
            set: function (val) {
                if (this._minPanAngle == val)
                    return;
                this._minPanAngle = val;
                this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "maxPanAngle", {
            get: function () {
                return this._maxPanAngle;
            },
            set: function (val) {
                if (this._maxPanAngle == val)
                    return;
                this._maxPanAngle = val;
                this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "minTiltAngle", {
            get: function () {
                return this._minTiltAngle;
            },
            set: function (val) {
                if (this._minTiltAngle == val)
                    return;
                this._minTiltAngle = val;
                this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "maxTiltAngle", {
            get: function () {
                return this._maxTiltAngle;
            },
            set: function (val) {
                if (this._maxTiltAngle == val)
                    return;
                this._maxTiltAngle = val;
                this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "yFactor", {
            /**
             * Fractional difference in distance between the horizontal camera orientation and vertical camera orientation. Defaults to 2.
             *
             * @see    #distance
             */
            get: function () {
                return this._yFactor;
            },
            set: function (val) {
                if (this._yFactor == val)
                    return;
                this._yFactor = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HoverController.prototype, "wrapPanAngle", {
            get: function () {
                return this._wrapPanAngle;
            },
            set: function (val) {
                if (this._wrapPanAngle == val)
                    return;
                this._wrapPanAngle = val;
                this.notifyUpdate();
            },
            enumerable: true,
            configurable: true
        });
        HoverController.prototype.update = function (interpolate) {
            if (interpolate === void 0) { interpolate = true; }
            if (this._tiltAngle != this._currentTiltAngle || this._panAngle != this._currentPanAngle) {
                this.notifyUpdate();
                if (this._wrapPanAngle) {
                    if (this._panAngle < 0)
                        this._panAngle = (this._panAngle % 360) + 360;
                    else
                        this._panAngle = this._panAngle % 360;
                    if (this._panAngle - this._currentPanAngle < -180)
                        this._currentPanAngle -= 360;
                    else if (this._panAngle - this._currentPanAngle > 180)
                        this._currentPanAngle += 360;
                }
                if (interpolate) {
                    this._currentTiltAngle += (this._tiltAngle - this._currentTiltAngle) / (this.steps + 1);
                    this._currentPanAngle += (this._panAngle - this._currentPanAngle) / (this.steps + 1);
                }
                else {
                    this._currentPanAngle = this._panAngle;
                    this._currentTiltAngle = this._tiltAngle;
                }
                //snap coords if angle differences are close
                if ((Math.abs(this._tiltAngle - this._currentTiltAngle) < 0.01) && (Math.abs(this._panAngle - this._currentPanAngle) < 0.01)) {
                    this._currentTiltAngle = this._tiltAngle;
                    this._currentPanAngle = this._panAngle;
                }
            }
            var pos = (this._lookAtObject) ? this._lookAtObject.position : (this._lookAtPosition) ? this._lookAtPosition : this._origin;
            var p = new egret3d.Vector3D();
            p.x = pos.x + this.distance * Math.sin(this._currentPanAngle * egret3d.MathUtil.DEGREES_TO_RADIANS) * Math.cos(this._currentTiltAngle * egret3d.MathUtil.DEGREES_TO_RADIANS);
            p.z = pos.z + this.distance * Math.cos(this._currentPanAngle * egret3d.MathUtil.DEGREES_TO_RADIANS) * Math.cos(this._currentTiltAngle * egret3d.MathUtil.DEGREES_TO_RADIANS);
            p.y = pos.y + this.distance * Math.sin(this._currentTiltAngle * egret3d.MathUtil.DEGREES_TO_RADIANS) * this.yFactor;
            if (this._target) {
                if (this._lookAtPosition)
                    this._target.lookAt(p, this._lookAtPosition);
            }
        };
        return HoverController;
    })(egret3d.ControllerBase);
    egret3d.HoverController = HoverController;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.CameraAnimationController
    * @classdesc
    * 摄像机动画控制器。
    * 每个摄像机动画绑定一个摄像机，控制摄像机的行为
    * 可以更换绑定的摄像机
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CameraAnimationController = (function () {
        /**
        * @language zh_CN
        * 构造函数
        * @param camera 需要一个摄像机对象来创建摄像机动画
        * @version Egret 3.0
        * @platform Web,Native
        */
        function CameraAnimationController(camera) {
            if (camera === void 0) { camera = null; }
            /**
            * @language zh_CN
            * 相机动画每帧数据列表
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.cameraAnimationFrames = [];
            this._playing = false;
            this._playTime = 0;
            this._currentFrameIndex = 0;
            this._loop = true;
            this._smooth = false;
            this._cameraAnimationFrame = new CameraAnimationFrame();
            this._camera = camera;
            this._cameraAnimationFrame.fov = 45;
            this._cameraAnimationFrame.rotation = new egret3d.Vector3D();
            this._cameraAnimationFrame.translation = new egret3d.Vector3D();
        }
        /**
        * @language zh_CN
        * 绑定动画控制的相机
        * @param camera
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraAnimationController.prototype.bindCamera = function (camera) {
            this._camera = camera;
        };
        /**
        * @language zh_CN
        * 播放相机动画 是否循环
        * @param isLoop 是否循环播放
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraAnimationController.prototype.play = function (isLoop) {
            if (this.cameraAnimationFrames.length <= 0)
                return;
            this._loop = isLoop;
            this._playTime = 0;
            this._camera.isController = false;
            this._playing = true;
        };
        /**
        * @language zh_CN
        * 数据更新
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraAnimationController.prototype.update = function (time, delay) {
            if (!this._playing)
                return;
            this._playTime += delay * 10;
            var Tnow = this._playTime % ((this.cameraAnimationFrames[this.cameraAnimationFrames.length - 1].time - this.cameraAnimationFrames[0].time) + (160));
            var currentFrameIndex = Math.floor(Tnow / (160)) % this.cameraAnimationFrames.length;
            if (!this._loop && this._currentFrameIndex > currentFrameIndex) {
                this._playing = false;
                this._camera.isController = true;
            }
            this._currentFrameIndex = currentFrameIndex;
            var currentFrame = this.cameraAnimationFrames[currentFrameIndex];
            if (this._smooth) {
                var nextFrameIndex = (currentFrameIndex + 1) % this.cameraAnimationFrames.length;
                var nextFrame = this.cameraAnimationFrames[nextFrameIndex];
                var t = (Tnow - currentFrame.time) / Math.abs(nextFrame.time - currentFrame.time);
                ///(v1.x - v0.x) * t + v0.x;
                this._cameraAnimationFrame.fov = (nextFrame.fov - currentFrame.fov) * t + currentFrame.fov;
                this._cameraAnimationFrame.rotation.copyFrom(currentFrame.rotation); ///.lerp(currentFrame.rotation, nextFrame.rotation, t);
                this._cameraAnimationFrame.translation.lerp(currentFrame.translation, nextFrame.translation, t);
            }
            else {
                this._cameraAnimationFrame.fov = currentFrame.fov;
                this._cameraAnimationFrame.rotation.copyFrom(currentFrame.rotation);
                this._cameraAnimationFrame.translation.copyFrom(currentFrame.translation);
            }
            this._camera.fieldOfView = this._cameraAnimationFrame.fov;
            this._camera.rotationX = this._cameraAnimationFrame.rotation.x * egret3d.Matrix3DUtils.RADIANS_TO_DEGREES + 90;
            this._camera.rotationY = this._cameraAnimationFrame.rotation.y * egret3d.Matrix3DUtils.RADIANS_TO_DEGREES;
            this._camera.rotationZ = this._cameraAnimationFrame.rotation.z * egret3d.Matrix3DUtils.RADIANS_TO_DEGREES;
            this._camera.position = this._cameraAnimationFrame.translation;
        };
        return CameraAnimationController;
    })();
    egret3d.CameraAnimationController = CameraAnimationController;
    /**
    * @private
    * @class egret3d.CameraAnimationFrame
    * @classdesc
    * 摄像机动画每帧数据
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CameraAnimationFrame = (function () {
        function CameraAnimationFrame() {
        }
        return CameraAnimationFrame;
    })();
    egret3d.CameraAnimationFrame = CameraAnimationFrame;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @class egret3d.CameraAnimationManager
    * @classdesc
    * 摄像机动画控制器管理
    * 管理所有摄像机动画
    * @version Egret 3.0
    * @platform Web,Native
    */
    var CameraAnimationManager = (function () {
        /**
        * @language zh_CN
        * 构建一个摄像机动画管理对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function CameraAnimationManager() {
            this._animation = {};
        }
        /**
        * @language zh_CN
        * 播放某个动画
        * 根据动画名字来播放，指定摄像机，并且控制动画是否循环播放
        * @param name 动画名
        * @param camera 相机
        * @param isLoop 是否循环
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraAnimationManager.prototype.play = function (name, camera, isLoop) {
            var _this = this;
            if (this._animation[name] != undefined) {
                this._animation[name].bindCamera(camera);
                this._animation[name].play(isLoop);
            }
            else {
                var loader = new egret3d.URLLoader();
                loader.onLoadComplete = function (loader) { return _this.onCallback(loader, name, camera, isLoop); };
                loader.load(name);
            }
        };
        /**
        * @language zh_CN
        * 更新所有的摄像机动画
        * @param time 当前时间
        * @param delay 每帧间隔时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        CameraAnimationManager.prototype.update = function (time, delay) {
            for (var key in this._animation) {
                this._animation[key].update(time, delay);
            }
        };
        CameraAnimationManager.prototype.onCallback = function (loader, name, camera, isLoop) {
            this._animation[name] = loader.data;
            this._animation[name].bindCamera(camera);
            this._animation[name].play(isLoop);
        };
        return CameraAnimationManager;
    })();
    egret3d.CameraAnimationManager = CameraAnimationManager;
})(egret3d || (egret3d = {}));
var DeviceUtil = (function () {
    function DeviceUtil() {
    }
    /**
     * @language zh_CN
     * 获取设备信息
     */
    DeviceUtil.getDeviceInfo = function () {
        return null;
    };
    Object.defineProperty(DeviceUtil, "getGPUMode", {
        /**
         * @
         */
        /**
         * @language zh_CN
         * 获取GPU类型
         * @returns {}
         */
        get: function () {
            if (true) {
                return egret3d.Egret3DDrive.OpenGLES_2_0;
            }
            return "";
        },
        enumerable: true,
        configurable: true
    });
    return DeviceUtil;
})();
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var egret3d;
(function (egret3d) {
    /**
     * Endian 类中包含一些值，它们表示用于表示多字节数字的字节顺序。
     * 字节顺序为 bigEndian（最高有效字节位于最前）或 littleEndian（最低有效字节位于最前）。
     * @class egret3d.Endian
     * @classdesc
     */
    var Endian = (function () {
        function Endian() {
        }
        /**
         * 表示多字节数字的最低有效字节位于字节序列的最前面。
         * 十六进制数字 0x12345678 包含 4 个字节（每个字节包含 2 个十六进制数字）。最高有效字节为 0x12。最低有效字节为 0x78。（对于等效的十进制数字 305419896，最高有效数字是 3，最低有效数字是 6）。
         * @constant {string} egret.Endian.LITTLE_ENDIAN
         */
        Endian.LITTLE_ENDIAN = "littleEndian";
        /**
         * 表示多字节数字的最高有效字节位于字节序列的最前面。
         * 十六进制数字 0x12345678 包含 4 个字节（每个字节包含 2 个十六进制数字）。最高有效字节为 0x12。最低有效字节为 0x78。（对于等效的十进制数字 305419896，最高有效数字是 3，最低有效数字是 6）。
         * @constant {string} egret.Endian.BIG_ENDIAN
         */
        Endian.BIG_ENDIAN = "bigEndian";
        return Endian;
    })();
    egret3d.Endian = Endian;
    /**
     * @class egret.ByteArray
     * @classdesc
     * ByteArray 类提供用于优化读取、写入以及处理二进制数据的方法和属性。
     * 注意：ByteArray 类适用于需要在字节层访问数据的高级 开发人员。
     */
    var ByteArray = (function () {
        /**
         * 创建一个 egret.ByteArray 对象以引用指定的 ArrayBuffer 对象
         * @param buffer {ArrayBuffer} 数据源
         */
        function ByteArray(buffer) {
            this.BUFFER_EXT_SIZE = 0; //Buffer expansion size
            this.EOF_byte = -1;
            this.EOF_code_point = -1;
            this._setArrayBuffer(buffer || new ArrayBuffer(this.BUFFER_EXT_SIZE));
            this.endian = Endian.BIG_ENDIAN;
        }
        ByteArray.prototype._setArrayBuffer = function (buffer) {
            this.write_position = buffer.byteLength;
            this.data = new DataView(buffer);
            this._position = 0;
        };
        Object.defineProperty(ByteArray.prototype, "buffer", {
            get: function () {
                return this.data.buffer;
            },
            /**
             * @private
             */
            set: function (value) {
                this.data = new DataView(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ByteArray.prototype, "dataView", {
            get: function () {
                return this.data;
            },
            /**
             * @private
             */
            set: function (value) {
                this.data = value;
                this.write_position = value.byteLength;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         */
        ByteArray.prototype.uncompress = function (type) {
            if (type === void 0) { type = "7z"; }
            //var decoder: nid.LZMA = new nid.LZMA();
            //var tmp: ArrayBuffer = decoder.decode(new Uint8Array(this.data.buffer)).buffer;
            //this.buffer = tmp; 
            //decoder = null;
        };
        Object.defineProperty(ByteArray.prototype, "bufferOffset", {
            /**
             * @private
             */
            get: function () {
                return this.data.byteOffset;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ByteArray.prototype, "position", {
            /**
             * 将文件指针的当前位置（以字节为单位）移动或返回到 ByteArray 对象中。下一次调用读取方法时将在此位置开始读取，或者下一次调用写入方法时将在此位置开始写入。
             * @member {number} egret.ByteArray#position
             */
            get: function () {
                return this._position;
            },
            set: function (value) {
                if (this._position < value) {
                    if (!this.validate(value - this._position)) {
                        return;
                    }
                }
                this._position = value;
                this.write_position = value > this.write_position ? value : this.write_position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ByteArray.prototype, "length", {
            /**
             * ByteArray 对象的长度（以字节为单位）。
             * 如果将长度设置为大于当前长度的值，则用零填充字节数组的右侧。
             * 如果将长度设置为小于当前长度的值，将会截断该字节数组。
             * @member {number} egret.ByteArray#length
             */
            get: function () {
                return this.write_position;
            },
            set: function (value) {
                this.validateBuffer(value, true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ByteArray.prototype, "bytesAvailable", {
            /**
             * 可从字节数组的当前位置到数组末尾读取的数据的字节数。
             * 每次访问 ByteArray 对象时，将 bytesAvailable 属性与读取方法结合使用，以确保读取有效的数据。
             * @member {number} egret.ByteArray#bytesAvailable
             */
            get: function () {
                return this.data.byteLength - this._position;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 清除字节数组的内容，并将 length 和 position 属性重置为 0。
         * @method egret.ByteArray#clear
         */
        ByteArray.prototype.clear = function () {
            //this._position = 0;
            this._setArrayBuffer(new ArrayBuffer(this.BUFFER_EXT_SIZE));
        };
        //public getArray():Uint8Array {
        //    if (this.array == null) {
        //        this.array = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
        //    }
        //    return this.array;
        //}
        /**
         * 从字节流中读取布尔值。读取单个字节，如果字节非零，则返回 true，否则返回 false
         * @returns 如果字节不为零，则返回 true，否则返回 false
         * @method egret.ByteArray#readBoolean
         */
        ByteArray.prototype.readBoolean = function () {
            if (!this.validate(ByteArray.SIZE_OF_BOOLEAN))
                return null;
            return this.data.getUint8(this.position++) != 0;
        };
        /**
         * 从字节流中读取带符号的字节
         * @returns 介于 -128 和 127 之间的整数
         * @method egret.ByteArray#readByte
         */
        ByteArray.prototype.readByte = function () {
            if (!this.validate(ByteArray.SIZE_OF_INT8))
                return null;
            return this.data.getInt8(this.position++);
        };
        /**
         * 从字节流中读取 length 参数指定的数据字节数。从 offset 指定的位置开始，将字节读入 bytes 参数指定的 ByteArray 对象中，并将字节写入目标 ByteArray 中
         * @param bytes 要将数据读入的 ByteArray 对象
         * @param offset bytes 中的偏移（位置），应从该位置写入读取的数据
         * @param length 要读取的字节数。默认值 0 导致读取所有可用的数据
         * @method egret.ByteArray#readBytes
         */
        ByteArray.prototype.readBytes = function (bytes, offset, length) {
            if (offset === void 0) { offset = 0; }
            if (length === void 0) { length = 0; }
            if (length == 0) {
                length = this.bytesAvailable;
            }
            else if (!this.validate(length)) {
                return null;
            }
            if (bytes) {
                bytes.validateBuffer(length);
            }
            else {
                bytes = new ByteArray(new ArrayBuffer(length));
            }
            //This method is expensive
            for (var i = 0; i < length; i++) {
                bytes.data.setUint8(i + offset, this.data.getUint8(this.position++));
            }
        };
        //public get leftBytes():ArrayBuffer {
        //    var begin = this.data.byteOffset + this.position;
        //    var end = this.data.byteLength;
        //    var result = new ArrayBuffer(end - begin);
        //    var resultBytes = new Uint8Array(result);
        //    var sourceBytes = new Uint8Array(this.data.buffer, begin, end - begin);
        //    resultBytes.set(sourceBytes);
        //    return resultBytes.buffer;
        //}
        /**
         * 从字节流中读取一个 IEEE 754 双精度（64 位）浮点数
         * @returns 双精度（64 位）浮点数
         * @method egret.ByteArray#readDouble
         */
        ByteArray.prototype.readDouble = function () {
            if (!this.validate(ByteArray.SIZE_OF_FLOAT64))
                return null;
            var value = this.data.getFloat64(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_FLOAT64;
            return value;
        };
        /**
         * 从字节流中读取一个 IEEE 754 单精度（32 位）浮点数
         * @returns 单精度（32 位）浮点数
         * @method egret.ByteArray#readFloat
         */
        ByteArray.prototype.readFloat = function () {
            if (!this.validate(ByteArray.SIZE_OF_FLOAT32))
                return null;
            var value = this.data.getFloat32(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_FLOAT32;
            return value;
        };
        /**
         * 从字节流中读取一个带符号的 32 位整数
         * @returns 介于 -2147483648 和 2147483647 之间的 32 位带符号整数
         * @method egret.ByteArray#readFloat
         */
        ByteArray.prototype.readInt = function () {
            if (!this.validate(ByteArray.SIZE_OF_INT32))
                return null;
            var value = this.data.getInt32(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_INT32;
            return value;
        };
        //        public readInt64():Int64{
        //            if (!this.validate(ByteArray.SIZE_OF_UINT32)) return null;
        //
        //            var low = this.data.getInt32(this.position, this.endian == Endian.LITTLE_ENDIAN);
        //            this.position += ByteArray.SIZE_OF_INT32;
        //            var high = this.data.getInt32(this.position, this.endian == Endian.LITTLE_ENDIAN);
        //            this.position += ByteArray.SIZE_OF_INT32;
        //            return new Int64(low,high);
        //        }
        /**
         * 使用指定的字符集从字节流中读取指定长度的多字节字符串
         * @param length 要从字节流中读取的字节数
         * @param charSet 表示用于解释字节的字符集的字符串。可能的字符集字符串包括 "shift-jis"、"cn-gb"、"iso-8859-1"”等
         * @returns UTF-8 编码的字符串
         * @method egret.ByteArray#readMultiByte
         */
        //public readMultiByte(length:number, charSet?:string):string {
        //    if (!this.validate(length)) return null;
        //
        //    return "";
        //}
        /**
         * 从字节流中读取一个带符号的 16 位整数
         * @returns 介于 -32768 和 32767 之间的 16 位带符号整数
         * @method egret.ByteArray#readShort
         */
        ByteArray.prototype.readShort = function () {
            if (!this.validate(ByteArray.SIZE_OF_INT16))
                return null;
            var value = this.data.getInt16(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_INT16;
            return value;
        };
        /**
         * 从字节流中读取无符号的字节
         * @returns 介于 0 和 255 之间的 32 位无符号整数
         * @method egret.ByteArray#readUnsignedByte
         */
        ByteArray.prototype.readUnsignedByte = function () {
            if (!this.validate(ByteArray.SIZE_OF_UINT8))
                return null;
            return this.data.getUint8(this.position++);
        };
        /**
         * 从字节流中读取一个无符号的 32 位整数
         * @returns 介于 0 和 4294967295 之间的 32 位无符号整数
         * @method egret.ByteArray#readUnsignedInt
         */
        ByteArray.prototype.readUnsignedInt = function () {
            if (!this.validate(ByteArray.SIZE_OF_UINT32))
                return null;
            var value = this.data.getUint32(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT32;
            return value;
        };
        //public readVariableSizedUnsignedInt():number {
        //    var i:number;
        //    var c:number = this.data.getUint8(this.position++);
        //    if (c != 0xFF) {
        //        i = c << 8;
        //        c = this.data.getUint8(this.position++);
        //        i |= c;
        //    }
        //    else {
        //        c = this.data.getUint8(this.position++);
        //        i = c << 16;
        //        c = this.data.getUint8(this.position++);
        //        i |= c << 8;
        //        c = this.data.getUint8(this.position++);
        //        i |= c;
        //    }
        //    return i;
        //}
        //		public readUnsignedInt64():UInt64{
        //            if (!this.validate(ByteArray.SIZE_OF_UINT32)) return null;
        //
        //            var low = this.data.getUint32(this.position, this.endian == Endian.LITTLE_ENDIAN);
        //            this.position += ByteArray.SIZE_OF_UINT32;
        //            var high = this.data.getUint32(this.position, this.endian == Endian.LITTLE_ENDIAN);
        //            this.position += ByteArray.SIZE_OF_UINT32;
        //			return new UInt64(low,high);
        //        }
        /**
         * 从字节流中读取一个无符号的 16 位整数
         * @returns 介于 0 和 65535 之间的 16 位无符号整数
         * @method egret.ByteArray#readUnsignedShort
         */
        ByteArray.prototype.readUnsignedShort = function () {
            if (!this.validate(ByteArray.SIZE_OF_UINT16))
                return null;
            var value = this.data.getUint16(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT16;
            return value;
        };
        /**
         * 从字节流中读取一个 UTF-8 字符串。假定字符串的前缀是无符号的短整型（以字节表示长度）
         * @returns UTF-8 编码的字符串
         * @method egret.ByteArray#readUTF
         */
        ByteArray.prototype.readUTF = function () {
            if (!this.validate(ByteArray.SIZE_OF_UINT16))
                return null;
            var length = this.data.getUint16(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT16;
            if (length > 0) {
                return this.readUTFBytes(length);
            }
            else {
                return "";
            }
        };
        /**
         * 从字节流中读取一个由 length 参数指定的 UTF-8 字节序列，并返回一个字符串
         * @param length 指明 UTF-8 字节长度的无符号短整型数
         * @returns 由指定长度的 UTF-8 字节组成的字符串
         * @method egret.ByteArray#readUTFBytes
         */
        ByteArray.prototype.readUTFBytes = function (length) {
            if (!this.validate(length))
                return null;
            var bytes = new Uint8Array(this.buffer, this.bufferOffset + this.position, length);
            this.position += length;
            /*var bytes: Uint8Array = new Uint8Array(new ArrayBuffer(length));
             for (var i = 0; i < length; i++) {
             bytes[i] = this.data.getUint8(this.position++);
             }*/
            return this.decodeUTF8(bytes);
        };
        //public readStandardString(length:number):string {
        //    if (!this.validate(length)) return null;
        //
        //    var str:string = "";
        //
        //    for (var i = 0; i < length; i++) {
        //        str += String.fromCharCode(this.data.getUint8(this.position++));
        //    }
        //    return str;
        //}
        //public readStringTillNull(keepEvenByte:boolean = true):string {
        //
        //    var str:string = "";
        //    var num:number = 0;
        //    while (this.bytesAvailable > 0) {
        //        var b:number = this.data.getUint8(this.position++);
        //        num++;
        //        if (b != 0) {
        //            str += String.fromCharCode(b);
        //        } else {
        //            if (keepEvenByte && num % 2 != 0) {
        //                this.position++;
        //            }
        //            break;
        //        }
        //    }
        //    return str;
        //}
        /**
         * 写入布尔值。根据 value 参数写入单个字节。如果为 true，则写入 1，如果为 false，则写入 0
         * @param value 确定写入哪个字节的布尔值。如果该参数为 true，则该方法写入 1；如果该参数为 false，则该方法写入 0
         * @method egret.ByteArray#writeBoolean
         */
        ByteArray.prototype.writeBoolean = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_BOOLEAN);
            this.data.setUint8(this.position++, value ? 1 : 0);
        };
        /**
         * 在字节流中写入一个字节
         * 使用参数的低 8 位。忽略高 24 位
         * @param value 一个 32 位整数。低 8 位将被写入字节流
         * @method egret.ByteArray#writeByte
         */
        ByteArray.prototype.writeByte = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_INT8);
            this.data.setInt8(this.position++, value);
        };
        //public writeUnsignedByte(value:number):void {
        //    this.validateBuffer(ByteArray.SIZE_OF_UINT8);
        //
        //    this.data.setUint8(this.position++, value);
        //}
        /**
         * 将指定字节数组 bytes（起始偏移量为 offset，从零开始的索引）中包含 length 个字节的字节序列写入字节流
         * 如果省略 length 参数，则使用默认长度 0；该方法将从 offset 开始写入整个缓冲区。如果还省略了 offset 参数，则写入整个缓冲区
         * 如果 offset 或 length 超出范围，它们将被锁定到 bytes 数组的开头和结尾
         * @param bytes ByteArray 对象
         * @param offset 从 0 开始的索引，表示在数组中开始写入的位置
         * @param length 一个无符号整数，表示在缓冲区中的写入范围
         * @method egret.ByteArray#writeBytes
         */
        ByteArray.prototype.writeBytes = function (bytes, offset, length) {
            if (offset === void 0) { offset = 0; }
            if (length === void 0) { length = 0; }
            var writeLength;
            if (offset < 0) {
                return;
            }
            if (length < 0) {
                return;
            }
            else if (length == 0) {
                writeLength = bytes.length - offset;
            }
            else {
                writeLength = Math.min(bytes.length - offset, length);
            }
            if (writeLength > 0) {
                this.validateBuffer(writeLength);
                var tmp_data = new DataView(bytes.buffer);
                for (var i = offset; i < writeLength + offset; i++) {
                    this.data.setUint8(this.position++, tmp_data.getUint8(i));
                }
            }
        };
        /**
         * 在字节流中写入一个 IEEE 754 双精度（64 位）浮点数
         * @param value 双精度（64 位）浮点数
         * @method egret.ByteArray#writeDouble
         */
        ByteArray.prototype.writeDouble = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_FLOAT64);
            this.data.setFloat64(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_FLOAT64;
        };
        /**
         * 在字节流中写入一个 IEEE 754 单精度（32 位）浮点数
         * @param value 单精度（32 位）浮点数
         * @method egret.ByteArray#writeFloat
         */
        ByteArray.prototype.writeFloat = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_FLOAT32);
            this.data.setFloat32(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_FLOAT32;
        };
        /**
         * 在字节流中写入一个带符号的 32 位整数
         * @param value 要写入字节流的整数
         * @method egret.ByteArray#writeInt
         */
        ByteArray.prototype.writeInt = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_INT32);
            this.data.setInt32(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_INT32;
        };
        /**
         * 使用指定的字符集将多字节字符串写入字节流
         * @param value 要写入的字符串值
         * @param charSet 表示要使用的字符集的字符串。可能的字符集字符串包括 "shift-jis"、"cn-gb"、"iso-8859-1"”等
         * @method egret.ByteArray#writeMultiByte
         */
        //public writeMultiByte(value:string, charSet:string):void {
        //
        //}
        /**
         * 在字节流中写入一个 16 位整数。使用参数的低 16 位。忽略高 16 位
         * @param value 32 位整数，该整数的低 16 位将被写入字节流
         * @method egret.ByteArray#writeShort
         */
        ByteArray.prototype.writeShort = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_INT16);
            this.data.setInt16(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_INT16;
        };
        //public writeUnsignedShort(value:number):void {
        //    this.validateBuffer(ByteArray.SIZE_OF_UINT16);
        //
        //    this.data.setUint16(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
        //    this.position += ByteArray.SIZE_OF_UINT16;
        //}
        /**
         * 在字节流中写入一个无符号的 32 位整数
         * @param value 要写入字节流的无符号整数
         * @method egret.ByteArray#writeUnsignedInt
         */
        ByteArray.prototype.writeUnsignedInt = function (value) {
            this.validateBuffer(ByteArray.SIZE_OF_UINT32);
            this.data.setUint32(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT32;
        };
        /**
         * 将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节
         * @param value 要写入的字符串值
         * @method egret.ByteArray#writeUTF
         */
        ByteArray.prototype.writeUTF = function (value) {
            var utf8bytes = this.encodeUTF8(value);
            var length = utf8bytes.length;
            this.validateBuffer(ByteArray.SIZE_OF_UINT16 + length);
            this.data.setUint16(this.position, length, this.endian === Endian.LITTLE_ENDIAN);
            this.position += ByteArray.SIZE_OF_UINT16;
            this._writeUint8Array(utf8bytes, false);
        };
        /**
         * 将 UTF-8 字符串写入字节流。类似于 writeUTF() 方法，但 writeUTFBytes() 不使用 16 位长度的词为字符串添加前缀
         * @param value 要写入的字符串值
         * @method egret.ByteArray#writeUTFBytes
         */
        ByteArray.prototype.writeUTFBytes = function (value) {
            this._writeUint8Array(this.encodeUTF8(value));
        };
        ByteArray.prototype.toString = function () {
            return "[ByteArray] length:" + this.length + ", bytesAvailable:" + this.bytesAvailable;
        };
        /**
         * 将 Uint8Array 写入字节流
         * @param bytes 要写入的Uint8Array
         * @param validateBuffer
         */
        ByteArray.prototype._writeUint8Array = function (bytes, validateBuffer) {
            if (validateBuffer === void 0) { validateBuffer = true; }
            if (validateBuffer) {
                this.validateBuffer(this.position + bytes.length);
            }
            for (var i = 0; i < bytes.length; i++) {
                this.data.setUint8(this.position++, bytes[i]);
            }
        };
        /**
         * @private
         */
        ByteArray.prototype.validate = function (len) {
            //len += this.data.byteOffset;
            if (this.data.byteLength > 0 && this._position + len <= this.data.byteLength) {
                return true;
            }
            else {
            }
        };
        /*********************/
        /*  PRIVATE METHODS   */
        /*********************/
        ByteArray.prototype.validateBuffer = function (len, needReplace) {
            if (needReplace === void 0) { needReplace = false; }
            this.write_position = len > this.write_position ? len : this.write_position;
            len += this._position;
            if (this.data.byteLength < len || needReplace) {
                var tmp = new Uint8Array(new ArrayBuffer(len + this.BUFFER_EXT_SIZE));
                var length = Math.min(this.data.buffer.byteLength, len + this.BUFFER_EXT_SIZE);
                tmp.set(new Uint8Array(this.data.buffer, 0, length));
                this.buffer = tmp.buffer;
            }
        };
        /**
         * UTF-8 Encoding/Decoding
         */
        ByteArray.prototype.encodeUTF8 = function (str) {
            var pos = 0;
            var codePoints = this.stringToCodePoints(str);
            var outputBytes = [];
            while (codePoints.length > pos) {
                var code_point = codePoints[pos++];
                if (this.inRange(code_point, 0xD800, 0xDFFF)) {
                    this.encoderError(code_point);
                }
                else if (this.inRange(code_point, 0x0000, 0x007f)) {
                    outputBytes.push(code_point);
                }
                else {
                    var count, offset;
                    if (this.inRange(code_point, 0x0080, 0x07FF)) {
                        count = 1;
                        offset = 0xC0;
                    }
                    else if (this.inRange(code_point, 0x0800, 0xFFFF)) {
                        count = 2;
                        offset = 0xE0;
                    }
                    else if (this.inRange(code_point, 0x10000, 0x10FFFF)) {
                        count = 3;
                        offset = 0xF0;
                    }
                    outputBytes.push(this.div(code_point, Math.pow(64, count)) + offset);
                    while (count > 0) {
                        var temp = this.div(code_point, Math.pow(64, count - 1));
                        outputBytes.push(0x80 + (temp % 64));
                        count -= 1;
                    }
                }
            }
            return new Uint8Array(outputBytes);
        };
        ByteArray.prototype.decodeUTF8 = function (data) {
            var fatal = false;
            var pos = 0;
            var result = "";
            var code_point;
            var utf8_code_point = 0;
            var utf8_bytes_needed = 0;
            var utf8_bytes_seen = 0;
            var utf8_lower_boundary = 0;
            while (data.length > pos) {
                var _byte = data[pos++];
                if (_byte === this.EOF_byte) {
                    if (utf8_bytes_needed !== 0) {
                        code_point = this.decoderError(fatal);
                    }
                    else {
                        code_point = this.EOF_code_point;
                    }
                }
                else {
                    if (utf8_bytes_needed === 0) {
                        if (this.inRange(_byte, 0x00, 0x7F)) {
                            code_point = _byte;
                        }
                        else {
                            if (this.inRange(_byte, 0xC2, 0xDF)) {
                                utf8_bytes_needed = 1;
                                utf8_lower_boundary = 0x80;
                                utf8_code_point = _byte - 0xC0;
                            }
                            else if (this.inRange(_byte, 0xE0, 0xEF)) {
                                utf8_bytes_needed = 2;
                                utf8_lower_boundary = 0x800;
                                utf8_code_point = _byte - 0xE0;
                            }
                            else if (this.inRange(_byte, 0xF0, 0xF4)) {
                                utf8_bytes_needed = 3;
                                utf8_lower_boundary = 0x10000;
                                utf8_code_point = _byte - 0xF0;
                            }
                            else {
                                this.decoderError(fatal);
                            }
                            utf8_code_point = utf8_code_point * Math.pow(64, utf8_bytes_needed);
                            code_point = null;
                        }
                    }
                    else if (!this.inRange(_byte, 0x80, 0xBF)) {
                        utf8_code_point = 0;
                        utf8_bytes_needed = 0;
                        utf8_bytes_seen = 0;
                        utf8_lower_boundary = 0;
                        pos--;
                        code_point = this.decoderError(fatal, _byte);
                    }
                    else {
                        utf8_bytes_seen += 1;
                        utf8_code_point = utf8_code_point + (_byte - 0x80) * Math.pow(64, utf8_bytes_needed - utf8_bytes_seen);
                        if (utf8_bytes_seen !== utf8_bytes_needed) {
                            code_point = null;
                        }
                        else {
                            var cp = utf8_code_point;
                            var lower_boundary = utf8_lower_boundary;
                            utf8_code_point = 0;
                            utf8_bytes_needed = 0;
                            utf8_bytes_seen = 0;
                            utf8_lower_boundary = 0;
                            if (this.inRange(cp, lower_boundary, 0x10FFFF) && !this.inRange(cp, 0xD800, 0xDFFF)) {
                                code_point = cp;
                            }
                            else {
                                code_point = this.decoderError(fatal, _byte);
                            }
                        }
                    }
                }
                //Decode string
                if (code_point !== null && code_point !== this.EOF_code_point) {
                    if (code_point <= 0xFFFF) {
                        if (code_point > 0)
                            result += String.fromCharCode(code_point);
                    }
                    else {
                        code_point -= 0x10000;
                        result += String.fromCharCode(0xD800 + ((code_point >> 10) & 0x3ff));
                        result += String.fromCharCode(0xDC00 + (code_point & 0x3ff));
                    }
                }
            }
            return result;
        };
        ByteArray.prototype.encoderError = function (code_point) {
            //$error(1026, code_point);
        };
        ByteArray.prototype.decoderError = function (fatal, opt_code_point) {
            if (fatal) {
            }
            return opt_code_point || 0xFFFD;
        };
        ByteArray.prototype.inRange = function (a, min, max) {
            return min <= a && a <= max;
        };
        ByteArray.prototype.div = function (n, d) {
            return Math.floor(n / d);
        };
        ByteArray.prototype.stringToCodePoints = function (string) {
            /** @type {Array.<number>} */
            var cps = [];
            // Based on http://www.w3.org/TR/WebIDL/#idl-DOMString
            var i = 0, n = string.length;
            while (i < string.length) {
                var c = string.charCodeAt(i);
                if (!this.inRange(c, 0xD800, 0xDFFF)) {
                    cps.push(c);
                }
                else if (this.inRange(c, 0xDC00, 0xDFFF)) {
                    cps.push(0xFFFD);
                }
                else {
                    if (i === n - 1) {
                        cps.push(0xFFFD);
                    }
                    else {
                        var d = string.charCodeAt(i + 1);
                        if (this.inRange(d, 0xDC00, 0xDFFF)) {
                            var a = c & 0x3FF;
                            var b = d & 0x3FF;
                            i += 1;
                            cps.push(0x10000 + (a << 10) + b);
                        }
                        else {
                            cps.push(0xFFFD);
                        }
                    }
                }
                i += 1;
            }
            return cps;
        };
        ByteArray.SIZE_OF_BOOLEAN = 1;
        ByteArray.SIZE_OF_INT8 = 1;
        ByteArray.SIZE_OF_INT16 = 2;
        ByteArray.SIZE_OF_INT32 = 4;
        ByteArray.SIZE_OF_UINT8 = 1;
        ByteArray.SIZE_OF_UINT16 = 2;
        ByteArray.SIZE_OF_UINT32 = 4;
        ByteArray.SIZE_OF_FLOAT32 = 4;
        ByteArray.SIZE_OF_FLOAT64 = 8;
        return ByteArray;
    })();
    egret3d.ByteArray = ByteArray;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @class egret3d.StringUtil
     * @classdesc
     * 字符串处理工具类
     */
    var StringUtil = (function () {
        function StringUtil() {
        }
        /**
         * @language zh_CN
         * 解析文件内容(按行解析)
         * @param file
         * @returns 行列表
         */
        StringUtil.parseContent = function (file) {
            var shaderList = new Array();
            var node = "";
            var endChar = ";";
            var index = -1;
            for (var i = 0; i < file.length; ++i) {
                if (file.charAt(i) == "{") {
                    index = node.indexOf("=");
                    if (index < 0) {
                        endChar = "}";
                    }
                }
                if (node == "") {
                    if (file.charAt(i) == " " || file.charAt(i) == "    ") {
                        continue;
                    }
                }
                node += file.charAt(i);
                if (endChar == file.charAt(i)) {
                    if (endChar == "}") {
                        var s_num = 0;
                        var e_num = 0;
                        for (var j = 0; j < node.length; ++j) {
                            if (node.charAt(j) == "{") {
                                s_num++;
                            }
                            else if (node.charAt(j) == "}") {
                                e_num++;
                            }
                        }
                        if (s_num != e_num) {
                            continue;
                        }
                        if (node.indexOf("struct") >= 0) {
                            endChar = ";";
                            continue;
                        }
                    }
                    if (node.length > 0) {
                        shaderList.push(node);
                    }
                    node = "";
                    endChar = ";";
                }
            }
            return shaderList;
        };
        /**
         * @language zh_CN
         * 解析一行的内容 有多少个成员
         * @param line 源内容
         * @returns 成员列表
         */
        StringUtil.parseLines = function (line) {
            var list = new Array();
            var value = "";
            for (var i = 0; i < line.length; ++i) {
                if (line.charAt(i) != " " && line.charAt(i) != "\t" && line.charAt(i) != "," &&
                    line.charAt(i) != "\r" && line.charAt(i) != "\n") {
                    if (line.charAt(i) == ";") {
                        if (value.length > 0) {
                            list.push(value);
                            value = "";
                        }
                        list.push(";");
                        break;
                    }
                    else if (line.charAt(i) == "=") {
                        if (value.length > 0) {
                            list.push(value);
                            value = "";
                        }
                        list.push("=");
                        continue;
                    }
                    value += line.charAt(i);
                    if (i == line.length - 1 && line != "") {
                        list.push(value);
                        value = "";
                    }
                }
                else {
                    if (value != "") {
                        list.push(value);
                        value = "";
                    }
                }
            }
            return list;
        };
        /**
         * @language zh_CN
         * 是否存在此字符串
         * @param fields 被检测的列表
         * @param str 比较字符串
         * @returns 成功返回true
         */
        StringUtil.hasString = function (fields, str) {
            for (var i = 0; i < fields.length; ++i) {
                if (fields[i] == str) {
                    return true;
                }
            }
            return false;
        };
        /**
         * @language zh_CN
         * 得到值的内容
         * @param fields 成员列表
         * @returns 值
         */
        StringUtil.getVarName = function (fields) {
            var equal = this.hasString(fields, "=");
            if (equal) {
                if (fields.length - 4 >= 0 && fields.length - 4 < fields.length) {
                    return fields[fields.length - 4];
                }
                return "";
            }
            if (fields.length - 2 >= 0 && fields.length - 2 < fields.length) {
                return fields[fields.length - 2];
            }
            return "";
        };
        /**
         * @language zh_CN
         * 返回变量的值
         * @param fields 变量数据列表
         * @returns 变量的值
         */
        StringUtil.getVarValue = function (fields) {
            var equal = this.hasString(fields, "=");
            if (equal) {
                if (fields.length - 2 >= 0 && fields.length - 2 < fields.length) {
                    return fields[fields.length - 2];
                }
            }
            return "";
        };
        /**
         * @language zh_CN
         * 返回变量类型
         * @param fields 变量数据列表
         * @returns 变量类型
         */
        StringUtil.getVarType = function (fields) {
            var equal = this.hasString(fields, "=");
            if (equal) {
                if (fields.length - 5 >= 0 && fields.length - 5 < fields.length) {
                    return fields[fields.length - 5];
                }
                return "";
            }
            if (fields.length - 3 >= 0 && fields.length - 3 < fields.length) {
                return fields[fields.length - 3];
            }
            return "";
        };
        /**
         * @language zh_CN
         * 返回变量属性
         * @param fields 变量数据列表
         * @returns 变量属性
         */
        StringUtil.getVarKey = function (fields) {
            var equal = this.hasString(fields, "=");
            if (equal) {
                if (fields.length > 5) {
                    return fields[0];
                }
                else {
                    return "";
                }
            }
            if (fields.length > 3) {
                return fields[0];
            }
            return "";
        };
        /**
         * @language zh_CN
         * 筛选文件中的指定字符去掉
         * @param file xxx
         * @returns 筛选后的字符
         */
        StringUtil.processShaderFile = function (file) {
            var filterChar = ["\n", "\r"];
            filterChar = [];
            var src = file;
            var dest = src;
            while (true) {
                var pos = src.indexOf("//");
                if (pos < 0) {
                    break;
                }
                var end = src.indexOf("\r\n", pos);
                if (end == -1) {
                    end = src.indexOf("\n", pos);
                }
                var slice_s = src.slice(pos, end);
                src = src.replace(slice_s, "");
                if (src == dest) {
                    break;
                }
                dest = src;
            }
            for (var i = 0; i < filterChar.length; ++i) {
                while (true) {
                    dest = src.replace(filterChar[i], "");
                    if (src == dest) {
                        break;
                    }
                    src = dest;
                }
            }
            return src;
        };
        /**
         * @language zh_CN
         * 解析字符颜色值
         * @param color
         * @returns
         */
        StringUtil.colorRgb = function (color) {
            var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
            var sColor = color.toLowerCase();
            if (sColor && reg.test(sColor)) {
                if (sColor.length === 4) {
                    var sColorNew = "#";
                    for (var i = 1; i < 4; i += 1) {
                        sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
                    }
                    sColor = sColorNew;
                }
                //处理六位的颜色值  
                var sColorChange = [];
                for (var i = 1; i < 7; i += 2) {
                    sColorChange.push(parseInt("0x" + sColor.slice(i, i + 2)));
                }
                return "RGB(" + sColorChange.join(",") + ")";
            }
            else {
                return sColor;
            }
        };
        return StringUtil;
    })();
    egret3d.StringUtil = StringUtil;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.Debug
    * @classdesc
    * 调试面板
    */
    var Debug = (function () {
        /**
         * @language zh_CN
         * 构造
         */
        function Debug() {
            this.isDebug = false;
            this._console = document.createElement('console');
            document.body.appendChild(this._console);
            this._console.style.color = "red";
            this._console.style.position = "absolute";
            this._console.style.top = "10px";
            this._console.style.left = "10px";
        }
        /**
         * @language zh_CN
         * 输出调试信息
         * @param parameters
         */
        Debug.prototype.trace = function () {
            var parameters = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                parameters[_i - 0] = arguments[_i];
            }
            if (this.isDebug) {
                this.reset();
                var len = parameters.length;
                for (var i = 0; i < len; i++) {
                    this._console.innerHTML += parameters[i] + "</br>";
                }
            }
        };
        /**
         * @language zh_CN
         * 重置显示数据
         */
        Debug.prototype.reset = function () {
            this._console.innerHTML = "";
        };
        Object.defineProperty(Debug, "instance", {
            /**
             * @language zh_CN
             * 取到当前Debug单例对象
             */
            get: function () {
                if (this._instance == null) {
                    this._instance = new Debug();
                }
                return this._instance;
            },
            enumerable: true,
            configurable: true
        });
        Debug._instance = null;
        return Debug;
    })();
    egret3d.Debug = Debug;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @class egret3d.WireframeBase
     * @classdesc
     * 线框渲染基类，可以控制顶点的颜色，顶点的大小
     * 可控制线的颜色，可选择是否渲染点或者渲染线
     * @version Egret 3.0
     * @platform Web,Native
     */
    var WireframeBase = (function () {
        /**
        * @private
        * @language zh_CN
        * constructor
        * @param vs vs文件名
        * @param fs fs文件名
        * @version Egret 3.0
        * @platform Web,Native
        */
        function WireframeBase(vs, fs) {
            if (vs === void 0) { vs = "wireframe_vertex"; }
            if (fs === void 0) { fs = "wireframe_fragment"; }
            this.vertexData = [
                0.5, 0.0, 0.0,
                -0.5, 0.0, 0.0
            ];
            this.vertexCount = 2;
            this.vertexLength = 3;
            this.vertexBytes = 12;
            /**
            * @language zh_CN
            * 是否以线渲染
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.isDrawLine = true;
            /**
            * @language zh_CN
            * 是否以点渲染
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.isDrawPoint = true;
            /**
            * @language zh_CN
            * 渲染顶点的大小
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.pointSize = 1.0;
            /**
            * @language zh_CN
            * 渲染顶点的颜色
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.pointColor = new egret3d.Vector3D(1, 1, 1, 1);
            /**
            * @language zh_CN
            * 渲染线的颜色
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.lineColor = new egret3d.Vector3D(1, 1, 1, 1);
            /**
            * @language zh_CN
            * 当前渲染对象的变换矩阵
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.modleMatrix = new egret3d.Matrix4_4();
            this.usage = new egret3d.MethodUsageData();
            this.vsShader = new egret3d.GLSL.ShaderBase(null, this.usage);
            this.fsShader = new egret3d.GLSL.ShaderBase(null, this.usage);
            this.setShader(vs, fs);
            //this.modleMatrix.identity();
        }
        /**
        * @language zh_CN
        * 根据geometry创建一个线框
        * @param geometry 模型数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        WireframeBase.prototype.createFromGeometry = function (geometry) {
        };
        /**
        * @language zh_CN
        * 根据两个顶点创建一条线段
        * @param first 线段的起始点
        * @param second 线段的结束点
        * @version Egret 3.0
        * @platform Web,Native
        */
        WireframeBase.prototype.createFromData = function (first, second) {
        };
        /**
        * @language zh_CN
        * 以下标来设置某个顶点的坐标
        * @param index 顶点下标
        * @param pos 设置顶点的坐标
        * @version Egret 3.0
        * @platform Web,Native
        */
        WireframeBase.prototype.setVertexPos = function (index, pos) {
            var i = index * this.vertexLength;
            if (i + 2 >= this.vertexData.length) {
                return;
            }
            this.vertexData[i] = pos.x;
            this.vertexData[i + 1] = pos.y;
            this.vertexData[i + 2] = pos.z;
        };
        /**
        * @language zh_CN
        * 设置渲染用的shader文件名字
        * @param vsName vs文件名
        * @param fsName fs文件名
        * @version Egret 3.0
        * @platform Web,Native
        */
        WireframeBase.prototype.setShader = function (vsName, fsName) {
            this.vsShader.addShader(vsName);
            this.fsShader.addShader(fsName);
            this.vsShaderSource = this.vsShader.getShaderSource();
            this.fsShaderSource = this.fsShader.getShaderSource();
        };
        /**
        * @language zh_CN
        * 提交数据到GPU渲染
        * @param context3D 设备上下文
        * @param camera 渲染时的相机
        * @version Egret 3.0
        * @platform Web,Native
        */
        WireframeBase.prototype.draw = function (context3D, camera) {
            //if (this.transformChange)
            //    this.notifyUpdate();
            context3D.gl.clear(egret3d.Egret3DDrive.DEPTH_BUFFER_BIT);
            if (!this.usage.program3D)
                this.rebuild(context3D);
            context3D.enbable(context3D.gl.DEPTH_TEST);
            context3D.setBlendFactors(egret3d.Egret3DDrive.ONE, egret3d.Egret3DDrive.ZERO);
            context3D.setProgram(this.usage.program3D);
            context3D.bindVertexBuffer(this.vertexBuffer3D);
            context3D.vertexAttribPointer(this.usage.program3D, this.usage.attribute_position.uniformIndex, 3, egret3d.Egret3DDrive.FLOAT, false, this.vertexBytes, 0);
            context3D.uniformMatrix4fv(this.usage.uniform_ModelMatrix.uniformIndex, false, this.modleMatrix.rawData);
            context3D.uniformMatrix4fv(this.usage.uniform_ProjectionMatrix.uniformIndex, false, camera.viewProjectionMatrix.rawData);
            if (this.isDrawLine) {
                context3D.uniform4fv(this.uniform_color, [this.lineColor.x, this.lineColor.y, this.lineColor.z, this.lineColor.w]);
                context3D.drawArrays(egret3d.DrawMode.LINES, 0, this.vertexCount);
            }
            if (this.isDrawPoint) {
                context3D.uniform4fv(this.uniform_color, [this.pointColor.x, this.pointColor.y, this.pointColor.z, this.pointColor.w]);
                context3D.uniform1f(this.uniform_pointSize, this.pointSize);
                context3D.drawArrays(egret3d.DrawMode.POINTS, 0, this.vertexCount);
            }
        };
        WireframeBase.prototype.rebuild = function (context3D) {
            var vertexShader = context3D.creatVertexShader(this.vsShaderSource);
            var fragmentShader = context3D.creatFragmentShader(this.fsShaderSource);
            this.usage.program3D = context3D.creatProgram(vertexShader, fragmentShader);
            if (this.usage.program3D) {
                context3D.setProgram(this.usage.program3D);
            }
            if (!this.vertexBuffer3D) {
                this.vertexBuffer3D = context3D.creatVertexBuffer(this.vertexData);
            }
            this.usage.attribute_position.uniformIndex = context3D.getShaderAttribLocation(this.usage.program3D, "attribute_position");
            this.usage.uniform_ModelMatrix.uniformIndex = context3D.getUniformLocation(this.usage.program3D, "uniform_ModelMatrix");
            this.usage.uniform_ProjectionMatrix.uniformIndex = context3D.getUniformLocation(this.usage.program3D, "uniform_ProjectionMatrix");
            this.uniform_color = context3D.getUniformLocation(this.usage.program3D, "uniform_color");
            this.uniform_pointSize = context3D.getUniformLocation(this.usage.program3D, "uniform_pointSize");
        };
        return WireframeBase;
    })();
    egret3d.WireframeBase = WireframeBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @class egret3d.WireframeLine
     * @classdesc
     *
     * 线渲染把两个顶点之间以线渲染的形式渲染出来
     * @includeExample Wireframe/WireframeLine.ts
     * @version Egret 3.0
     * @platform Web,Native
     *
     */
    var WireframeLine = (function (_super) {
        __extends(WireframeLine, _super);
        /**
        * @language zh_CN
        * 构建一个线框渲染对象
        * @param vs vs文件名
        * @param fs fs文件名
        * @version Egret 3.0
        * @platform Web,Native
        */
        function WireframeLine(vs, fs) {
            if (vs === void 0) { vs = "wireframe_vertex"; }
            if (fs === void 0) { fs = "wireframe_fragment"; }
            _super.call(this, vs, fs);
        }
        /**
        * @language zh_CN
        * 根据两个顶点创建一条线段
        * @param first 线段的起始点
        * @param second 线段的结束点
        * @version Egret 3.0
        * @platform Web,Native
        */
        WireframeLine.prototype.createFromData = function (first, second) {
            this.vertexData = [];
            this.vertexCount = 0;
            this.vertexData.push(first.x, first.y, first.z, second.x, second.y, second.z);
            this.vertexCount = 2;
        };
        return WireframeLine;
    })(egret3d.WireframeBase);
    egret3d.WireframeLine = WireframeLine;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @class egret3d.WriframeMesh
     * @classdesc
     *
     * 模型线框网格,以线框形式渲染模型
     * @includeExample Wireframe/WireframeLine.ts
     * @version Egret 3.0
     * @platform Web,Native
     */
    var WireframeMesh = (function (_super) {
        __extends(WireframeMesh, _super);
        /**
        * @language zh_CN
        * 构建一个线框渲染Mesh对象
        * @version Egret 3.0
        * @platform Web,Native
        */
        function WireframeMesh(vs, fs) {
            if (vs === void 0) { vs = "wireframe_vertex"; }
            if (fs === void 0) { fs = "wireframe_fragment"; }
            _super.call(this, vs, fs);
        }
        /**
        * @language zh_CN
        * 根据mesh创建一个线框
        * @param mesh 需要渲染的Mesh
        * @version Egret 3.0
        * @platform Web,Native
        */
        WireframeMesh.prototype.createByMesh = function (mesh) {
            this.createFromGeometry(mesh.geometry);
            mesh.bindWireframe(this);
        };
        /**
        * @language zh_CN
        * 根据geometry创建一个线框
        * @param geometry 模型数据
        * @version Egret 3.0
        * @platform Web,Native
        */
        WireframeMesh.prototype.createFromGeometry = function (geometry) {
            this.vertexData = [];
            this.vertexCount = 0;
            var pos_0 = new egret3d.Vector3D();
            var pos_1 = new egret3d.Vector3D();
            var pos_2 = new egret3d.Vector3D();
            for (var i = 0; i < geometry.indexData.length / 3; ++i) {
                var index_0 = geometry.indexData[i * 3 + 0];
                var index_1 = geometry.indexData[i * 3 + 1];
                var index_2 = geometry.indexData[i * 3 + 2];
                pos_0.x = geometry.verticesData[index_0 * geometry.vertexAttLength];
                pos_0.y = geometry.verticesData[index_0 * geometry.vertexAttLength + 1];
                pos_0.z = geometry.verticesData[index_0 * geometry.vertexAttLength + 2];
                pos_1.x = geometry.verticesData[index_1 * geometry.vertexAttLength];
                pos_1.y = geometry.verticesData[index_1 * geometry.vertexAttLength + 1];
                pos_1.z = geometry.verticesData[index_1 * geometry.vertexAttLength + 2];
                pos_2.x = geometry.verticesData[index_2 * geometry.vertexAttLength];
                pos_2.y = geometry.verticesData[index_2 * geometry.vertexAttLength + 1];
                pos_2.z = geometry.verticesData[index_2 * geometry.vertexAttLength + 2];
                this.vertexData.push(pos_0.x, pos_0.y, pos_0.z, pos_1.x, pos_1.y, pos_1.z, pos_1.x, pos_1.y, pos_1.z, pos_2.x, pos_2.y, pos_2.z, pos_2.x, pos_2.y, pos_2.z, pos_0.x, pos_0.y, pos_0.z);
                this.vertexCount += 6;
            }
        };
        return WireframeMesh;
    })(egret3d.WireframeBase);
    egret3d.WireframeMesh = WireframeMesh;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @class egret3d.PostCanvas
     * @classdesc
     * post canvas
     */
    var PostCanvas = (function () {
        function PostCanvas(vs, fs) {
            if (vs === void 0) { vs = "postCanvas_vertex"; }
            if (fs === void 0) { fs = "postCanvas_fragment"; }
            /**
            * @language zh_CN
            * rectangle
            */
            this.rectangle = new egret3d.Rectangle(0, 0, 0, 0);
            this.distortion = false;
            this.distortionK1 = 0.5;
            this.uniformDistortionK = new egret3d.Vector3D();
            this.transformChange = true;
            this.position = new egret3d.Vector3D();
            this.rotation = new egret3d.Vector3D();
            this.scale = new egret3d.Vector3D(1.0, 1.0, 1.0);
            this.px = 0;
            this.py = 0;
            //this.viewPort = view3D.viewPort ;
            //this.rectangle.x = this.viewPort.x ;
            //this.rectangle.y = this.viewPort.y ;
            //this.rectangle.width = this.viewPort.width;
            //this.rectangle.height = this.viewPort.height;
            this._viewMatrix = new egret3d.Matrix4_4();
            this.setShader(vs, fs);
        }
        Object.defineProperty(PostCanvas.prototype, "x", {
            /**
            * @language zh_CN
            *
            * @returns x
            */
            get: function () {
                return this.rectangle.x;
            },
            /**
            * @language zh_CN
            *
            * @param value x
            */
            set: function (value) {
                if (this.rectangle.x != value) {
                    this.rectangle.x = value;
                    this.transformChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PostCanvas.prototype, "y", {
            /**
            * @language zh_CN
            *
            * @returns y
            */
            get: function () {
                return this.rectangle.y;
            },
            /**
            * @language zh_CN
            *
            * @param value y
            */
            set: function (value) {
                if (this.rectangle.y != value) {
                    this.rectangle.y = value;
                    this.transformChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PostCanvas.prototype, "width", {
            /**
            * @language zh_CN
            *
            * @returns width
            */
            get: function () {
                return this.rectangle.width;
            },
            /**
            * @language zh_CN
            *
            * @param value width
            */
            set: function (value) {
                if (this.rectangle.width != value) {
                    this.rectangle.width = value;
                    this.transformChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PostCanvas.prototype, "height", {
            /**
            * @language zh_CN
            *
            * @returns height
            */
            get: function () {
                return this.rectangle.height;
            },
            /**
            * @language zh_CN
            *
            * @param value height
            */
            set: function (value) {
                if (this.rectangle.height != value) {
                    this.rectangle.height = value;
                    this.transformChange = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 曲面
        */
        PostCanvas.prototype.startWarped = function () {
            this.distortion = true;
            var scale1 = 0.0;
            var scale2 = 0.0;
            var norm = Math.sqrt((this.viewPort.height / 2.0) * (this.viewPort.height / 2.0) + (this.viewPort.width / 2.0) * (this.viewPort.width / 2.0));
            var vertDist = (this.viewPort.height / 2.0) / norm;
            scale2 = vertDist / (vertDist + this.distortionK1 * vertDist * vertDist * vertDist);
            var horizDist = (this.viewPort.width / 2.0) / norm;
            scale1 = (horizDist / ((horizDist + this.distortionK1 * horizDist * horizDist * horizDist)));
            this.uniformDistortionK.x = this.distortionK1;
            this.uniformDistortionK.y = scale1;
            this.uniformDistortionK.z = scale2;
        };
        /**
        * @language zh_CN
        * 设置渲染shader文件名
        * @param vsName vs
        * @param fsName fs
        */
        PostCanvas.prototype.setShader = function (vsName, fsName) {
            this.usage = new egret3d.MethodUsageData();
            this.vsShader = new egret3d.GLSL.ShaderBase(null, this.usage);
            this.fsShader = new egret3d.GLSL.ShaderBase(null, this.usage);
            this.vsShader.addShader(vsName);
            this.fsShader.addShader(fsName);
            this.vsShaderSource = this.vsShader.getShaderSource();
            this.fsShaderSource = this.fsShader.getShaderSource();
        };
        PostCanvas.prototype.rebuild = function (context3D) {
            var vertexShader = context3D.creatVertexShader(this.vsShaderSource);
            var fragmentShader = context3D.creatFragmentShader(this.fsShaderSource);
            this.usage.program3D = context3D.creatProgram(vertexShader, fragmentShader);
            if (this.usage.program3D) {
                context3D.setProgram(this.usage.program3D);
            }
            if (!this.vertexBuffer3D) {
                this.vertexBuffer3D = context3D.creatVertexBuffer(PostCanvas.singleQuadData);
                this.indexBuffer3D = context3D.creatIndexBuffer(PostCanvas.singleQuadIndex);
            }
            this.usage.attribute_position.uniformIndex = context3D.getShaderAttribLocation(this.usage.program3D, "attribute_position");
            this.usage.attribute_uv0.uniformIndex = context3D.getShaderAttribLocation(this.usage.program3D, "attribute_uv0");
            this.usage.uniform_ProjectionMatrix.uniformIndex = context3D.getUniformLocation(this.usage.program3D, "uniform_ProjectionMatrix");
            if (this.distortion) {
                this.distortionK1Register = context3D.getUniformLocation(this.usage.program3D, "_K");
            }
            if (this.usage.uniform_sceneWidth) {
                this.usage.uniform_sceneWidth.uniformIndex = context3D.getUniformLocation(this.usage.program3D, this.usage.uniform_sceneWidth.varName);
            }
            if (this.usage.uniform_sceneHeight) {
                this.usage.uniform_sceneHeight.uniformIndex = context3D.getUniformLocation(this.usage.program3D, this.usage.uniform_sceneHeight.varName);
            }
            //--------texture----------------
            var sampler2D;
            for (var index in this.usage.sampler2DList) {
                sampler2D = this.usage.sampler2DList[index];
                sampler2D.uniformIndex = context3D.getUniformLocation(this.usage.program3D, sampler2D.varName);
            }
            //--------texture----------------
            var sampler3D;
            for (var index in this.usage.sampler3DList) {
                sampler3D = this.usage.sampler3DList[index];
                sampler3D.uniformIndex = context3D.getUniformLocation(this.usage.program3D, sampler3D.varName);
            }
        };
        /**
        * @language zh_CN
        * xxxxxxxx
        * @param context3D
        * @param viewPort
        * @returns
        */
        PostCanvas.prototype.draw = function (context3D, viewPort) {
            this.viewPort = viewPort;
            if (this.transformChange)
                this.notifyUpdate();
            //context3D.gl.clear(Egret3DDrive.DEPTH_BUFFER_BIT);
            if (!this.usage.program3D)
                this.rebuild(context3D);
            context3D.viewPort(viewPort.x, viewPort.y, viewPort.width, viewPort.height);
            context3D.disable(context3D.gl.DEPTH_TEST);
            context3D.disable(context3D.gl.BLEND);
            context3D.setProgram(this.usage.program3D);
            context3D.bindVertexBuffer(this.vertexBuffer3D);
            context3D.vertexAttribPointer(this.usage.program3D, this.usage.attribute_position.uniformIndex, 3, egret3d.Egret3DDrive.FLOAT, false, 20, 0);
            context3D.vertexAttribPointer(this.usage.program3D, this.usage.attribute_uv0.uniformIndex, 2, egret3d.Egret3DDrive.FLOAT, false, 20, 12);
            context3D.uniformMatrix4fv(this.usage.uniform_ProjectionMatrix.uniformIndex, false, this._viewMatrix.rawData);
            if (this.distortion) {
                context3D.uniform3f(this.distortionK1Register, this.uniformDistortionK.x, this.uniformDistortionK.y, this.uniformDistortionK.z);
            }
            if (this.usage.uniform_sceneWidth) {
                context3D.uniform1f(this.usage.uniform_sceneWidth.uniformIndex, this.viewPort.width);
            }
            if (this.usage.uniform_sceneHeight) {
                context3D.uniform1f(this.usage.uniform_sceneHeight.uniformIndex, this.viewPort.height);
            }
            //--------texture----------------
            var sampler2D;
            for (var index in this.usage.sampler2DList) {
                sampler2D = this.usage.sampler2DList[index];
                if (sampler2D.varName == "texture2D_1") {
                    context3D.setTexture2DAt(sampler2D.activeTextureIndex, sampler2D.uniformIndex, sampler2D.index, this.texture.texture);
                }
                else if (sampler2D.varName == "texture2D_2") {
                    context3D.setTexture2DAt(sampler2D.activeTextureIndex, sampler2D.uniformIndex, sampler2D.index, this.texture2.texture);
                }
            }
            context3D.drawElement(egret3d.DrawMode.TRIANGLES, this.indexBuffer3D, 0, 6);
        };
        PostCanvas.prototype.notifyUpdate = function () {
            this.transformChange = false;
            this._viewMatrix.identity();
            this.position.x = -1;
            this.position.y = 1;
            this.scale.x = this.rectangle.width / this.viewPort.width * 2.0;
            this.scale.y = this.rectangle.height / this.viewPort.height * 2.0;
            this._viewMatrix.recompose([this.position, this.rotation, this.scale]);
        };
        PostCanvas.singleQuadData = [
            0.0, -1.0, 0.0, 0.0, 0.0,
            1.0, -1.0, 0.0, 1.0, 0.0,
            1.0, 0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 0.0, 0.0, 1.0
        ];
        PostCanvas.singleQuadIndex = [0, 1, 2, 0, 2, 3];
        return PostCanvas;
    })();
    egret3d.PostCanvas = PostCanvas;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @class egret3d.HUD
     * @classdesc
     * HUD直接渲染在屏幕上的一张贴图。
     * 可直接指定2维坐标，贴图的宽度和高度
     * 其底层渲染也是由4个顶点构成，顶点数据结构有位置信息和uv信息
     * 其所有的HUD对象的顶点信息数据都是共用的
     * @version Egret 3.0
     * @platform Web,Native
     */
    var HUD = (function () {
        /**
        * @language zh_CN
        * 构造
        */
        function HUD() {
            /**
            * @language zh_CN
            * @private
            */
            this.rectangle = new egret3d.Rectangle(0, 0, 0, 0);
            /**
            * @language zh_CN
            * @private
            * anchor
            */
            this.anchor = new egret3d.Vector3D(0.5, 0.5);
            /**
            * @language zh_CN
            * @private
            * rotation
            */
            this.rotation = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * @private
            * r
            */
            this.r = 1;
            /**
            * @language zh_CN
            * @private
            * g
            */
            this.g = 1;
            /**
            * @language zh_CN
            * @private
            * b
            */
            this.b = 1;
            /**
            * @language zh_CN
            * @private
            * a
            */
            this.a = 1;
            /**
            * @language zh_CN
            * @private
            * uvRectangle
            */
            this.uvRectangle = new egret3d.Rectangle(0, 0, 1, 1);
            this.rectangle.x = 0;
            this.rectangle.y = 0;
            this.rectangle.width = 100;
            this.rectangle.height = 100;
            this._viewMatrix = new egret3d.Matrix4_4();
            //this._viewMatrix.appendScale(0.1,0.1, 1.0);
            this.quadShader = new QuadShader();
            // this.usage.attribute_position.index = context3D.getShaderAttribLocation(program3D, this.usage.attribute_position.name);
            // this.usage.attribute_normal.index = context3D.getShaderAttribLocation(program3D, this.usage.attribute_normal.name);
            // this.usage.attribute_tangent.index = context3D.getShaderAttribLocation(program3D, this.usage.attribute_tangent.name);
        }
        Object.defineProperty(HUD.prototype, "x", {
            /**
            * @language zh_CN
            * 得到x坐标
            * @returns x坐标
            */
            get: function () {
                return this.rectangle.x;
            },
            /**
            * @language zh_CN
            * 设置x坐标
            * @param value x坐标
            */
            set: function (value) {
                this.rectangle.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "y", {
            /**
            * @language zh_CN
            * 得到y坐标
            * @returns y坐标
            */
            get: function () {
                return this.rectangle.y;
            },
            /**
            * @language zh_CN
            * 设置y坐标
            * @param value y坐标
            */
            set: function (value) {
                this.rectangle.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "width", {
            /**
            * @language zh_CN
            * 得到HUD的宽度
            * @returns HUD宽
            */
            get: function () {
                return this.rectangle.width;
            },
            /**
            * @language zh_CN
            * 设置HUD的宽度
            * @param value HUD宽
            */
            set: function (value) {
                this.rectangle.width = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HUD.prototype, "height", {
            /**
            * @language zh_CN
            * 得到HUD的高度
            * @returns HUD高
            */
            get: function () {
                return this.rectangle.height;
            },
            /**
            * @language zh_CN
            * 设置HUD的高度
            * @param value HUD高
            */
            set: function (value) {
                this.rectangle.height = value;
            },
            enumerable: true,
            configurable: true
        });
        HUD.prototype.rebuild = function (context3D) {
            var vertexShader = context3D.creatVertexShader(this.quadShader.vertexShaderSource);
            var fragmentShader = context3D.creatFragmentShader(this.quadShader.fragmentShaderSource);
            this.shaderProgram = context3D.creatProgram(vertexShader, fragmentShader);
            if (this.shaderProgram) {
                context3D.setProgram(this.shaderProgram);
            }
            if (!this.vertexBuffer3D) {
                this.vertexBuffer3D = context3D.creatVertexBuffer(HUD.singleQuadData);
                this.indexBuffer3D = context3D.creatIndexBuffer(HUD.singleQuadIndex);
            }
            this.posAtt = context3D.getShaderAttribLocation(this.shaderProgram, "aVertexPosition");
            this.uvAtt = context3D.getShaderAttribLocation(this.shaderProgram, "aTextureCoord");
            this.viewMatIndex = context3D.getUniformLocation(this.shaderProgram, "viewProjectionMatrix");
            this.uiDataIndex = context3D.getUniformLocation(this.shaderProgram, "uiDatas");
            this.textureIndex = context3D.getUniformLocation(this.shaderProgram, "diffuseTexture");
            this.materialDataIndex = context3D.getUniformLocation(this.shaderProgram, "materialData");
        };
        /**
        * @language zh_CN
        * 提交数据给GPU渲染
        * @param context3D Context3D
        */
        HUD.prototype.draw = function (context3D) {
            if (!this.shaderProgram)
                this.rebuild(context3D);
            this.viewPort = egret3d.Egret3DDrive.canvasRectangle;
            this._viewMatrix.identity();
            //test
            var tempMat = new egret3d.Matrix4_4();
            this._viewMatrix.appendRotation(this.rotation.z, egret3d.Vector3D.Z_AXIS);
            tempMat.appendScale(this.rectangle.width / this.viewPort.width * 2.0, this.rectangle.height / this.viewPort.height * 2.0, 1.0);
            this._viewMatrix.append(tempMat);
            var px = (this.viewPort.width - (this.rectangle.x + this.rectangle.width / 2) * 2.0) * (1 / this.viewPort.width); // +
            //(this.viewPort.width - (this.rectangle.width / 2.0) * 2.0) * (1 / this.viewPort.width); 
            var py = (this.viewPort.height - (this.rectangle.y + this.rectangle.height / 2) * 2.0) * (1 / this.viewPort.height); // +
            //(this.viewPort.height - (this.rectangle.height / 2.0) * 2.0) * (1 / this.viewPort.height); 
            this._viewMatrix.appendTranslation(-px, py, 0.0);
            context3D.setProgram(this.shaderProgram);
            //var len = 3 * Float32Array.BYTES_PER_ELEMENT +
            //    2 * Float32Array.BYTES_PER_ELEMENT;
            context3D.bindVertexBuffer(this.vertexBuffer3D);
            context3D.vertexAttribPointer(this.shaderProgram, this.posAtt, 3, egret3d.Egret3DDrive.FLOAT, false, 20, 0);
            context3D.vertexAttribPointer(this.shaderProgram, this.uvAtt, 2, egret3d.Egret3DDrive.FLOAT, false, 20, 12);
            context3D.uniformMatrix4fv(this.viewMatIndex, false, this._viewMatrix.rawData);
            this.texture.upload(context3D);
            context3D.setTexture2DAt(egret3d.ContextSamplerType.TEXTURE_0, this.textureIndex, 0, this.texture.texture);
            context3D.uniform4fv(this.materialDataIndex, [this.r, this.g, this.b, this.a]);
            //context3D.setTexture2DSamplerState(egret3d.NEAREST, egret3d.NEAREST, egret3d.CLAMP_TO_EDGE, egret3d.CLAMP_TO_EDGE);
            context3D.enbable(egret3d.Egret3DDrive.BLEND);
            context3D.setBlendFactors(egret3d.Egret3DDrive.SRC_ALPHA, egret3d.Egret3DDrive.ONE_MINUS_SRC_ALPHA);
            context3D.drawElement(egret3d.DrawMode.TRIANGLES, this.indexBuffer3D, 0, 6);
            context3D.gl.clear(egret3d.Egret3DDrive.DEPTH_BUFFER_BIT);
        };
        HUD.singleQuadData = [
            -0.5, -0.5, 0.0, 0.0, 0.0,
            0.5, -0.5, 0.0, 1.0, 0.0,
            0.5, 0.5, 0.0, 1.0, 1.0,
            -0.5, 0.5, 0.0, 0.0, 1.0
        ];
        HUD.singleQuadIndex = [0, 1, 2, 0, 2, 3];
        return HUD;
    })();
    egret3d.HUD = HUD;
    /**
    * @private
    */
    var QuadShader = (function () {
        function QuadShader() {
            this.vertexShaderSource = "";
            this.fragmentShaderSource = "";
            this.vertexShaderSource = "precision mediump float; \n";
            this.vertexShaderSource += " attribute vec3 aVertexPosition;                                                                       \n ";
            this.vertexShaderSource += " attribute vec2 aTextureCoord;                                                                         \n ";
            this.vertexShaderSource += "                                                                                                       \n ";
            this.vertexShaderSource += " varying  vec2 vTextureCoord;                                                                      \n ";
            this.vertexShaderSource += " uniform  mat4 viewProjectionMatrix;                                                                      \n ";
            this.vertexShaderSource += " uniform  vec4 uiDatas[116];                                                                      \n ";
            this.vertexShaderSource += "  void main(void) {                                                                                      \n ";
            this.vertexShaderSource += "     vec4 pos = vec4(aVertexPosition.xyz, 1.0) ;                                    \n ";
            this.vertexShaderSource += "     gl_Position = viewProjectionMatrix * pos;                                    \n ";
            this.vertexShaderSource += "     vTextureCoord = aTextureCoord ;                                                                       \n ";
            this.vertexShaderSource += " }                                                                                                     \n ";
            this.fragmentShaderSource = " precision mediump float; \n";
            this.fragmentShaderSource += " varying  vec2 vTextureCoord;                                                                      \n ";
            this.fragmentShaderSource += " uniform sampler2D diffuseTexture;                                                                      \n ";
            this.fragmentShaderSource += " uniform vec4 materialData;                                                                      \n ";
            this.fragmentShaderSource += "  void main(void) {                                                                                      \n ";
            this.fragmentShaderSource += "      vec4 color  = texture2D(diffuseTexture,vTextureCoord) * materialData ;                                    \n ";
            //this.fragmentShaderSource += "    vec4 color = vec4( 1.0 ,1.0 ,0.0 ,1.0) ;                                    \n ";
            this.fragmentShaderSource += "      gl_FragColor  = color;                                    \n ";
            this.fragmentShaderSource += "}                        \n ";
        }
        return QuadShader;
    })();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.PostEffectBase
    * @classdesc
    * 后期合成基类
    */
    var PostEffectBase = (function () {
        /**
         * @language zh_CN
         */
        function PostEffectBase() {
            this.rec = new egret3d.Rectangle();
        }
        /**
         * @language zh_CN
         * @param context3D
         * @param width
         * @param height
         */
        PostEffectBase.prototype.init = function (context3D, width, height) {
            this.nextFrameBuffer = egret3d.RttManager.creatFrameBuffer(egret3d.FrameBufferType.defaultFrameBuffer, context3D, width, height, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB);
            this.rec.width = width;
            this.rec.height = height;
        };
        /**
         * @language zh_CN
         * @param source 数据来源buffer
         * @param target 渲染的目标buffer
         * @param context3D  gpu设备
         * @param viewPort 视口
         */
        PostEffectBase.prototype.drawToTarget = function (source, target, context3D, viewPort) {
        };
        return PostEffectBase;
    })();
    egret3d.PostEffectBase = PostEffectBase;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.BrightPost
    * @classdesc
    * 后期亮度调整
    * @version Egret 3.0
    * @platform Web,Native
    */
    var BrightPost = (function (_super) {
        __extends(BrightPost, _super);
        /**
         * @language zh_CN
         * 构造
         * @version Egret 3.0
         * @platform Web,Native
         */
        function BrightPost() {
            _super.call(this);
            this.postCanvas = new egret3d.PostCanvas("postCanvas_vertex", "BrightPassFilter");
        }
        /**
         * @language zh_CN
         * 渲染到目标帧缓冲上
         * @param source 数据来源buffer
         * @param target 渲染的目标buffer
         * @param context3D  gpu设备
         * @param viewPort 视口
         * @version Egret 3.0
         * @platform Web,Native
         */
        BrightPost.prototype.drawToTarget = function (source, target, context3D, viewPort) {
            context3D.setRenderToTexture(this.nextFrameBuffer.texture.texture, true, 0);
            this.postCanvas.width = this.rec.width;
            this.postCanvas.height = this.rec.height;
            this.postCanvas.texture = target.texture;
            this.postCanvas.draw(context3D, this.rec);
            //context3D.setRenderToBackBuffer();
            //this.postCanvas.width = viewPort.width;
            //this.postCanvas.height = viewPort.height;
            //this.postCanvas.draw(context3D, this.nextFrameBuffer.texture.texture, viewPort);
        };
        return BrightPost;
    })(egret3d.PostEffectBase);
    egret3d.BrightPost = BrightPost;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.GaussianBlurHorizontalPost
    * @classdesc
    * 后期横向高斯模糊
    */
    var GaussianBlurHorizontalPost = (function (_super) {
        __extends(GaussianBlurHorizontalPost, _super);
        /**
         * @language zh_CN
         */
        function GaussianBlurHorizontalPost() {
            _super.call(this);
            this.postCanvas = new egret3d.PostCanvas("postCanvas_vertex", "GaussianBlurHorizontal");
        }
        /**
         * @language zh_CN
         * @param source 数据来源buffer
         * @param target 渲染的目标buffer
         * @param context3D  gpu设备
         * @param viewPort 视口
         */
        GaussianBlurHorizontalPost.prototype.drawToTarget = function (source, target, context3D, viewPort) {
            context3D.setRenderToTexture(this.nextFrameBuffer.texture.texture, true, 0);
            this.postCanvas.width = this.rec.width;
            this.postCanvas.height = this.rec.height;
            this.postCanvas.texture = target.texture;
            this.postCanvas.draw(context3D, this.rec);
        };
        return GaussianBlurHorizontalPost;
    })(egret3d.PostEffectBase);
    egret3d.GaussianBlurHorizontalPost = GaussianBlurHorizontalPost;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.GaussianBlurVerticalPost
    * @classdesc
    * 后期纵向高斯模糊
    */
    var GaussianBlurVerticalPost = (function (_super) {
        __extends(GaussianBlurVerticalPost, _super);
        /**
         * @language zh_CN
         */
        function GaussianBlurVerticalPost() {
            _super.call(this);
            this.postCanvas = new egret3d.PostCanvas("postCanvas_vertex", "GaussianBlurVertical");
        }
        /**
         * @language zh_CN
         * @param source 数据来源buffer
         * @param target 渲染的目标buffer
         * @param context3D  gpu设备
         * @param viewPort 视口
         */
        GaussianBlurVerticalPost.prototype.drawToTarget = function (source, target, context3D, viewPort) {
            context3D.setRenderToTexture(this.nextFrameBuffer.texture.texture, true, 0);
            this.postCanvas.width = this.rec.width;
            this.postCanvas.height = this.rec.height;
            this.postCanvas.texture = target.texture;
            this.postCanvas.draw(context3D, this.rec);
            //  context3D.setRenderToBackBuffer();
        };
        return GaussianBlurVerticalPost;
    })(egret3d.PostEffectBase);
    egret3d.GaussianBlurVerticalPost = GaussianBlurVerticalPost;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @language zh_CN
    * @class egret3d.Composition
    * @classdesc
    * 后期合成
    */
    var Composition = (function (_super) {
        __extends(Composition, _super);
        /**
         * @language zh_CN
         * 构造
         */
        function Composition() {
            _super.call(this);
            this.postCanvas = new egret3d.PostCanvas("postCanvas_vertex", "Composition");
        }
        /**
         * @language zh_CN
         * 渲染到目标帧缓冲上
         * @param source 数据来源buffer
         * @param target 渲染的目标buffer
         * @param context3D  gpu设备
         * @param viewPort 视口
         */
        Composition.prototype.drawToTarget = function (source, target, context3D, viewPort) {
            context3D.setRenderToTexture(this.nextFrameBuffer.texture.texture, true, 0);
            this.postCanvas.width = this.rec.width;
            this.postCanvas.height = this.rec.height;
            this.postCanvas.texture = target.texture;
            this.postCanvas.texture2 = source.texture;
            this.postCanvas.draw(context3D, this.rec);
        };
        return Composition;
    })(egret3d.PostEffectBase);
    egret3d.Composition = Composition;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.Tonemaping
    * @classdesc
    * 颜色调和
    */
    var Tonemaping = (function (_super) {
        __extends(Tonemaping, _super);
        /**
         * @language zh_CN
         */
        function Tonemaping() {
            _super.call(this);
            this.postCanvas = new egret3d.PostCanvas("postCanvas_vertex", "Tonemaping");
        }
        /**
         * @language zh_CN
         
         * @param source 数据来源buffer
         * @param target 渲染的目标buffer
         * @param context3D  gpu设备
         * @param viewPort 视口
         */
        Tonemaping.prototype.drawToTarget = function (source, target, context3D, viewPort) {
            this.postCanvas.width = this.rec.width;
            this.postCanvas.height = this.rec.height;
            this.postCanvas.texture = source.texture;
            this.postCanvas.texture2 = target.texture;
            this.postCanvas.draw(context3D, this.rec);
        };
        return Tonemaping;
    })(egret3d.PostEffectBase);
    egret3d.Tonemaping = Tonemaping;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @private
    * @class egret3d.HDR
    * @classdesc
    * 后期HDR合成
    */
    var HDR = (function (_super) {
        __extends(HDR, _super);
        /**
         * @language zh_CN
         */
        function HDR() {
            _super.call(this);
            this.lumAdapt = 0.0;
            this.lum = 1.0;
            this.brightPost = new egret3d.BrightPost();
            this.gaussianBlurHorizontalPost = new egret3d.GaussianBlurHorizontalPost();
            this.gaussianBlurVerticalPost = new egret3d.GaussianBlurVerticalPost();
            this.composition = new egret3d.Composition();
            this.toneMap = new egret3d.Tonemaping();
        }
        /**
         * @language zh_CN
         * @param context3D
         * @param width
         * @param height
         */
        HDR.prototype.init = function (context3D, width, height) {
            this.brightPost.init(context3D, width, height);
            this.gaussianBlurHorizontalPost.init(context3D, width, height);
            this.gaussianBlurVerticalPost.init(context3D, width, height);
            this.composition.init(context3D, width, height);
            this.toneMap.init(context3D, width, height);
        };
        /**
         * @language zh_CN
         * @param source 数据来源buffer
         * @param target 渲染的目标buffer
         * @param context3D  gpu设备
         * @param viewPort 视口
         */
        HDR.prototype.drawToTarget = function (source, target, context3D, viewPort) {
            this.lumAdapt += (this.lum - this.lumAdapt) * (1 - Math.pow(0.98, 30 * 16));
            var next = source;
            this.brightPost.drawToTarget(source, next, context3D, viewPort);
            next = this.brightPost.nextFrameBuffer;
            this.nextFrameBuffer = this.brightPost.nextFrameBuffer;
            this.gaussianBlurHorizontalPost.drawToTarget(source, next, context3D, viewPort);
            next = this.gaussianBlurHorizontalPost.nextFrameBuffer;
            this.gaussianBlurVerticalPost.drawToTarget(source, next, context3D, viewPort);
            next = this.gaussianBlurVerticalPost.nextFrameBuffer;
            this.nextFrameBuffer = next;
            //this.composition.drawToTarget(source, next, context3D, viewPort);
            //this.nextFrameBuffer = this.composition.nextFrameBuffer;
            context3D.setRenderToBackBuffer();
        };
        return HDR;
    })(egret3d.PostEffectBase);
    egret3d.HDR = HDR;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @class egret3d.View3D
     * @classdesc
     * 渲染视图
     * view3D 是整个3D引擎的渲染视口，可以控制渲染窗口的大小，渲染的方式
     * 可以设置不同的相机 camera3D
     * 交换不同的场景元素 scene3D
     * skyBox需要在这里直接设置，有cube sky 和 sphere sky
     * 整个渲染的主循环通过 render
     * @see egret3d.camera3d
     * @see egret3d.scene3D
     * @version Egret 3.0
     * @platform Web,Native
     */
    var View3D = (function () {
        /**
        * @language zh_CN
        * 创建一个新的 View3D 对象。
        * @param viewPort {Rectangle} 显示区域
        * @param camera {Camera3D} 摄像机
        * @version Egret 3.0
        * @platform Web,Native
        */
        function View3D(viewPort, camera) {
            var _this = this;
            if (camera === void 0) { camera = null; }
            this._width = 0;
            this._height = 0;
            this._x = 0;
            this._y = 0;
            this._localPos = new egret3d.Point();
            this._globalPos = new egret3d.Point();
            this._aspectRatio = 1;
            this._scissorRectDirty = true;
            this._viewportDirty = true;
            this._viewPortMatrix = new egret3d.Matrix4_4();
            this._useShadow = false;
            this._isDeferred = false;
            this._resizeFuncs = new Array();
            this._wireframeList = new Array();
            this._hudList = new Array();
            this._context3D = egret3d.Egret3DDrive.context3D;
            this._camera = camera || new egret3d.Camera3D(egret3d.CameraType.perspective);
            this._scissorRect = new egret3d.Rectangle();
            this._viewPort = viewPort;
            this._scene = new egret3d.Scene3D();
            this._render = egret3d.RenderManager.getRender(egret3d.RenderType.defaultRender);
            //this.requestFrameBuffer();
            this.x = viewPort.x;
            this.y = viewPort.y;
            this.width = viewPort.width;
            this.height = viewPort.height;
            window.addEventListener("resize", function () { return _this.resize(); });
            this._mouseEventManager = new egret3d.Mouse3DManager(this._camera);
        }
        Object.defineProperty(View3D.prototype, "root", {
            /**
            * @language zh_CN
            * 返回渲染根节点
            * 返回渲染场景的 scene3D
            * @returns Object3D
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._scene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "scene", {
            /**
            * @language zh_CN
            * 返回 Scene3D 对象
            * 返回 Scene3D 对象
            * @returns {Scene3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._scene;
            },
            /**
            * @language zh_CN
            * 设置场景
            * 设置渲染场景的 scene3D ， 可以将整个渲染 列表替换，可作为游戏中切换游戏场景的主要接口
            * @param scene {Scene3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (scene) {
                this._scene = scene;
            },
            enumerable: true,
            configurable: true
        });
        View3D.prototype.resize = function () {
            this.x = this.viewPort.x = 0;
            this.y = this.viewPort.y = 0;
            this.width = this.viewPort.width = window.innerWidth;
            this.height = this.viewPort.height = window.innerHeight;
            egret3d.Egret3DDrive.canvas.width = this.viewPort.width;
            egret3d.Egret3DDrive.canvas.height = this.viewPort.height;
            egret3d.Egret3DDrive.canvasRectangle.x = this.x;
            egret3d.Egret3DDrive.canvasRectangle.y = this.y;
            egret3d.Egret3DDrive.canvasRectangle.width = this.width;
            egret3d.Egret3DDrive.canvasRectangle.height = this.height;
            this.updateViewSizeData();
            for (var i = 0; i < this._resizeFuncs.length; ++i) {
                this._resizeFuncs[i]();
            }
        };
        Object.defineProperty(View3D.prototype, "render", {
            /**
            * @language zh_CN
            * 设置渲染器
            * view3D 可以使用不同的渲染器，每个渲染器可以渲染不同的渲染通道使之直接在主屏幕中显示出来
            * @param val {RenderBase}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (val) {
                this._render = val;
                if (typeof (val) === "GBufferRender") {
                    this._isDeferred = true;
                }
                else {
                    this._isDeferred = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "useShadow", {
            /**
            * @language zh_CN
            * 是否使用影子
            * 在当前的渲染时口中，是否可以使用阴影映射，如果是将开始进行渲染逻辑
            * @returns {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._useShadow;
            },
            /**
            * @language zh_CN
            * 是否使用影子
            * 在当前的渲染时口中，是否可以使用阴影映射，如果是将开始进行渲染逻辑
            * @param flag {boolean}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (flag) {
                this._useShadow = flag;
                if (flag) {
                    this._shadowRender = new egret3d.ShadowRender();
                }
            },
            enumerable: true,
            configurable: true
        });
        View3D.prototype.requestFrameBuffer = function () {
            if (this._isDeferred) {
            }
            else {
                this._postCanvas = new egret3d.PostCanvas();
            }
        };
        /**
        * @language zh_CN
        * @private
        * 监听设备重置回调
        * 事件机制
        * @event func  {Function}
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.addListenerResize = function (func) {
            this._resizeFuncs.push(func);
        };
        Object.defineProperty(View3D.prototype, "viewPort", {
            /**
            * @language zh_CN
            * 返回视口
            * 返回视口的尺寸大小
            * @returns {Rectangle}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._viewPort;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "sky", {
            /**
            * @language zh_CN
            * 返回天空盒子
            * 设置天空盒子，天空盒子的类型有 cubesky 和 spheresky 两种类型，其中 spheresky 是属于360天空全景照片使用
            * @returns {Sky}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._sky;
            },
            /**
            * @language zh_CN
            * 设置天空盒子
            * 设置天空盒子，天空盒子的类型有 cubesky 和 spheresky 两种类型，其中 spheresky 是属于360天空全景照片使用
            * @param value {Sky} 天空盒子
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._sky = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "sphereSky", {
            /**
            * @language zh_CN
            * 设置天空球
            * 设置天空盒子，天空盒子的类型有 cubesky 和 spheresky 两种类型，其中 spheresky 是属于360天空全景照片使用
            * @param value {SphereSky} 天空球
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._sphereSky = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 添加 HUD 到渲染列表中
        * 设置天空盒子，天空盒子的类型有 cubesky 和 spheresky 两种类型，其中 spheresky 是属于360天空全景照片使用
        * @param hud {HUD}
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.addHUD = function (hud) {
            this._hudList.push(hud);
        };
        /**
        * @language zh_CN
        * @private
        * 在渲染列表中删除一个HUD
        * @param hud {HUD}
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.delHUN = function (hud) {
            var index = this._hudList.indexOf(hud);
            this._hudList.splice(index, 1);
        };
        /**
        * @language zh_CN
        * 增加wireframe进渲染列表
        * 在view3D中添加物体的网格显示对象
        * @param wireframe
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.addWireframe = function (wireframe) {
            this._wireframeList.push(wireframe);
        };
        /**
        * @language zh_CN
        * 在渲染列表中删除一个wireframe
        * 动态删除物体的显示网格
        * @param hud
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.delWireframe = function (wireframe) {
            var index = this._wireframeList.indexOf(wireframe);
            this._wireframeList.splice(index, 1);
        };
        Object.defineProperty(View3D.prototype, "backImageTexture", {
            /**
            * @language zh_CN
            * 设置背景渲染贴图
            * 设置一个可跟随视口大小匹配，且永远在最后的背景显示贴图
            * @param texture 贴图
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (texture) {
                if (!this._backImg) {
                    this._backImg = new egret3d.HUD();
                    this._backImg.x = 0; // viewPort.width * 0.5  ;
                    this._backImg.y = 0; // * 0.5  ;
                    this._backImg.width = this.width;
                    this._backImg.height = this.height;
                }
                texture.upload(this._context3D);
                this._backImg.texture = texture;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "postEffect", {
            /**
            * @language zh_CN
            * 设置 postEffect
            * 设置后期MRT处理的着色滤镜，例如（HDR，tonymaping，bloom）
            * @param postEffects {Array<PostEffectBase>}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (postEffects) {
                if (postEffects) {
                    this._postCanvas = this._postCanvas || new egret3d.PostCanvas();
                    this._postList = postEffects;
                    for (var i = 0; i < this._postList.length; i++) {
                        this._postList[i].init(this._context3D, 512, 512);
                    }
                    this._sourceFrameBuffer = this._sourceFrameBuffer || egret3d.RttManager.creatFrameBuffer(egret3d.FrameBufferType.defaultFrameBuffer, this._context3D, 512, 512, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "camera3D", {
            /**
            * @language zh_CN
            * 返回 摄像机
            * 返回 摄像机 Camera3D
            * @returns Camera3D
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._camera;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "context3D", {
            /**
            * @language zh_CN
            * @private
            * 返回 Context3D
            * @returns Context3D
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._context3D;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "width", {
            /**
            * @language zh_CN
            * 获取视口的大小
            * 视口的宽度。当使用软件渲染，平台限制2048像素
            * @private
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._width;
            },
            /**
            * @language zh_CN
            * 设置视口的宽度。
            * 视口的宽度。当使用软件渲染，平台限制2048像素
            * @param width {number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._width = value;
                this._aspectRatio = this._width / this._height;
                this._camera.aspectRatio = this._aspectRatio;
                this._scissorRect.width = value;
                this._scissorRectDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "height", {
            /**
            * @language zh_CN
            * 获取视口的大小
            * 视口的高度。当使用软件渲染，平台限制2048像素
            * @returns {number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._height;
            },
            /**
            * @language zh_CN
            * 设置视口的宽度。
            * 视口的高度。当使用软件渲染，平台限制2048像素
            * @param height {number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._height = value;
                this._aspectRatio = this._width / this._height;
                this._camera.aspectRatio = this._aspectRatio;
                this._scissorRect.height = value;
                this._scissorRectDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "x", {
            /**
            * @language zh_CN
            * 返回 x 坐标值
            * 返回在网页中的webgl画面位置
            * @returns {number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._x;
            },
            /**
            * @language zh_CN
            * 设置 x 坐标值。
            * 设置在网页中的webgl画面位置
            * @param  x {number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._x == value)
                    return;
                this._localPos.x = this._x = value;
                this._globalPos.x = value;
                this._globalPosDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(View3D.prototype, "y", {
            /**
            * @language zh_CN
            * 返回 y 坐标值
            * 返回在网页中的webgl画面位置
            * @returns {number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._y;
            },
            /**
            * @language zh_CN
            * 设置 y 坐标值。
            * 设置在网页中的webgl画面位置
            * @param  x {number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                if (this._y == value)
                    return;
                this._localPos.y = value;
                this._globalPos.y = value;
                this._globalPosDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 将一个 Object3D 实例添加到 Scene3D 实例中。
        * 将一个 Object3D 实例添加到 Scene3D 实例中。参与scene3D中的显示树优化，并且即时渲染出来
        * @param  child3D {Object3D}
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.addChild3D = function (child3D) {
            this._scene.addChild(child3D);
        };
        /**
        * @language zh_CN
        * 渲染
        * 渲染中的主循环，可以使用外部时间控制器驱动，也可使用 requestFrame
        * @param time 当前时间
        * @param delay 时间间隔
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.renden = function (time, delay) {
            this.updateViewSizeData();
            this._scene.collect.update(this._camera);
            this._mouseEventManager.update(this._scene.collect);
            this._context3D.gl.enable(egret3d.Egret3DDrive.BLEND);
            this._context3D.gl.enable(egret3d.Egret3DDrive.CULL_FACE);
            this._context3D.viewPort(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
            this._context3D.clear(0.0, 0.0, 0.0, 1);
            if (this._backImg)
                this._backImg.draw(this._context3D);
            this._context3D.clearDepth(1);
            this._context3D.clearStencil(0);
            //----------即时渲染部分-------------------
            if (!this._isDeferred) {
                if (this._postList) {
                    if (this._useShadow) {
                        egret3d.RttManager.drawToTexture(time, delay, egret3d.ShadowRender.frameBuffer.texture.texture, this._context3D, this._shadowRender, this._scene.collect, this._camera, this.viewPort);
                    }
                    if (this._sky) {
                        this._sky.draw(this._context3D, this.camera3D);
                    }
                    else if (this._sphereSky) {
                        this._sphereSky.draw(this._context3D, this.camera3D);
                    }
                    egret3d.RttManager.drawToTexture(time, delay, this._sourceFrameBuffer.texture.texture, this._context3D, this._render, this._scene.collect, this._camera, this.viewPort);
                    this._context3D.clearDepth(1);
                    var next = this._sourceFrameBuffer;
                    for (var i = 0; i < this._postList.length; i++) {
                        this._postList[i].drawToTarget(this._sourceFrameBuffer, next, this._context3D, this._viewPort);
                        next = this._postList[i].nextFrameBuffer;
                    }
                    this._postCanvas.width = this._viewPort.width;
                    this._postCanvas.height = this._viewPort.height;
                    this._postCanvas.texture = next.texture;
                    this._postCanvas.draw(this._context3D, this._viewPort);
                }
                else {
                    if (this._sky) {
                        this._sky.draw(this._context3D, this.camera3D);
                    }
                    else if (this._sphereSky) {
                        this._sphereSky.draw(this._context3D, this.camera3D);
                    }
                    if (this._useShadow) {
                        egret3d.RttManager.drawToTexture(time, delay, egret3d.ShadowRender.frameBuffer.texture.texture, this._context3D, this._shadowRender, this._scene.collect, this._camera, this.viewPort);
                    }
                    this._context3D.clearDepth(1);
                    this._context3D.viewPort(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
                    this._render.draw(time, delay, this._context3D, this._scene.collect, this._camera, this._viewPort);
                }
            }
            else {
                //----------延迟渲染部分-------------------
                this._context3D.clearDepth(1);
                this._context3D.viewPort(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
                this._render.draw(time, delay, this._context3D, this._scene.collect, this._camera, this._viewPort);
            }
            for (var i = 0; i < this._wireframeList.length; i++) {
                this._wireframeList[i].draw(this._context3D, this.camera3D);
            }
            for (var i = 0; i < this._hudList.length; i++) {
                this._hudList[i].draw(this._context3D);
            }
            this._context3D.gl.finish();
        };
        View3D.prototype.updateViewSizeData = function () {
            this._camera.aspectRatio = this._aspectRatio;
            if (this._scissorRectDirty) {
                this._scissorRectDirty = false;
                this._camera.updateScissorRect(this._scissorRect.x, this._scissorRect.y, this._scissorRect.width, this._scissorRect.height);
            }
            if (this._viewportDirty) {
                this._viewportDirty = false;
                this._camera.updateViewport(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
            }
        };
        /**
        * @language zh_CN
        * 设置tag名和name的下标为index 没有的话会新加tag
        * 设置渲染的层级标签，可以自定义渲染优先顺序，让渲染可自定义化
        * @param name tag名
        * @param index 下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.setTags = function (name, index) {
            this._scene.collect.setTags(name, index);
        };
        /**
        * @language zh_CN
        * 设置layer名和name的下标为index
        * 设置渲染的层级标签，可以自定义渲染优先顺序，让渲染可自定义化
        * @param layer layer名
        * @param index 下标
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.setTagsItem = function (layer, index) {
            this._scene.collect.setTagsItem(layer, index);
        };
        /**
        * @language zh_CN
        * 返回layer的值
        * 返回当前标签的渲染层级
        * @param name tag名
        * @param layer layer名
        * @returns {Number}
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.getTagLayer = function (name, layer) {
            if (name === void 0) { name = "default"; }
            if (layer === void 0) { layer = "layer_0"; }
            return this._scene.collect.getTagLayer(name, layer);
        };
        /**
        * @language zh_CN
        * 得到tag
        * 返回当前标签的渲染标签的名字
        * @param name tag名
        * @returns {Tag}
        * @version Egret 3.0
        * @platform Web,Native
        */
        View3D.prototype.getTag = function (name) {
            if (name === void 0) { name = "default"; }
            return this._scene.collect.getTag(name);
        };
        return View3D;
    })();
    egret3d.View3D = View3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.Channel
     * @classdesc
     * VR 渲染视图。
     * @version Egret 3.0
     * @platform Web,Native
     */
    var VRView3D = (function (_super) {
        __extends(VRView3D, _super);
        /**
        * @language zh_CN
        * 创建一个新的 VRView3D 对象。
        * @param viewPort {Rectangle} 显示区域
        * @version Egret 3.0
        * @platform Web,Native
        */
        function VRView3D(viewPort) {
            _super.call(this, viewPort, new egret3d.Camera3D(egret3d.CameraType.VR));
            this.leftViewPort = new egret3d.Rectangle();
            this.rightViewPort = new egret3d.Rectangle();
            this.tab = false;
            this.eyeMatrix = new egret3d.EyesMatrix();
            this.leftViewPort.x = this.viewPort.x;
            this.leftViewPort.y = this.viewPort.y;
            this.leftViewPort.width = this.viewPort.width;
            this.leftViewPort.height = this.viewPort.height;
            this.rightViewPort.x = this.leftViewPort.width;
            this.rightViewPort.y = this.viewPort.y;
            this.rightViewPort.width = this.viewPort.width * 0.5;
            this.rightViewPort.height = this.viewPort.height;
            this.setupVR();
        }
        VRView3D.prototype.requestFrameBuffer = function () {
        };
        VRView3D.prototype.setupVR = function () {
            if (this._isDeferred) {
            }
            else {
                this._leftCanvas = new egret3d.PostCanvas("postCanvas_vertex", "warpedImage_fragment");
                this._rightCanvas = new egret3d.PostCanvas("postCanvas_vertex", "warpedImage_fragment");
                this._leftCanvas.rectangle.x = 0;
                this._leftCanvas.rectangle.y = 0;
                this._leftCanvas.rectangle.width = 480;
                this._leftCanvas.rectangle.height = 480 / 512 * this.viewPort.height;
                this._rightCanvas.rectangle.x = 480 + 30;
                this._rightCanvas.rectangle.y = 0;
                this._rightCanvas.rectangle.width = 480;
                this._rightCanvas.rectangle.height = 480 / 512 * this.viewPort.height;
                this._leftCanvas.startWarped();
                this._rightCanvas.startWarped();
                this._leftFrameBuffer = egret3d.RttManager.creatFrameBuffer(egret3d.FrameBufferType.leftEyeFrameBuffer, this._context3D, 1024, 1024, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB);
                this._rightFrameBuffer = egret3d.RttManager.creatFrameBuffer(egret3d.FrameBufferType.rightEyeFrameBuffer, this._context3D, 1024, 1024, egret3d.FrameBufferFormat.UNSIGNED_BYTE_RGB);
            }
        };
        /**
        * @language zh_CN
        * 设置眼睛空间
        * @param value {Number} Eyes Space。
        * @version Egret 3.0
        * @platform Web,Native
        */
        VRView3D.prototype.setEyesSpace = function (value) {
            this._leftCanvas.x = 75;
            this._leftCanvas.y = 0;
            this._leftCanvas.width = 512;
            this._leftCanvas.height = 512;
            this._rightCanvas.x = 75;
            this._rightCanvas.y = 512 + value;
            this._rightCanvas.width = 512;
            this._rightCanvas.height = 512;
        };
        /**
        * @language zh_CN
        * 渲染
        * @param time {Number} 当前时间
        * @param delay {Number} 间隔时间
        * @version Egret 3.0
        * @platform Web,Native
        */
        VRView3D.prototype.renden = function (time, delay) {
            _super.prototype.updateViewSizeData.call(this);
            this._scene.collect.update(this._camera);
            this._context3D.gl.enable(egret3d.Egret3DDrive.BLEND);
            this._context3D.gl.enable(egret3d.Egret3DDrive.CULL_FACE);
            this._context3D.viewPort(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
            this._context3D.clear(0.0, 0.0, 0.0, 1.0);
            //this._root.rotationZ = 180;
            //this._root.rotationX = -90 ;
            //this._camera.tap(CameraType.perspective);
            // if (this.tab) {
            this.leftEye(time, delay);
            //      this.tab = false;
            // } else {
            this.rightEye(time, delay);
            //      this.tab = true;
            //   }
            this._context3D.viewPort(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
            this._leftCanvas.texture = this._leftFrameBuffer.texture;
            this._rightCanvas.texture = this._leftFrameBuffer.texture;
            this._leftCanvas.draw(this._context3D, this._viewPort);
            this._rightCanvas.draw(this._context3D, this._viewPort);
            for (var i = 0; i < this._hudList.length; i++) {
                this._hudList[i].draw(this._context3D);
            }
            this._context3D.gl.finish();
        };
        VRView3D.prototype.leftEye = function (time, delay) {
            this._context3D.viewPort(this.leftViewPort.x, this.leftViewPort.y, this.leftViewPort.width, this.leftViewPort.height);
            this._camera.tap(egret3d.CameraType.VR, egret3d.VRType.left);
            this._context3D.setRenderToTexture(this._leftFrameBuffer.texture.texture, true, 0);
            if (this._sky) {
                this._sky.draw(this._context3D, this.camera3D);
            }
            if (this._sphereSky) {
                this._sphereSky.draw(this._context3D, this.camera3D);
            }
            this._context3D.clearDepth(1);
            this._render.draw(time, delay, this._context3D, this._scene.collect, this._camera, this._viewPort);
            this._context3D.setRenderToBackBuffer();
        };
        VRView3D.prototype.rightEye = function (time, delay) {
            this._context3D.viewPort(this.rightViewPort.x, this.rightViewPort.y, this.rightViewPort.width, this.rightViewPort.height);
            this._camera.tap(egret3d.CameraType.VR, egret3d.VRType.right);
            this._context3D.setRenderToTexture(this._rightFrameBuffer.texture.texture, true, 0);
            if (this._sky) {
                this._sky.draw(this._context3D, this.camera3D);
            }
            if (this._sphereSky) {
                this._sphereSky.draw(this._context3D, this.camera3D);
            }
            this._context3D.clearDepth(1);
            this._render.draw(time, delay, this._context3D, this._scene.collect, this._camera, this._viewPort);
            this._context3D.setRenderToBackBuffer();
        };
        return VRView3D;
    })(egret3d.View3D);
    egret3d.VRView3D = VRView3D;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @version Egret 3.0
     * @platform Web,Native
     */
    (function (KeyCode) {
        KeyCode[KeyCode["Key_BackSpace"] = 8] = "Key_BackSpace";
        KeyCode[KeyCode["Key_Tab"] = 9] = "Key_Tab";
        KeyCode[KeyCode["Key_Clear"] = 10] = "Key_Clear";
        KeyCode[KeyCode["Key_Enter"] = 11] = "Key_Enter";
        KeyCode[KeyCode["Key_Shift_L"] = 12] = "Key_Shift_L";
        KeyCode[KeyCode["Key_Control_L"] = 13] = "Key_Control_L";
        KeyCode[KeyCode["Key_Alt_L"] = 14] = "Key_Alt_L";
        KeyCode[KeyCode["Key_Pause"] = 15] = "Key_Pause";
        KeyCode[KeyCode["Key_CapsLock"] = 16] = "Key_CapsLock";
        KeyCode[KeyCode["Key_Escape"] = 17] = "Key_Escape";
        KeyCode[KeyCode["Key_Space"] = 18] = "Key_Space";
        KeyCode[KeyCode["Key_Prior"] = 19] = "Key_Prior";
        KeyCode[KeyCode["Key_Next"] = 20] = "Key_Next";
        KeyCode[KeyCode["Key_End"] = 21] = "Key_End";
        KeyCode[KeyCode["Key_Home"] = 22] = "Key_Home";
        KeyCode[KeyCode["Key_Left"] = 23] = "Key_Left";
        KeyCode[KeyCode["Key_Up"] = 24] = "Key_Up";
        KeyCode[KeyCode["Key_Right"] = 25] = "Key_Right";
        KeyCode[KeyCode["Key_Down"] = 26] = "Key_Down";
        KeyCode[KeyCode["Key_Select"] = 27] = "Key_Select";
        KeyCode[KeyCode["Key_Print"] = 28] = "Key_Print";
        KeyCode[KeyCode["Key_Execute"] = 29] = "Key_Execute";
        KeyCode[KeyCode["Key_Insert"] = 30] = "Key_Insert";
        KeyCode[KeyCode["Key_Delete"] = 31] = "Key_Delete";
        KeyCode[KeyCode["Key_Help"] = 32] = "Key_Help";
        KeyCode[KeyCode["Key_0"] = 48] = "Key_0";
        KeyCode[KeyCode["Key_1"] = 49] = "Key_1";
        KeyCode[KeyCode["Key_2"] = 50] = "Key_2";
        KeyCode[KeyCode["Key_3"] = 51] = "Key_3";
        KeyCode[KeyCode["Key_4"] = 52] = "Key_4";
        KeyCode[KeyCode["Key_5"] = 53] = "Key_5";
        KeyCode[KeyCode["Key_6"] = 54] = "Key_6";
        KeyCode[KeyCode["Key_7"] = 55] = "Key_7";
        KeyCode[KeyCode["Key_8"] = 56] = "Key_8";
        KeyCode[KeyCode["Key_9"] = 57] = "Key_9";
        KeyCode[KeyCode["Key_A"] = 65] = "Key_A";
        KeyCode[KeyCode["Key_B"] = 66] = "Key_B";
        KeyCode[KeyCode["Key_C"] = 67] = "Key_C";
        KeyCode[KeyCode["Key_D"] = 68] = "Key_D";
        KeyCode[KeyCode["Key_E"] = 69] = "Key_E";
        KeyCode[KeyCode["Key_F"] = 70] = "Key_F";
        KeyCode[KeyCode["Key_G"] = 71] = "Key_G";
        KeyCode[KeyCode["Key_H"] = 72] = "Key_H";
        KeyCode[KeyCode["Key_I"] = 73] = "Key_I";
        KeyCode[KeyCode["Key_J"] = 74] = "Key_J";
        KeyCode[KeyCode["Key_K"] = 75] = "Key_K";
        KeyCode[KeyCode["Key_L"] = 76] = "Key_L";
        KeyCode[KeyCode["Key_M"] = 77] = "Key_M";
        KeyCode[KeyCode["Key_N"] = 78] = "Key_N";
        KeyCode[KeyCode["Key_O"] = 79] = "Key_O";
        KeyCode[KeyCode["Key_P"] = 80] = "Key_P";
        KeyCode[KeyCode["Key_Q"] = 81] = "Key_Q";
        KeyCode[KeyCode["Key_R"] = 82] = "Key_R";
        KeyCode[KeyCode["Key_S"] = 83] = "Key_S";
        KeyCode[KeyCode["Key_T"] = 84] = "Key_T";
        KeyCode[KeyCode["Key_U"] = 85] = "Key_U";
        KeyCode[KeyCode["Key_V"] = 86] = "Key_V";
        KeyCode[KeyCode["Key_W"] = 87] = "Key_W";
        KeyCode[KeyCode["Key_X"] = 88] = "Key_X";
        KeyCode[KeyCode["Key_Y"] = 89] = "Key_Y";
        KeyCode[KeyCode["Key_Z"] = 90] = "Key_Z";
        KeyCode[KeyCode["Key_KP_0"] = 96] = "Key_KP_0";
        KeyCode[KeyCode["Key_KP_1"] = 97] = "Key_KP_1";
        KeyCode[KeyCode["Key_KP_2"] = 98] = "Key_KP_2";
        KeyCode[KeyCode["Key_KP_3"] = 99] = "Key_KP_3";
        KeyCode[KeyCode["Key_KP_4"] = 100] = "Key_KP_4";
        KeyCode[KeyCode["Key_KP_5"] = 101] = "Key_KP_5";
        KeyCode[KeyCode["Key_KP_6"] = 102] = "Key_KP_6";
        KeyCode[KeyCode["Key_KP_7"] = 103] = "Key_KP_7";
        KeyCode[KeyCode["Key_KP_8"] = 104] = "Key_KP_8";
        KeyCode[KeyCode["Key_KP_9"] = 105] = "Key_KP_9";
        KeyCode[KeyCode["Key_Multiply"] = 106] = "Key_Multiply";
        KeyCode[KeyCode["Key_Add"] = 107] = "Key_Add";
        KeyCode[KeyCode["Key_Separator"] = 108] = "Key_Separator";
        KeyCode[KeyCode["Key_Subtract"] = 109] = "Key_Subtract";
        KeyCode[KeyCode["Key_Decimal"] = 110] = "Key_Decimal";
        KeyCode[KeyCode["Key_Divide"] = 111] = "Key_Divide";
        KeyCode[KeyCode["Key_F1"] = 112] = "Key_F1";
        KeyCode[KeyCode["Key_F2"] = 113] = "Key_F2";
        KeyCode[KeyCode["Key_F3"] = 114] = "Key_F3";
        KeyCode[KeyCode["Key_F4"] = 115] = "Key_F4";
        KeyCode[KeyCode["Key_F5"] = 116] = "Key_F5";
        KeyCode[KeyCode["Key_F6"] = 117] = "Key_F6";
        KeyCode[KeyCode["Key_F7"] = 118] = "Key_F7";
        KeyCode[KeyCode["Key_F8"] = 119] = "Key_F8";
        KeyCode[KeyCode["Key_F9"] = 120] = "Key_F9";
        KeyCode[KeyCode["Key_F10"] = 121] = "Key_F10";
        KeyCode[KeyCode["Key_F11"] = 122] = "Key_F11";
        KeyCode[KeyCode["Key_F12"] = 123] = "Key_F12";
        KeyCode[KeyCode["Key_F13"] = 124] = "Key_F13";
        KeyCode[KeyCode["Key_F14"] = 125] = "Key_F14";
        KeyCode[KeyCode["Key_F15"] = 126] = "Key_F15";
        KeyCode[KeyCode["Key_F16"] = 127] = "Key_F16";
        KeyCode[KeyCode["Key_F17"] = 128] = "Key_F17";
        KeyCode[KeyCode["Key_F18"] = 129] = "Key_F18";
        KeyCode[KeyCode["Key_F19"] = 130] = "Key_F19";
        KeyCode[KeyCode["Key_F20"] = 131] = "Key_F20";
        KeyCode[KeyCode["Key_F21"] = 132] = "Key_F21";
        KeyCode[KeyCode["Key_F22"] = 133] = "Key_F22";
        KeyCode[KeyCode["Key_F23"] = 134] = "Key_F23";
        KeyCode[KeyCode["Key_F24"] = 135] = "Key_F24";
        KeyCode[KeyCode["Key_Num_Lock"] = 136] = "Key_Num_Lock";
        KeyCode[KeyCode["Key_Scroll_Lock"] = 137] = "Key_Scroll_Lock";
        KeyCode[KeyCode["Key_Mouse_Left"] = 256] = "Key_Mouse_Left";
        KeyCode[KeyCode["Key_Mouse_Right"] = 257] = "Key_Mouse_Right";
        KeyCode[KeyCode["Key_Mouse_Mid"] = 258] = "Key_Mouse_Mid";
    })(egret3d.KeyCode || (egret3d.KeyCode = {}));
    var KeyCode = egret3d.KeyCode;
    /**
     * @language zh_CN
     * @class egret3d.Input
     * @classdesc
     * 处理输入设备,鼠标.键盘.触摸。
     * @includeExample input/Input.ts
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Input = (function () {
        /**
        * @language zh_CN
        * 创建一个新的 Input 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Input() {
            var _this = this;
            /**
            * @language zh_CN
            * 当前鼠标X坐标。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.mouseX = 0;
            /**
            * @language zh_CN
            * 当前鼠标Y坐标。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.mouseY = 0;
            /**
            * @language zh_CN
            * 鼠标滚轮增量值。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.wheelDelta = 0;
            /**
            * @language zh_CN
            * 鼠标X坐标的偏移值。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.mouseOffsetX = 0;
            /**
            * @language zh_CN
            * 鼠标Y坐标的偏移值。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.mouseOffsetY = 0;
            /**
            * @language zh_CN
            * 上一次鼠标X坐标。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.mouseLastX = 0;
            /**
            * @language zh_CN
            * 上一次鼠标Y坐标。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.mouseLastY = 0;
            this._time = 0;
            this._keyStatus = {};
            this._listenerKeyClick = new Array();
            this._listenerKeyUp = new Array();
            this._listenerKeyDown = new Array();
            this._listenerSwipe = null;
            this._mouseMoveFunc = new Array();
            this._mouseWheelFunc = new Array();
            this._ondeviceorientation = new Array();
            this._ondevicemotion = new Array();
            this._listenerGamepadButtons = new Array();
            this._touchStartCallback = new Array();
            this._touchEndCallback = new Array();
            this._touchMoveCallback = new Array();
            /**
            * @language zh_CN
            * 游戏手柄Stick1事件侦听函数。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.onGamepadStick1 = null;
            /**
            * @language zh_CN
            * 游戏手柄Stick2事件侦听函数。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.onGamepadStick2 = null;
            /**
            * @language zh_CN
            * 旋转。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.rotation = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 加速度。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this._acceleration = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 重力。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.gravity = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 象限。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.quadrant = 0;
            this._gp = false;
            this._first = true;
            this._initAngle = new egret3d.Vector3D();
            this._oldPosition1 = null;
            this._oldPosition2 = null;
            window.onmousewheel = function (e) { return _this.mouseWheel(e); };
            window.onmousedown = function (e) { return _this.mouseStart(e); };
            window.onmouseup = function (e) { return _this.mouseEnd(e); };
            window.onmousemove = function (e) { return _this.mouseMove(e); };
            window.onkeydown = function (e) { return _this.keyDown(e); };
            window.onkeyup = function (e) { return _this.keyUp(e); };
            if (this.canGame()) {
                window.addEventListener("gamepadconnected", function (e) { return _this.ongamepadconnected(e); });
                window.addEventListener("gamepaddisconnected", function (e) { return _this.ongamepaddisconnected(e); });
            }
            window.ontouchstart = function (e) { return _this.touchStart(e); };
            window.ontouchend = function (e) { return _this.touchEnd(e); };
            window.ontouchmove = function (e) { return _this.touchMove(e); };
            window.ontouchcancel = function (e) { return _this.touchEnd(e); };
            window.addEventListener("deviceorientation", function (e) { return _this.ondeviceorientation(e); });
            window.addEventListener("devicemotion", function (e) { return _this.detectShake(e); });
        }
        Object.defineProperty(Input, "instance", {
            /**
            * @language zh_CN
            * 获取Input类对象的单例。
            * @returns Input
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._instance == null) {
                    this._instance = new Input();
                }
                return this._instance;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @language zh_CN
        * 添加手指按下事件。
        * @version Egret 3.0
        * @platform Web,Native
        * @param callback {Function} 手指按下事件的侦听函数
        */
        Input.prototype.addTouchStartCallback = function (callback) {
            this._touchStartCallback.push(callback);
        };
        /**
        * @language zh_CN
        * 添加手指弹起事件。
        * @version Egret 3.0
        * @platform Web,Native
        * @param callback {Function} 手指弹起事件的侦听函数
        */
        Input.prototype.addTouchEndCallback = function (callback) {
            this._touchEndCallback.push(callback);
        };
        /**
        * @language zh_CN
        * 添加手指移动事件。
        * @version Egret 3.0
        * @platform Web,Native
        * @param callback {Function} 手指移动事件的侦听函数
        */
        Input.prototype.addTouchMoveCallback = function (callback) {
            this._touchMoveCallback.push(callback);
        };
        Input.prototype.ongamepaddisconnected = function (e) {
            egret3d.Debug.instance.trace("Gamepad disconnected!");
            this._gp = false;
        };
        Input.prototype.ongamepadconnected = function (e) {
            egret3d.Debug.instance.trace("Gamepad connected!");
            this._gp = true;
        };
        /**
        * @language zh_CN
        * 游戏手柄按钮是否按下。
        * @version Egret 3.0
        * @platform Web,Native
        * @param index {number}
        * @returns {boolean}
        */
        Input.prototype.getGamepadButtonState = function (index) {
            return navigator.getGamepads()[0].buttons[index].pressed;
        };
        /**
        * @language zh_CN
        * 游戏手柄摇杆方向 Stick1 。
        * @version Egret 3.0
        * @platform Web,Native
        * @returns {Vector3D}
        */
        Input.prototype.getGamepadStick1 = function () {
            return new egret3d.Vector3D(navigator.getGamepads()[0].axes[0], navigator.getGamepads()[0].axes[1], 0);
        };
        /**
        * @language zh_CN
        * 游戏手柄摇杆方向 Stick2 。
        * @version Egret 3.0
        * @platform Web,Native
        * @returns {Vector3D}
        */
        Input.prototype.getGamepadStick2 = function () {
            return new egret3d.Vector3D(navigator.getGamepads()[0].axes[2], navigator.getGamepads()[0].axes[3], 0);
        };
        Input.prototype.canGame = function () {
            return "getGamepads" in navigator;
        };
        /**
        * @language zh_CN
        * 更新游戏手柄信息。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Input.prototype.reportOnGamepad = function () {
            if (this.canGame() && this._gp) {
                if (this.onGamepadStick1 != null) {
                    this.onGamepadStick1(this.getGamepadStick1());
                }
                if (this.onGamepadStick2 != null) {
                    this.onGamepadStick2(this.getGamepadStick2());
                }
                for (var i = 0; i < this._listenerGamepadButtons.length; ++i) {
                    this._listenerGamepadButtons[i](this.getGamepadButtonState(i));
                }
            }
        };
        Input.prototype.printout = function () {
            var html = "";
            html += "id: " + navigator.getGamepads()[0].id + "<br/>";
            var len = navigator.getGamepads()[0].buttons.length;
            for (var i = 0; i < len; i++) {
                html += "Button " + (i + 1) + ": ";
                if (this.getGamepadButtonState(i))
                    html += " pressed";
                html += "<br/>";
            }
            var v = this.getGamepadStick1();
            html += "Stick 1" + ": " + v.x + "," + v.y + "<br/>";
            v = this.getGamepadStick2();
            html += "Stick 2" + ": " + v.x + "," + v.y + "<br/>";
            egret3d.Debug.instance.trace(html);
        };
        Input.prototype.detectShake = function (evt) {
            var accl = evt.acceleration; //acceleration 排除重力影响的加速度  accelerationIncludingGravity(含重力的加速度)
            //x、y 和 z 轴方向加速
            if (accl.x > 1.5 || accl.y > 1.5 || accl.z > 1.5) {
            }
            else {
            }
            if (this._ondevicemotion && this._ondevicemotion.length > 0) {
                var x = Math.ceil(accl.x * 1000) / 1000;
                var y = Math.ceil(accl.y * 1000) / 1000;
                var z = Math.ceil(accl.z * 1000) / 1000;
                this._ondevicemotion[0](x, y, z);
            }
        };
        Input.prototype.ondeviceorientation = function (e) {
            //alpha rotation around the z-axis  between 0 and 360 degrees 
            //在围绕 z 轴旋转时（即左右旋转时），y 轴的度数差 0 到 360度 。
            //beta Rotation around the x-axis cause the beta angle to change. The range of beta is between -180 and 180 degrees 
            //在围绕 x 轴旋转时（即前后旋转时），z 轴的度数差 -180到180度。  
            //gamma The gamma angle is associated with the y-axis between -90 and 90 degrees 
            //在围绕 y 轴旋转时（即扭转设备时），z 轴的度数差 -90到90度。  
            if (this._ondeviceorientation && this._ondeviceorientation.length > 0) {
                var alpha = Math.round(e.alpha * 100) * 0.01;
                var beta = Math.round(e.beta * 100) * 0.01;
                var gamma = Math.round(e.gamma * 100) * 0.01;
                if (this._first) {
                    this._initAngle["x"] = alpha;
                    this._initAngle["y"] = beta;
                    this._initAngle["z"] = gamma;
                }
                this._delayX = alpha - this._caheX;
                this._delayY = beta - this._caheY;
                this._delayZ = gamma - this._caheZ;
                this._caheX = alpha;
                this._caheY = beta;
                this._caheZ = gamma;
                this._initAngle.x += this._delayX;
                this._initAngle.y += this._delayY;
                this._initAngle.z += this._delayZ;
                this._ondeviceorientation[0](this._initAngle);
            }
        };
        //屏幕翻转
        Input.prototype.onorientationchange = function (e) {
        };
        Input.prototype.onPinch = function (x, y, x1, y1) {
            this._oldPosition1 = new egret3d.Point(x, y);
            this._oldPosition2 = new egret3d.Point(x1, y1);
        };
        Input.prototype.onSwipe = function (x, y) {
            this.mouseX = x;
            this.mouseY = y;
            this._oldPosition1 = null;
            this._oldPosition2 = null;
            this._time = new Date().getTime();
            for (var i = 0; i < this._listenerKeyDown.length; ++i) {
                this._listenerKeyDown[i](KeyCode.Key_Mouse_Left);
            }
        };
        Input.prototype.touchStart = function (e) {
            e.preventDefault();
            var x1 = e.targetTouches[0].clientX - egret3d.Egret3DDrive.clientRect.left;
            var y1 = e.targetTouches[0].clientY - egret3d.Egret3DDrive.clientRect.top;
            if (e.targetTouches.length == 2) {
                var x2 = e.targetTouches[1].clientX - egret3d.Egret3DDrive.clientRect.left;
                var y2 = e.targetTouches[1].clientY - egret3d.Egret3DDrive.clientRect.top;
                this.onPinch(x1, y1, x2, y2);
            }
            else if (e.targetTouches.length == 1) {
                this.onSwipe(x1, y1);
            }
            for (var i = 0; i < this._touchStartCallback.length; i++) {
                this._touchStartCallback[i](e);
            }
        };
        Input.prototype.touchEnd = function (e) {
            if (e.targetTouches.length > 1) {
                var x = e.targetTouches[0].clientX - egret3d.Egret3DDrive.clientRect.left;
                var y = e.targetTouches[0].clientY - egret3d.Egret3DDrive.clientRect.top;
                var x1 = e.targetTouches[1].clientX - egret3d.Egret3DDrive.clientRect.left;
                var y1 = e.targetTouches[1].clientY - egret3d.Egret3DDrive.clientRect.top;
                this.onPinch(x, y, x1, y1);
            }
            else if (e.targetTouches.length == 1) {
                this.onSwipe(e.targetTouches[0].clientX - egret3d.Egret3DDrive.clientRect.left, e.targetTouches[0].clientY - egret3d.Egret3DDrive.clientRect.top);
            }
            else {
                this._oldPosition1 = null;
                this._oldPosition2 = null;
                this._time = 0;
                for (var i = 0; i < this._listenerKeyUp.length; ++i) {
                    this._listenerKeyUp[i](KeyCode.Key_Mouse_Left);
                }
            }
            for (var i = 0; i < this._touchEndCallback.length; i++) {
                this._touchEndCallback[i](e);
            }
        };
        Input.prototype.touchMove = function (e) {
            this.mouseLastX = this.mouseX;
            this.mouseLastY = this.mouseY;
            this.mouseX = e.targetTouches[0].clientX - egret3d.Egret3DDrive.clientRect.left;
            this.mouseY = e.targetTouches[0].clientY - egret3d.Egret3DDrive.clientRect.top;
            this.mouseOffsetX = this.mouseX - this.mouseLastX;
            this.mouseOffsetY = this.mouseY - this.mouseLastY;
            e.preventDefault();
            if (e.targetTouches.length > 1) {
                var newPosition1 = new egret3d.Point(this.mouseX, this.mouseY);
                var newPosition2 = new egret3d.Point(e.targetTouches[1].clientX - egret3d.Egret3DDrive.clientRect.left, e.targetTouches[1].clientY - egret3d.Egret3DDrive.clientRect.top);
                if (this._oldPosition1 == null)
                    this._oldPosition1 = newPosition1;
                if (this._oldPosition2 == null)
                    this._oldPosition2 = newPosition2;
                if (this.isEnlarge(this._oldPosition1, this._oldPosition2, newPosition1, newPosition2))
                    this.wheelDelta = 120;
                else
                    this.wheelDelta = -120;
                this._oldPosition1 = newPosition1;
                this._oldPosition2 = newPosition2;
                for (var i = 0; i < this._mouseWheelFunc.length; ++i) {
                    this._mouseWheelFunc[i]();
                }
            }
            else {
                this._listenerSwipe();
            }
            for (var i = 0; i < this._touchMoveCallback.length; i++) {
                this._touchMoveCallback[i](e);
            }
        };
        /**
        * @language zh_CN
        * 添加鼠标移动事件的侦听器函数。
        * @version Egret 3.0
        * @platform Web,Native
        * @param func {Function} 处理鼠标移事件的侦听器函数
        */
        Input.prototype.addListenerMouseMove = function (func) {
            this._mouseMoveFunc.push(func);
        };
        /**
        * @language zh_CN
        * 添加鼠标滚轮事件的侦听器函数。
        * @version Egret 3.0
        * @platform Web,Native
        * @param func {Function} 处理鼠标滚轮事件的侦听器函数
        */
        Input.prototype.addListenerMouseWheel = function (func) {
            this._mouseWheelFunc.push(func);
        };
        /**
        * @language zh_CN
        * 添加键盘鼠标点击事件的侦听器函数。
        * @version Egret 3.0
        * @platform Web,Native
        * @param func {Function} 处理键盘鼠标点击事件的侦听器函数
        */
        Input.prototype.addListenerKeyClick = function (func) {
            this._listenerKeyClick.push(func);
        };
        /**
        * @language zh_CN
        * 添加键盘鼠标弹起事件的侦听器函数。
        * @version Egret 3.0
        * @platform Web,Native
        * @param func {Function} 处理键盘鼠标弹起事件的侦听器函数
        */
        Input.prototype.addListenerKeyUp = function (func) {
            this._listenerKeyUp.push(func);
        };
        /**
        * @language zh_CN
        * 添加键盘鼠标按下事件的侦听器函数。
        * @version Egret 3.0
        * @platform Web,Native
        * @param func {Function} 处理键盘鼠标按下事件的侦听器函数
        */
        Input.prototype.addListenerKeyDown = function (func) {
            this._listenerKeyDown.push(func);
        };
        /**
        * @language zh_CN
        * 移动端手指划动的手势事件。
        * @version Egret 3.0
        * @platform Web,Native
        * @param func {Function} 手指划动划动的手势事件的侦听器函数
        */
        Input.prototype.addListenerSwipe = function (func) {
            this._listenerSwipe = func;
        };
        /**
        * @language zh_CN
        * 添加设备旋转事件。
        * @version Egret 3.0
        * @platform Web,Native
        * @param func {Function} 设备旋转事件的侦听器函数
        */
        Input.prototype.addListenerDeviceorientation = function (func) {
            this._ondeviceorientation.push(func);
        };
        /**
        * @language zh_CN
        * 添加设备移动事件。
        * @version Egret 3.0
        * @platform Web,Native
        * @param func {Function} 设备移动事件的侦听器函数
        */
        Input.prototype.addListenerDevicemotion = function (func) {
            this._ondevicemotion.push(func);
        };
        /**
        * @language zh_CN
        * 添加游戏手柄按钮点击事件。
        * @version Egret 3.0
        * @platform Web,Native
        * @param func {Function} 游戏手柄点击事件的侦听器函数
        */
        Input.prototype.addListenerGamePadButtons = function (func) {
            this._listenerGamepadButtons.push(func);
        };
        Input.prototype.mouseEnd = function (e) {
            this.mouseX = e.clientX - egret3d.Egret3DDrive.clientRect.left;
            this.mouseY = e.clientY - egret3d.Egret3DDrive.clientRect.top;
            var k = 0;
            switch (e.button) {
                case 0:
                    k = KeyCode.Key_Mouse_Left;
                    break;
                case 2:
                    k = KeyCode.Key_Mouse_Right;
                    break;
                case 1:
                    k = KeyCode.Key_Mouse_Mid;
                    break;
            }
            if (k != 0) {
                if (this._keyStatus[k]) {
                    for (var i = 0; i < this._listenerKeyClick.length; ++i) {
                        this._listenerKeyClick[i](k);
                    }
                }
                this._keyStatus[k] = false;
                for (var i = 0; i < this._listenerKeyUp.length; ++i) {
                    this._listenerKeyUp[i](k);
                }
            }
        };
        Input.prototype.mouseStart = function (e) {
            this.mouseX = e.clientX - egret3d.Egret3DDrive.clientRect.left;
            this.mouseY = e.clientY - egret3d.Egret3DDrive.clientRect.top;
            var k = 0;
            switch (e.button) {
                case 0:
                    k = KeyCode.Key_Mouse_Left;
                    break;
                case 2:
                    k = KeyCode.Key_Mouse_Right;
                    break;
                case 1:
                    k = KeyCode.Key_Mouse_Mid;
                    break;
            }
            if (k != 0) {
                this._keyStatus[k] = true;
                for (var i = 0; i < this._listenerKeyDown.length; ++i) {
                    this._listenerKeyDown[i](k);
                }
            }
        };
        Input.prototype.mouseMove = function (e) {
            this.mouseLastX = this.mouseX;
            this.mouseLastY = this.mouseY;
            this.mouseX = e.clientX - egret3d.Egret3DDrive.clientRect.left;
            this.mouseY = e.clientY - egret3d.Egret3DDrive.clientRect.top;
            this.mouseOffsetX = this.mouseX - this.mouseLastX;
            this.mouseOffsetY = this.mouseY - this.mouseLastY;
            for (var i = 0; i < this._mouseMoveFunc.length; ++i) {
                this._mouseMoveFunc[i](e);
            }
        };
        Input.prototype.mouseWheel = function (e) {
            this.wheelDelta = e.wheelDelta;
            for (var i = 0; i < this._mouseWheelFunc.length; ++i) {
                this._mouseWheelFunc[i]();
            }
        };
        Input.prototype.keyDown = function (e) {
            this._keyStatus[e.keyCode] = true;
            for (var i = 0; i < this._listenerKeyDown.length; ++i) {
                this._listenerKeyDown[i](e.keyCode);
            }
        };
        Input.prototype.keyUp = function (e) {
            if (this._keyStatus[e.keyCode]) {
                for (var i = 0; i < this._listenerKeyClick.length; ++i) {
                    this._listenerKeyClick[i](e.keyCode);
                }
            }
            this._keyStatus[e.keyCode] = false;
            for (var i = 0; i < this._listenerKeyUp.length; ++i) {
                this._listenerKeyUp[i](e.keyCode);
            }
        };
        //返回角度
        Input.prototype.GetSlideAngle = function (dx, dy) {
            return Math.atan2(dy, dx) * 180 / Math.PI;
        };
        /**
        * @language zh_CN
        * 根据起点和终点返回方向
        * @param  startX {Number} 起点X坐标
        * @param  startY {Number} 起点Y坐标
        * @param  endX   {Number} 终点X坐标
        * @param  endY   {Number} 终点Y坐标
        * @returns result {number} 1：向上，2：向下，3：向左，4：向右,0：未滑动
        */
        Input.prototype.GetSlideDirection = function (startX, startY, endX, endY) {
            var dy = startY - endY;
            var dx = endX - startX;
            var result = 0;
            //如果滑动距离太短
            if (Math.abs(dx) < 2 && Math.abs(dy) < 2) {
                return result;
            }
            var angle = this.GetSlideAngle(dx, dy);
            if (angle >= -45 && angle < 45) {
                result = 4;
            }
            else if (angle >= 45 && angle < 135) {
                result = 1;
            }
            else if (angle >= -135 && angle < -45) {
                result = 2;
            }
            else if ((angle >= 135 && angle <= 180) || (angle >= -180 && angle < -135)) {
                result = 3;
            }
            return result;
        };
        Input.prototype.isEnlarge = function (op1, op2, np1, np2) {
            //函数传入上一次触摸两点的位置与本次触摸两点的位置计算出用户的手势
            var leng1 = Math.sqrt((op1.x - op2.x) * (op1.x - op2.x) + (op1.y - op2.y) * (op1.y - op2.y));
            var leng2 = Math.sqrt((np1.x - np2.x) * (np1.x - np2.x) + (np1.y - np2.y) * (np1.y - np2.y));
            if (leng1 < leng2) {
                //放大手势
                return true;
            }
            else {
                //缩小手势
                return false;
            }
        };
        Input._instance = null;
        return Input;
    })();
    egret3d.Input = Input;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @language zh_CN
     * @class egret3d.OrientationController
     * @classdesc
     * 陀螺仪控制器
     */
    var OrientationController = (function () {
        /**
        * @language zh_CN
        * constructor
        */
        function OrientationController() {
            this.orientation = new egret3d.Vector3D();
            this.screenOrientation = 0;
            this.openDebug = false;
            /**
            * @language zh_CN
            * 偏移旋转
            */
            this.offsetRotation = new egret3d.Vector3D();
            /**
            * @language zh_CN
            * 陀螺仪当前旋转角度
            */
            this.fixOritation = new egret3d.Vector3D();
            this.state = -1;
            this.degtorad = Math.PI / 180; // Degree-to-Radian conversion
            this.q = new egret3d.Quaternion();
            this.q1 = new egret3d.Quaternion();
            this.outQ = new egret3d.Quaternion();
            this.front = new egret3d.Vector3D(0, 0, 200);
            this.test = new egret3d.Vector3D();
            if (this.openDebug) {
                this.accDiv = document.createElement("div");
                this.accGravityDiv = document.createElement("div");
                this.rotationRateDiv = document.createElement("div");
                this.orientationRateDiv = document.createElement("div");
                this.stateDiv = document.createElement("div");
                this.accDiv.style.color = "red";
                this.accGravityDiv.style.color = "red";
                this.rotationRateDiv.style.color = "red";
                this.orientationRateDiv.style.color = "red";
                this.stateDiv.style.color = "red";
                this.stateDiv.style.fontSize = "52";
                document.body.appendChild(this.accDiv);
                document.body.appendChild(this.accGravityDiv);
                document.body.appendChild(this.rotationRateDiv);
                document.body.appendChild(this.orientationRateDiv);
                document.body.appendChild(this.stateDiv);
            }
        }
        /**
        * @language zh_CN
        * 初始化
        */
        OrientationController.prototype.start = function () {
            var _this = this;
            this.orientationchangeHandler();
            window.addEventListener("orientationchange", function () { return _this.orientationchangeHandler(); });
            window.addEventListener("devicemotion", function (e) { return _this.motionHandler(e); });
            window.addEventListener("deviceorientation", function (e) { return _this.orientationHandler(e); });
        };
        /**
        * @language zh_CN
        * 释放
        */
        OrientationController.prototype.stop = function () {
            var _this = this;
            window.removeEventListener("orientationchange", function () { return _this.orientationchangeHandler(); });
            window.removeEventListener("devicemotion", function (e) { return _this.motionHandler(e); });
            window.removeEventListener("deviceorientation", function (e) { return _this.orientationHandler(e); });
        };
        /**
        * @language zh_CN
        */
        OrientationController.prototype.orientationchangeHandler = function () {
            //if (window.orientation != undefined)
            //  this.screenOrientation = <number>window.orientation ;
            //.this.state = window.orientation;
        };
        /**
        * @language zh_CN
        *
        * @param event
        */
        OrientationController.prototype.motionHandler = function (event) {
            this.acc = event.acceleration;
            this.accGravity = event.accelerationIncludingGravity;
            this.rotationRate = event.rotationRate;
        };
        /**
        * @language zh_CN
        *
        * @param event
        * @returns
        */
        OrientationController.prototype.orientationHandler = function (event) {
            this.orientation.x = event.alpha;
            this.orientation.y = event.beta;
            this.orientation.z = event.gamma;
            if (this.openDebug)
                this.debug();
        };
        OrientationController.prototype.debug = function () {
            //this.accDiv.innerHTML = "<br><br><br> acc-x:" + this.acc.x + "<br>acc-y:" + this.acc.y + "<br>acc-z:" + this.acc.z ;
            this.accGravityDiv.innerHTML = "<br><br> Gravity-x:" + this.orientation.x * egret3d.Matrix3DUtils.RADIANS_TO_DEGREES + "<br>Gravity-y:" + this.orientation.y + "<br>Gravity-z:" + this.orientation.z;
            //this.rotationRateDiv.innerHTML = "<br> Rate-x:" + this.rotationRate.alpha + "<br>Rate-y:" + this.rotationRate.gamma + "<br>Rate-z:" + this.rotationRate.beta;
            this.orientationRateDiv.innerHTML = "<br> orientation-x:" + this.fixOritation.x + "<br>orientation-y:" + this.fixOritation.y + "<br>orientation-z:" + this.fixOritation.z;
            //this.orientationRateDiv.innerHTML = "<br> orientation-x:" + this.fixOritation.x * Matrix3DUtils.RADIANS_TO_DEGREES + "<br>orientation-y:" + this.fixOritation.y * Matrix3DUtils.RADIANS_TO_DEGREES + "<br>orientation-z:" + this.fixOritation.z * Matrix3DUtils.RADIANS_TO_DEGREES;
            this.stateDiv.innerHTML = "<br> state: " + this.state;
        };
        /**
        * @language zh_CN
        *
        * @returns number
        */
        OrientationController.prototype.getOrientation = function () {
            switch (window.screen.msOrientation) {
                case 'landscape-primary':
                    return -90;
                case 'landscape-secondary':
                    return 90;
                case 'portrait-secondary':
                    return 180;
                case 'portrait-primary':
                    return 0;
            }
            // this returns 90 if width is greater then height 
            // and window orientation is undefined OR 0
            // if (!window.orientation && window.innerWidth > window.innerHeight)
            //   return 90;<number>window.orientation ||
            return 0;
        };
        /**
        * @language zh_CN
        * 由陀螺仪的角度值计算出旋转四元数
        * @param alpha
        * @param beta
        * @param gamma
        * @returns 旋转四元数
        */
        OrientationController.prototype.getQuaternion = function (alpha, beta, gamma) {
            var _x = beta ? beta * this.degtorad : 0; // beta value
            var _y = gamma ? gamma * this.degtorad : 0; // gamma value
            var _z = alpha ? alpha * this.degtorad : 0; // alpha value
            var orient = -this.getOrientation() * this.degtorad; // this.getOrientation()) * this.degtorad ; // O
            this.state = this.getOrientation();
            var cX = Math.cos(_x / 2);
            var cY = Math.cos(_y / 2);
            var cZ = Math.cos(_z / 2);
            var sX = Math.sin(_x / 2);
            var sY = Math.sin(_y / 2);
            var sZ = Math.sin(_z / 2);
            //this.q1.fromAxisAngle(Vector3D.Y_AXIS, alpha * this.degtorad);
            //
            // ZXY quaternion construction.
            //
            this.q.w = cX * cY * cZ - sX * sY * sZ;
            this.q.x = sX * cY * cZ - cX * sY * sZ;
            this.q.y = cX * sY * cZ + sX * cY * sZ;
            this.q.z = cX * cY * sZ + sX * sY * cZ;
            var zee = new egret3d.Vector3D(0, 0, 1);
            var q0 = new egret3d.Quaternion();
            q0.fromAxisAngle(zee, orient / egret3d.Matrix3DUtils.DEGREES_TO_RADIANS);
            this.q.multiply(this.q, q0); // camera looks out the back of the device, not the top
            zee.setTo(-1, 0, 0);
            q0.fromAxisAngle(zee, 90 * this.degtorad / egret3d.Matrix3DUtils.DEGREES_TO_RADIANS);
            this.q.multiply(this.q, q0);
            return this.q;
        };
        /**
        * @language zh_CN
        * 数据更新
        * @param camera3D 当前相机
        */
        OrientationController.prototype.update = function (camera3D) {
            this.getQuaternion(this.orientation.x, this.orientation.y, this.orientation.z);
            this.q.toEulerAngles(this.fixOritation);
            camera3D.rotationX = -this.fixOritation.x + this.offsetRotation.x;
            camera3D.rotationZ = -this.fixOritation.y + this.offsetRotation.z;
            camera3D.rotationY = -this.fixOritation.z + this.offsetRotation.y;
        };
        return OrientationController;
    })();
    egret3d.OrientationController = OrientationController;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
    * @language zh_CN
    * @class egret3d.AudioManager
    * @classdesc
    * AudioManager 类允许您在应用程序中 播放 HTML5 Audio 和 Web Audio。
    * @includeExample audio/AudioManager.ts
    * @version Egret 3.0
    * @platform Web,Native
    */
    var AudioManager = (function () {
        /**
        * @language zh_CN
        * 创建一个新的 AudioManager 对象。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function AudioManager() {
            /**
            * @language zh_CN
            * 音量，范围从 0（静音）至 1（最大幅度）。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.volume = 1;
            this.codecs = {};
            if (this.hasAudioContext()) {
                if (typeof AudioContext !== 'undefined') {
                    this.context = new AudioContext();
                }
            }
        }
        /**
        * @language zh_CN
        * 是否支持 HTML5 Audio tag API。
        * @returns {boolean}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.hasAudio = function () {
            return (typeof Audio !== 'undefined');
        };
        /**
        * @language zh_CN
        * 是否支持 Web Audio API。
        * @returns {boolean}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.hasAudioContext = function () {
            return !!(typeof AudioContext !== 'undefined');
        };
        /**
        * @language zh_CN
        * 浏览器是否可以播放这种音频类型。
        * @param url 指向外部音频文件的 URL。
        * @param audio {HTMLAudioElement} HTMLAudio元素
        * @returns {boolean}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.isSupported = function (url, audio) {
            if (this.codecs == null) {
                if (audio == null)
                    audio = new Audio();
                this.codecs = {
                    mp3: !!audio.canPlayType('audio/mpeg;').replace(/^no$/, ''),
                    opus: !!audio.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
                    ogg: !!audio.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
                    wav: !!audio.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
                    aac: !!audio.canPlayType('audio/aac;').replace(/^no$/, ''),
                    m4a: !!(audio.canPlayType('audio/x-m4a;') || audio.canPlayType('audio/m4a;') || audio.canPlayType('audio/aac;')).replace(/^no$/, ''),
                    mp4: !!(audio.canPlayType('audio/x-mp4;') || audio.canPlayType('audio/mp4;') || audio.canPlayType('audio/aac;')).replace(/^no$/, ''),
                    weba: !!audio.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')
                };
            }
            var ext = url.match(/^data:audio\/([^;,]+);/i);
            if (!ext) {
                ext = url.split('?', 1)[0].match(/\.([^.]+)$/);
            }
            if (ext) {
                ext = ext[1].toLowerCase();
            }
            return this.codecs[ext];
        };
        /**
        * @language zh_CN
        * 生成一个新的 Sound 对象 ，将声音数据加载到 Sound 对象中。
        * @param url {String}   指向外部音频文件的 URL。
        * @param success {Function} 一个可选的音频文件加载成功的事件处理函数。
        * @param error {Function} 一个可选的音频文件加载失败的事件处理函数。
        * @returns {Sound}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.createSound = function (url, success, error) {
            if (success === void 0) { success = null; }
            if (error === void 0) { error = null; }
            return new egret3d.Sound(url, success, error);
        };
        /**
        * @language zh_CN
        * 生成一个新的 Channel 对象来播放该声音。此方法返回 Channel 对象，访问该对象可停止声音并监控音量。
        * @param sound{Sound} 要播放的声音数据。
        * @param options{any}   ["volume":1,"loop":true volume] 回放音量, 0 到 1 ， loop 是否循环播放。
        * @returns {Channel}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.playSound = function (sound, options) {
            options = options || {};
            var channel = new egret3d.Channel(sound, options);
            channel.play();
            return channel;
        };
        /**
        * @language zh_CN
        * 生成一个新的 Channel3d 对象来播放该声音。此方法返回 Channel3d 对象，访问该对象可停止声音并监控音量。
        * @param sound {Sound}  要播放的声音数据。
        * @param position {Vector3D} 在三维空间中播放的位置。
        * @param options {any} ["volume":1,"loop":true volume] 回放音量, 0 到 1 ， loop 是否循环播放。
        * @returns {Channel}
        * @version Egret 3.0
        * @platform Web,Native
        */
        AudioManager.prototype.playSound3d = function (sound, position, options) {
            options = options || {};
            var channel = new egret3d.Channel3d(sound, options);
            channel.position = position;
            if (options.volume) {
                channel.volume = options.volume;
            }
            if (options.loop) {
                channel.loop = options.loop;
            }
            if (options.maxDistance) {
                channel.maxDistance = options.maxDistance;
            }
            if (options.minDistance) {
                channel.minDistance = options.minDistance;
            }
            if (options.rollOffFactor) {
                channel.rollOffFactor = options.rollOffFactor;
            }
            channel.play();
            return channel;
        };
        Object.defineProperty(AudioManager, "instance", {
            /**
            * @language zh_CN
            * AudioManager类的单例模式，返回一个 AudioManager 对象。
            * @returns AudioManager
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                if (this._instance == null) {
                    this._instance = new AudioManager();
                }
                return this._instance;
            },
            enumerable: true,
            configurable: true
        });
        return AudioManager;
    })();
    egret3d.AudioManager = AudioManager;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Channel
     * @classdesc
     * Channel 类控制应用程序中的声音，对声音执行更精细的控制。每个声音均分配给一个声道，而且应用程序可以具有混合在一起的多个声道。
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Channel = (function () {
        /**
        * @language zh_CN
        * 创建一个新的 Channel 对象。
        * @param sound {Sound} Sound 对象 音频的数据源。
        * @param {Object} options {any} ["volume":1,"loop":true volume] 回放音量, 0 到 1 ， loop 是否循环播放。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Channel(sound, options) {
            /**
            * @language zh_CN
            * 音量，范围从 0（静音）至 1（最大幅度）。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.volume = 1.0;
            /**
            * @language zh_CN
            * 是否循环播放 使声音播放结束时重新开始播放。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.loop = false;
            /**
            * @language zh_CN
            * 当前播放速度。1.0 正常速度。0.5 半速（更慢）。2.0 倍速（更快）。-1.0 向后。正常速度。-0.5 向后，半速。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.pitch = 1.0;
            options = options || {};
            if (options.volume)
                this.volume = options.volume;
            if (options.loop)
                this.loop = options.loop;
            if (options.pitch)
                this.pitch = options.pitch;
            this.sound = sound;
            this.paused = false;
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                this.context = egret3d.AudioManager.instance.context;
                this.startTime = 0;
                this.startOffset = 0;
                this.source = null;
                this.gain = this.context.createGain();
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.sound.audio) {
                    this.source = this.sound.audio.cloneNode(false);
                    this.source.pause();
                }
            }
        }
        /**
        * @language zh_CN
        * 开始在该声道中播放声音。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.play = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    throw new Error("Call stop() before calling play()");
                }
                this.createSource();
                if (!this.source) {
                    return;
                }
                this.startTime = this.context.currentTime;
                this.source.start(0, this.startOffset % this.source.buffer.duration);
            }
            else if (egret3d.AudioManager.instance.hasAudio) {
                this.paused = false;
                this.source.play();
            }
            this.setVolume(this.volume);
            this.setLoop(this.loop);
            this.setPitch(this.pitch);
        };
        /**
        * @language zh_CN
        * 暂时停止在该声道中播放声音。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.pause = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    this.startOffset += this.context.currentTime - this.startTime;
                    this.source.stop(0);
                    this.source = null;
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.source) {
                    this.source.pause();
                }
            }
            this.paused = true;
        };
        /**
        * @language zh_CN
        * 从暂停的位置继续在该声道中播放声音。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.unpause = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source || !this.paused) {
                    throw new Error('Call pause() before unpausing.');
                }
                this.createSource();
                if (!this.source) {
                    return;
                }
                this.startTime = this.context.currentTime;
                this.source.start(0, this.startOffset % this.source.buffer.duration);
                // Initialize volume and loop
                this.setVolume(this.volume);
                this.setLoop(this.loop);
                this.setPitch(this.pitch);
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                this.source.play();
            }
            this.paused = false;
        };
        /**
        * @language zh_CN
        * 停止在该声道中播放声音。
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.stop = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    this.source.stop(0);
                    this.startOffset = 0;
                    this.source = null;
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.source) {
                    this.source.pause();
                    this.source.currentTime = 0;
                }
            }
        };
        Channel.prototype.setLoop = function (value) {
            if (this.source) {
                this.source.loop = value;
            }
        };
        Channel.prototype.setVolume = function (value) {
            if (this.gain) {
                this.gain.gain.value = value * egret3d.AudioManager.instance.volume;
            }
            else if (this.source) {
                this.source.volume = value * egret3d.AudioManager.instance.volume;
            }
        };
        Channel.prototype.setPitch = function (value) {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    this.source.playbackRate.value = value;
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.source) {
                    this.source.playbackRate = value;
                }
            }
        };
        /**
        * @language zh_CN
        * 是否正在播放。
        * @returns {boolean}
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.isPlaying = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                return (!this.paused);
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                return (!this.source.paused);
            }
        };
        /**
        * @language zh_CN
        * 音频持续时间。
        * @returns {number}
        * @version Egret 3.0
        * @platform Web,Native
        */
        Channel.prototype.getDuration = function () {
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (this.source) {
                    return this.source.buffer.duration;
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                if (this.source) {
                    var d = this.source.duration;
                    if (d === d) {
                        return d;
                    }
                }
            }
            return 0;
        };
        Channel.prototype.createSource = function () {
            var _this = this;
            if (this.sound.buffer) {
                this.source = this.context.createBufferSource();
                this.source.buffer = this.sound.buffer;
                this.source.connect(this.gain);
                this.gain.connect(this.context.destination);
                if (this.loop) {
                    this.source.onended = function () { return _this.play(); };
                }
            }
        };
        return Channel;
    })();
    egret3d.Channel = Channel;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Channel3d
     * @classdesc
     * Channel3d 类控制应用程序中 在三维空间中播放的声音。每个声音均分配给一个声道，而且应用程序可以具有混合在一起的多个声道。
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Channel3d = (function (_super) {
        __extends(Channel3d, _super);
        /**
        * @language zh_CN
        * 创建一个新的 Channel3d 对象。
        * @param sound {Sound} Sound 对象 音频的数据源。
        * @param {Object} options {any} ["volume":1,"loop":true volume] 回放音量, 0 到 1 ， loop 是否循环播放。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Channel3d(sound, options) {
            _super.call(this, sound, options);
            this._position = new egret3d.Vector3D();
            this._velocity = new egret3d.Vector3D();
            if (egret3d.AudioManager.instance.hasAudioContext())
                this._panner = this.context.createPanner();
            this._maxDistance = 10000; // default maxDistance
            this._minDistance = 1;
            this._rollOffFactor = 1;
            this._listener = new egret3d.Vector3D();
        }
        Object.defineProperty(Channel3d.prototype, "listener", {
            /**
            * @language zh_CN
            * 返回监听者位置。
            * @returns {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._listener;
            },
            /**
            * @language zh_CN
            * 设置监听者位置。
            * @param value {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (value) {
                this._listener.copyFrom(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "position", {
            /**
            * @language zh_CN
            * 三维空间中的位置。
            * @returns {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._position;
            },
            /**
            * @language zh_CN
            * 三维空间中的位置。
            * @param opsition {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (position) {
                this._position.copyFrom(position);
                if (egret3d.AudioManager.instance.hasAudioContext()) {
                    this._panner.setPosition(position.x, position.y, position.z);
                }
                if (egret3d.AudioManager.instance.hasAudio()) {
                    if (this.source) {
                        var factor = this.fallOff(this._listener, this.position, this.minDistance, this.maxDistance, this.rollOffFactor);
                        this.source.volume = this.volume * factor;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "velocity", {
            /**
            * @language zh_CN
            * 传播方向。
            * @returns {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._velocity;
            },
            /**
            * @language zh_CN
            * 传播方向。
            * @param velocity {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (velocity) {
                this._velocity.copyFrom(velocity);
                if (egret3d.AudioManager.instance.hasAudioContext())
                    this._panner.setVelocity(velocity.x, velocity.y, velocity.z);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "maxDistance", {
            /**
            * @language zh_CN
            * 最大距离。
            * @returns {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._maxDistance;
            },
            /**
            * @language zh_CN
            * 最大距离。
            * @param max{Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (max) {
                this._maxDistance = max;
                if (egret3d.AudioManager.instance.hasAudioContext())
                    this._panner.maxDistance = max;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "minDistance", {
            /**
            * @language zh_CN
            * 最小距离。
            * @returns {Vector3D}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._minDistance;
            },
            /**
            * @language zh_CN
            * 最小距离。
            * @param min{Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (min) {
                this._minDistance = min;
                if (egret3d.AudioManager.instance.hasAudioContext())
                    this._panner.refDistance = min;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Channel3d.prototype, "rollOffFactor", {
            /**
            * @language zh_CN
            * rollOff 系数。
            * @returns {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._rollOffFactor;
            },
            /**
            * @language zh_CN
            * rollOff 系数。
            * @param factor {Number}
            * @version Egret 3.0
            * @platform Web,Native
            */
            set: function (factor) {
                this._rollOffFactor = factor;
                if (this._panner)
                    this._panner.rolloffFactor = factor;
            },
            enumerable: true,
            configurable: true
        });
        Channel3d.prototype.createSource = function () {
            this.source = this.context.createBufferSource();
            this.source.buffer = this.sound.buffer;
            // Connect up the nodes
            this.source.connect(this._panner);
            this._panner.connect(this.gain);
            this.gain.connect(this.context.destination);
        };
        // Fall off function which should be the same as the one in the Web Audio API,
        // taken from OpenAL
        Channel3d.prototype.fallOff = function (posOne, posTwo, refDistance, maxDistance, rolloffFactor) {
            var distance = egret3d.Vector3D.distance(posOne, posTwo);
            if (distance < refDistance) {
                return 1;
            }
            else if (distance > maxDistance) {
                return 0;
            }
            else {
                var numerator = refDistance + (rolloffFactor * (distance - refDistance));
                if (numerator !== 0) {
                    return refDistance / numerator;
                }
                else {
                    return 1;
                }
            }
        };
        return Channel3d;
    })(egret3d.Channel);
    egret3d.Channel3d = Channel3d;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @language zh_CN
     * @class egret3d.Sound
     * @classdesc
     * Sound 类允许您在应用程序中使用声音。使用 Sound 类可以创建 Sound 对象、将外部 MP3 文件加载到该对象并播放该文件、关闭声音流，以及访问有关声音的数据，如有关流中字节数和 ID3 元数据的信息。可通过以下项对声音执行更精细的控制：声音源（声音的 Channel 和 Channel3d）用于控制向计算机扬声器输出声音的属性。
     * @version Egret 3.0
     * @platform Web,Native
     */
    var Sound = (function () {
        /**
        * @language zh_CN
        * 创建一个新的 Sound 对象。一旦某个 Sound 对象加载完成声音文件，就不能再将另一个声音文件加载到该 Sound 对象中。要加载另一个声音文件，请创建新的 Sound 对象。
        * @param {String}   指向外部音频文件的 URL。
        * @param {Function} 一个可选的音频文件加载成功的事件处理函数。
        * @param {Function} 一个可选的音频文件加载失败的事件处理函数。
        * @version Egret 3.0
        * @platform Web,Native
        */
        function Sound(url, success, error) {
            var _this = this;
            if (success === void 0) { success = null; }
            if (error === void 0) { error = null; }
            /**
            * @language zh_CN
            * HTML音频 数据源。
            * @version Egret 3.0
            * @platform Web,Native
            */
            this.audio = null;
            this._success = success;
            this._error = error;
            this.isLoaded = false;
            if (egret3d.AudioManager.instance.hasAudioContext()) {
                if (egret3d.AudioManager.instance.isSupported(url, this.audio)) {
                    console.warn('Audio format not supported');
                    error(this);
                }
                else {
                    if (egret3d.AudioManager.instance.context) {
                        this.loadAudioFile(url);
                    }
                }
            }
            else if (egret3d.AudioManager.instance.hasAudio()) {
                try {
                    this.audio = new Audio();
                }
                catch (e) {
                    console.warn("No support for Audio element");
                    if (error)
                        error(this);
                    return;
                }
                if (egret3d.AudioManager.instance.isSupported(url, this.audio)) {
                    console.warn('Audio format not supported');
                    if (error)
                        error(this);
                }
                else {
                    this.audio.src = url;
                    this.audio.addEventListener("canplaythrough", function (ev) { return _this.oncanplaythrough(ev); });
                    this.audio.addEventListener("ended", function (ev) { return _this.onended(ev); });
                    this.audio.load();
                }
            }
        }
        Object.defineProperty(Sound.prototype, "buffer", {
            /**
            * @language zh_CN
            * Web音频 数据源。
            * @returns {AudioBuffer}
            * @version Egret 3.0
            * @platform Web,Native
            */
            get: function () {
                return this._buffer;
            },
            enumerable: true,
            configurable: true
        });
        Sound.prototype.loadAudioFile = function (url) {
            var _this = this;
            if (this.xhr == null)
                this.xhr = new XMLHttpRequest(); //通过XHR下载音频文件
            this.xhr.open('GET', url, true);
            this.xhr.responseType = 'arraybuffer';
            this.xhr.onload = function (e) { return _this.audioLoadend(e); };
            this.xhr.send();
        };
        Sound.prototype.audioLoadend = function (e) {
            var _this = this;
            egret3d.AudioManager.instance.context.decodeAudioData(this.xhr.response, function (buffer) { return _this.decodeSuccessCallback(buffer); });
        };
        Sound.prototype.decodeSuccessCallback = function (buffer) {
            this._buffer = buffer;
            if (this._success)
                this._success(this);
        };
        Sound.prototype.onended = function (ev) {
        };
        Sound.prototype.oncanplaythrough = function (ev) {
            if (!this.isLoaded) {
                this.isLoaded = true;
                if (this._success)
                    this._success(this);
            }
        };
        return Sound;
    })();
    egret3d.Sound = Sound;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     * @class egret3D.Egret3DEngine
     * @classdesc
     * 引擎库文件加载
     * 引擎库前期加载设置，开发中加载未压缩的编译引擎
     */
    var Egret3DEngine = (function () {
        function Egret3DEngine() {
        }
        Egret3DEngine.getXHR = function () {
            var xhr = null;
            if (window["XMLHttpRequest"]) {
                xhr = new window["XMLHttpRequest"]();
            }
            else {
                xhr = new ActiveXObject("MSXML2.XMLHTTP");
            }
            return xhr;
        };
        /**
         * @language zh_CN
         * 请求读取
         * @event complete 读取完成响应回调
         */
        Egret3DEngine.preload = function (complete) {
            this._complete = complete;
            if (this._xhr == null) {
                this._xhr = this.getXHR();
            }
            if (this._xhr == null) {
                alert("Your browser does not support XMLHTTP.");
                return;
            }
            if (this._xhr.readyState > 0) {
                this._xhr.abort();
            }
            this._xhr.open("GET", this._libUrl, true);
            this._xhr.addEventListener("progress", function (e) { return Egret3DEngine.onProgress(e); }, false);
            this._xhr.addEventListener("readystatechange", function (e) { return Egret3DEngine.onReadyStateChange(e); }, false);
            this._xhr.addEventListener("error", function (e) { return Egret3DEngine.onError(e); }, false);
            this._xhr.responseType = "text";
            this._xhr.send();
        };
        Egret3DEngine.onReadyStateChange = function (event) {
            if (this._xhr.readyState == 4) {
                if (this._xhr.status >= 400 || this._xhr.status == 0) {
                    console.log(this._libUrl, "load fail");
                }
                else {
                    this.loadComplete();
                }
            }
        };
        Egret3DEngine.loadComplete = function () {
            var libTex = this._xhr.responseText;
            this.applyClass(libTex);
        };
        Egret3DEngine.onProgress = function (event) {
            var e = event.loaded.toString() + event.total;
            console.log("progress event```" + e);
        };
        Egret3DEngine.onError = function (event) {
            console.log("load error", event);
        };
        Egret3DEngine.applyClass = function (source) {
            this.importList = source.split("///");
            this.importList.shift();
            for (var i = 0; i < this.importList.length; i++) {
                this.importList[i] = this.importList[i].replace("\r\n", "");
                this.importList[i] = this.importList[i].replace("import ", "/js/");
            }
            this.importList.pop();
            this.startLoadScript(null);
        };
        Egret3DEngine.startLoadScript = function (e) {
            var _this = this;
            if (this.importList.length > 0) {
                var egret3DScript = document.createElement("script");
                egret3DScript.src = this.importList.shift();
                egret3DScript.onload = function (e) { return _this.startLoadScript(e); };
                egret3DScript.onerror = function (e) { return _this.loadScriptError(e); };
                document.head.appendChild(egret3DScript);
            }
            else {
                console.log("all complete");
                this._complete();
            }
        };
        Egret3DEngine.loadScriptError = function (e) {
            var error = "load Script Error \r\n no file:" + e.srcElement.src;
            alert(error);
            this.startLoadScript(null);
        };
        Egret3DEngine.djs = "";
        Egret3DEngine._libUrl = "/js/Egret3D/Egret3D.lib.js";
        return Egret3DEngine;
    })();
    egret3d.Egret3DEngine = Egret3DEngine;
})(egret3d || (egret3d = {}));
